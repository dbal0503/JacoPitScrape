<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RandomDataImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math.random</a> &gt; <span class="el_source">RandomDataImpl.java</span></div><h1>RandomDataImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math.random;

import java.io.Serializable;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.SecureRandom;
import java.util.Collection;

import org.apache.commons.math.distribution.BetaDistribution;
import org.apache.commons.math.distribution.BinomialDistribution;
import org.apache.commons.math.distribution.CauchyDistribution;
import org.apache.commons.math.distribution.ChiSquaredDistribution;
import org.apache.commons.math.distribution.ContinuousDistribution;
import org.apache.commons.math.distribution.FDistribution;
import org.apache.commons.math.distribution.HypergeometricDistribution;
import org.apache.commons.math.distribution.IntegerDistribution;
import org.apache.commons.math.distribution.PascalDistribution;
import org.apache.commons.math.distribution.TDistribution;
import org.apache.commons.math.distribution.WeibullDistribution;
import org.apache.commons.math.distribution.ZipfDistribution;
import org.apache.commons.math.exception.MathInternalError;
import org.apache.commons.math.exception.NotStrictlyPositiveException;
import org.apache.commons.math.exception.NumberIsTooLargeException;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.util.ArithmeticUtils;
import org.apache.commons.math.util.FastMath;
import org.apache.commons.math.util.ResizableDoubleArray;

/**
 * Implements the {@link RandomData} interface using a {@link RandomGenerator}
 * instance to generate non-secure data and a {@link java.security.SecureRandom}
 * instance to provide data for the &lt;code&gt;nextSecureXxx&lt;/code&gt; methods. If no
 * &lt;code&gt;RandomGenerator&lt;/code&gt; is provided in the constructor, the default is
 * to use a {@link Well19937c} generator. To plug in a different
 * implementation, either implement &lt;code&gt;RandomGenerator&lt;/code&gt; directly or
 * extend {@link AbstractRandomGenerator}.
 * &lt;p&gt;
 * Supports reseeding the underlying pseudo-random number generator (PRNG). The
 * &lt;code&gt;SecurityProvider&lt;/code&gt; and &lt;code&gt;Algorithm&lt;/code&gt; used by the
 * &lt;code&gt;SecureRandom&lt;/code&gt; instance can also be reset.
 * &lt;/p&gt;
 * &lt;p&gt;
 * For details on the default PRNGs, see {@link java.util.Random} and
 * {@link java.security.SecureRandom}.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;Usage Notes&lt;/strong&gt;:
 * &lt;ul&gt;
 * &lt;li&gt;
 * Instance variables are used to maintain &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances used in data generation. Therefore, to
 * generate a random sequence of values or strings, you should use just
 * &lt;strong&gt;one&lt;/strong&gt; &lt;code&gt;RandomDataImpl&lt;/code&gt; instance repeatedly.&lt;/li&gt;
 * &lt;li&gt;
 * The &quot;secure&quot; methods are *much* slower. These should be used only when a
 * cryptographically secure random sequence is required. A secure random
 * sequence is a sequence of pseudo-random values which, in addition to being
 * well-dispersed (so no subsequence of values is an any more likely than other
 * subsequence of the the same length), also has the additional property that
 * knowledge of values generated up to any point in the sequence does not make
 * it any easier to predict subsequent values.&lt;/li&gt;
 * &lt;li&gt;
 * When a new &lt;code&gt;RandomDataImpl&lt;/code&gt; is created, the underlying random
 * number generators are &lt;strong&gt;not&lt;/strong&gt; initialized. If you do not
 * explicitly seed the default non-secure generator, it is seeded with the
 * current time in milliseconds plus the system identity hash code on first use.
 * The same holds for the secure generator. If you provide a &lt;code&gt;RandomGenerator&lt;/code&gt;
 * to the constructor, however, this generator is not reseeded by the constructor
 * nor is it reseeded on first use.&lt;/li&gt;
 * &lt;li&gt;
 * The &lt;code&gt;reSeed&lt;/code&gt; and &lt;code&gt;reSeedSecure&lt;/code&gt; methods delegate to the
 * corresponding methods on the underlying &lt;code&gt;RandomGenerator&lt;/code&gt; and
 * &lt;code&gt;SecureRandom&lt;/code&gt; instances. Therefore, &lt;code&gt;reSeed(long)&lt;/code&gt;
 * fully resets the initial state of the non-secure random number generator (so
 * that reseeding with a specific value always results in the same subsequent
 * random sequence); whereas reSeedSecure(long) does &lt;strong&gt;not&lt;/strong&gt;
 * reinitialize the secure random number generator (so secure sequences started
 * with calls to reseedSecure(long) won't be identical).&lt;/li&gt;
 * &lt;li&gt;
 * This implementation is not synchronized.
 * &lt;/ul&gt;
 * &lt;/p&gt;
 *
 * @version $Id$
 */
public class RandomDataImpl implements RandomData, Serializable {

    /** Serializable version identifier */
    private static final long serialVersionUID = -626730818244969716L;

    /** Used when generating Exponential samples
     * [1] writes:
     * One table containing the constants
     * q_i = sum_{j=1}^i (ln 2)^j/j! = ln 2 + (ln 2)^2/2 + ... + (ln 2)^i/i!
     * until the largest representable fraction below 1 is exceeded.
     *
     * Note that
     * 1 = 2 - 1 = exp(ln 2) - 1 = sum_{n=1}^infty (ln 2)^n / n!
     * thus q_i -&gt; 1 as i -&gt; infty,
     * so the higher 1, the closer to one we get (the series is not alternating).
     *
     * By trying, n = 16 in Java is enough to reach 1.0.
     */
<span class="fc" id="L122">    private static double[] EXPONENTIAL_SA_QI = null;</span>

    /** underlying random number generator */
<span class="fc" id="L125">    private RandomGenerator rand = null;</span>

    /** underlying secure random number generator */
<span class="fc" id="L128">    private SecureRandom secRand = null;</span>

    /**
     * Initialize tables
     */
    static {
        /**
         * Filling EXPONENTIAL_SA_QI table.
         * Note that we don't want qi = 0 in the table.
         */
<span class="fc" id="L138">        final double LN2 = FastMath.log(2);</span>
<span class="fc" id="L139">        double qi = 0;</span>
<span class="fc" id="L140">        int i = 1;</span>

        /**
         * MathUtils provides factorials up to 20, so let's use that limit together
         * with Precision.EPSILON to generate the following code (a priori, we know that
         * there will be 16 elements, but instead of hardcoding that, this is
         * prettier):
         */
<span class="fc" id="L148">        final ResizableDoubleArray ra = new ResizableDoubleArray(20);</span>

<span class="fc bfc" id="L150" title="All 2 branches covered.">        while (qi &lt; 1) {</span>
<span class="fc" id="L151">            qi += FastMath.pow(LN2, i) / ArithmeticUtils.factorial(i);</span>
<span class="fc" id="L152">            ra.addElement(qi);</span>
<span class="fc" id="L153">            ++i;</span>
        }

<span class="fc" id="L156">        EXPONENTIAL_SA_QI = ra.getElements();</span>
<span class="fc" id="L157">    }</span>

    /**
     * Construct a RandomDataImpl.
     */
<span class="fc" id="L162">    public RandomDataImpl() {</span>
<span class="fc" id="L163">    }</span>

    /**
     * Construct a RandomDataImpl using the supplied {@link RandomGenerator} as
     * the source of (non-secure) random data.
     *
     * @param rand the source of (non-secure) random data
     * (may be null, resulting in default JDK-supplied generator)
     * @since 1.1
     */
    public RandomDataImpl(RandomGenerator rand) {
<span class="fc" id="L174">        super();</span>
<span class="fc" id="L175">        this.rand = rand;</span>
<span class="fc" id="L176">    }</span>

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated using a
     * 2-step process.
     * &lt;ol&gt;
     * &lt;li&gt;
     * len/2+1 binary bytes are generated using the underlying Random&lt;/li&gt;
     * &lt;li&gt;
     * Each binary byte is translated into 2 hex digits&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     *
     * @param len
     *            the desired string length.
     * @return the random string.
     * @throws NotStrictlyPositiveException if {@code len &lt;= 0}.
     */
    public String nextHexString(int len) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        if (len &lt;= 0) {</span>
<span class="fc" id="L198">            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);</span>
        }

        // Get a random number generator
<span class="fc" id="L202">        RandomGenerator ran = getRan();</span>

        // Initialize output buffer
<span class="fc" id="L205">        StringBuilder outBuffer = new StringBuilder();</span>

        // Get int(len/2)+1 random bytes
<span class="fc" id="L208">        byte[] randomBytes = new byte[(len / 2) + 1];</span>
<span class="fc" id="L209">        ran.nextBytes(randomBytes);</span>

        // Convert each byte to 2 hex digits
<span class="fc bfc" id="L212" title="All 2 branches covered.">        for (int i = 0; i &lt; randomBytes.length; i++) {</span>
<span class="fc" id="L213">            Integer c = Integer.valueOf(randomBytes[i]);</span>

            /*
             * Add 128 to byte value to make interval 0-255 before doing hex
             * conversion. This guarantees &lt;= 2 hex digits from toHexString()
             * toHexString would otherwise add 2^32 to negative arguments.
             */
<span class="fc" id="L220">            String hex = Integer.toHexString(c.intValue() + 128);</span>

            // Make sure we add 2 hex digits for each byte
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (hex.length() == 1) {</span>
<span class="fc" id="L224">                hex = &quot;0&quot; + hex;</span>
            }
<span class="fc" id="L226">            outBuffer.append(hex);</span>
        }
<span class="fc" id="L228">        return outBuffer.toString().substring(0, len);</span>
    }

    /**
     * Generate a random int value uniformly distributed between
     * &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt;, inclusive.
     *
     * @param lower
     *            the lower bound.
     * @param upper
     *            the upper bound.
     * @return the random integer.
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}.
     */
    public int nextInt(int lower, int upper) {
<span class="fc bfc" id="L243" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L244">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L245">                                                lower, upper, false);</span>
        }
<span class="fc" id="L247">        double r = getRan().nextDouble();</span>
<span class="fc" id="L248">        return (int) ((r * upper) + ((1.0 - r) * lower) + r);</span>
    }

    /**
     * Generate a random long value uniformly distributed between
     * &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt;, inclusive.
     *
     * @param lower
     *            the lower bound.
     * @param upper
     *            the upper bound.
     * @return the random integer.
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}.
     */
    public long nextLong(long lower, long upper) {
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L264">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L265">                                                lower, upper, false);</span>
        }
<span class="fc" id="L267">        double r = getRan().nextDouble();</span>
<span class="fc" id="L268">        return (long) ((r * upper) + ((1.0 - r) * lower) + r);</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description:&lt;/strong&gt; hex strings are generated in
     * 40-byte segments using a 3-step process.
     * &lt;ol&gt;
     * &lt;li&gt;
     * 20 random bytes are generated using the underlying
     * &lt;code&gt;SecureRandom&lt;/code&gt;.&lt;/li&gt;
     * &lt;li&gt;
     * SHA-1 hash is applied to yield a 20-byte binary digest.&lt;/li&gt;
     * &lt;li&gt;
     * Each byte of the binary digest is converted to 2 hex digits.&lt;/li&gt;
     * &lt;/ol&gt;
     * &lt;/p&gt;
     *
     * @param len
     *            the length of the generated string
     * @return the random string
     * @throws NotStrictlyPositiveException if {@code len &lt;= 0}.
     */
    public String nextSecureHexString(int len) {
<span class="fc bfc" id="L293" title="All 2 branches covered.">        if (len &lt;= 0) {</span>
<span class="fc" id="L294">            throw new NotStrictlyPositiveException(LocalizedFormats.LENGTH, len);</span>
        }

        // Get SecureRandom and setup Digest provider
<span class="fc" id="L298">        SecureRandom secRan = getSecRan();</span>
<span class="fc" id="L299">        MessageDigest alg = null;</span>
        try {
<span class="fc" id="L301">            alg = MessageDigest.getInstance(&quot;SHA-1&quot;);</span>
<span class="nc" id="L302">        } catch (NoSuchAlgorithmException ex) {</span>
            // this should never happen
<span class="nc" id="L304">            throw new MathInternalError(ex);</span>
<span class="fc" id="L305">        }</span>
<span class="fc" id="L306">        alg.reset();</span>

        // Compute number of iterations required (40 bytes each)
<span class="fc" id="L309">        int numIter = (len / 40) + 1;</span>

<span class="fc" id="L311">        StringBuilder outBuffer = new StringBuilder();</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        for (int iter = 1; iter &lt; numIter + 1; iter++) {</span>
<span class="fc" id="L313">            byte[] randomBytes = new byte[40];</span>
<span class="fc" id="L314">            secRan.nextBytes(randomBytes);</span>
<span class="fc" id="L315">            alg.update(randomBytes);</span>

            // Compute hash -- will create 20-byte binary hash
<span class="fc" id="L318">            byte hash[] = alg.digest();</span>

            // Loop over the hash, converting each byte to 2 hex digits
<span class="fc bfc" id="L321" title="All 2 branches covered.">            for (int i = 0; i &lt; hash.length; i++) {</span>
<span class="fc" id="L322">                Integer c = Integer.valueOf(hash[i]);</span>

                /*
                 * Add 128 to byte value to make interval 0-255 This guarantees
                 * &lt;= 2 hex digits from toHexString() toHexString would
                 * otherwise add 2^32 to negative arguments
                 */
<span class="fc" id="L329">                String hex = Integer.toHexString(c.intValue() + 128);</span>

                // Keep strings uniform length -- guarantees 40 bytes
<span class="fc bfc" id="L332" title="All 2 branches covered.">                if (hex.length() == 1) {</span>
<span class="fc" id="L333">                    hex = &quot;0&quot; + hex;</span>
                }
<span class="fc" id="L335">                outBuffer.append(hex);</span>
            }
        }
<span class="fc" id="L338">        return outBuffer.toString().substring(0, len);</span>
    }

    /**
     * Generate a random int value uniformly distributed between
     * &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt;, inclusive. This algorithm uses
     * a secure random number generator.
     *
     * @param lower
     *            the lower bound.
     * @param upper
     *            the upper bound.
     * @return the random integer.
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}.
     */
    public int nextSecureInt(int lower, int upper) {
<span class="fc bfc" id="L354" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L355">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L356">                                                lower, upper, false);</span>
        }
<span class="fc" id="L358">        SecureRandom sec = getSecRan();</span>
<span class="fc" id="L359">        return lower + (int) (sec.nextDouble() * (upper - lower + 1));</span>
    }

    /**
     * Generate a random long value uniformly distributed between
     * &lt;code&gt;lower&lt;/code&gt; and &lt;code&gt;upper&lt;/code&gt;, inclusive. This algorithm uses
     * a secure random number generator.
     *
     * @param lower
     *            the lower bound.
     * @param upper
     *            the upper bound.
     * @return the random integer.
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}.
     */
    public long nextSecureLong(long lower, long upper) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L376">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L377">                                                lower, upper, false);</span>
        }
<span class="fc" id="L379">        SecureRandom sec = getSecRan();</span>
<span class="fc" id="L380">        return lower + (long) (sec.nextDouble() * (upper - lower + 1));</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;:
     * &lt;ul&gt;&lt;li&gt; For small means, uses simulation of a Poisson process
     * using Uniform deviates, as described
     * &lt;a href=&quot;http://irmi.epfl.ch/cmos/Pmmi/interactive/rng7.htm&quot;&gt; here.&lt;/a&gt;
     * The Poisson process (and hence value returned) is bounded by 1000 * mean.&lt;/li&gt;
     *
     * &lt;li&gt; For large means, uses the rejection algorithm described in &lt;br/&gt;
     * Devroye, Luc. (1981).&lt;i&gt;The Computer Generation of Poisson Random Variables&lt;/i&gt;
     * &lt;strong&gt;Computing&lt;/strong&gt; vol. 26 pp. 197-207.&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;
     *
     * @param mean mean of the Poisson distribution.
     * @return the random Poisson value.
     * @throws NotStrictlyPositiveException if {@code mean &lt;= 0}.
     */
    public long nextPoisson(double mean) {
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (mean &lt;= 0) {</span>
<span class="fc" id="L402">            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);</span>
        }

<span class="fc" id="L405">        final double pivot = 40.0d;</span>
<span class="fc bfc" id="L406" title="All 2 branches covered.">        if (mean &lt; pivot) {</span>
<span class="fc" id="L407">            final RandomGenerator generator = getRan();</span>
<span class="fc" id="L408">            double p = FastMath.exp(-mean);</span>
<span class="fc" id="L409">            long n = 0;</span>
<span class="fc" id="L410">            double r = 1.0d;</span>
<span class="fc" id="L411">            double rnd = 1.0d;</span>

<span class="pc bpc" id="L413" title="1 of 2 branches missed.">            while (n &lt; 1000 * mean) {</span>
<span class="fc" id="L414">                rnd = generator.nextDouble();</span>
<span class="fc" id="L415">                r = r * rnd;</span>
<span class="fc bfc" id="L416" title="All 2 branches covered.">                if (r &gt;= p) {</span>
<span class="fc" id="L417">                    n++;</span>
                } else {
<span class="fc" id="L419">                    return n;</span>
                }
            }
<span class="nc" id="L422">            return n;</span>
        } else {
<span class="fc" id="L424">            final double lambda = FastMath.floor(mean);</span>
<span class="fc" id="L425">            final double lambdaFractional = mean - lambda;</span>
<span class="fc" id="L426">            final double logLambda = FastMath.log(lambda);</span>
<span class="fc" id="L427">            final double logLambdaFactorial = ArithmeticUtils.factorialLog((int) lambda);</span>
<span class="fc bfc" id="L428" title="All 2 branches covered.">            final long y2 = lambdaFractional &lt; Double.MIN_VALUE ? 0 : nextPoisson(lambdaFractional);</span>
<span class="fc" id="L429">            final double delta = FastMath.sqrt(lambda * FastMath.log(32 * lambda / FastMath.PI + 1));</span>
<span class="fc" id="L430">            final double halfDelta = delta / 2;</span>
<span class="fc" id="L431">            final double twolpd = 2 * lambda + delta;</span>
<span class="fc" id="L432">            final double a1 = FastMath.sqrt(FastMath.PI * twolpd) * FastMath.exp(1 / 8 * lambda);</span>
<span class="fc" id="L433">            final double a2 = (twolpd / delta) * FastMath.exp(-delta * (1 + delta) / twolpd);</span>
<span class="fc" id="L434">            final double aSum = a1 + a2 + 1;</span>
<span class="fc" id="L435">            final double p1 = a1 / aSum;</span>
<span class="fc" id="L436">            final double p2 = a2 / aSum;</span>
<span class="fc" id="L437">            final double c1 = 1 / (8 * lambda);</span>

<span class="fc" id="L439">            double x = 0;</span>
<span class="fc" id="L440">            double y = 0;</span>
<span class="fc" id="L441">            double v = 0;</span>
<span class="fc" id="L442">            int a = 0;</span>
<span class="fc" id="L443">            double t = 0;</span>
<span class="fc" id="L444">            double qr = 0;</span>
<span class="fc" id="L445">            double qa = 0;</span>
            for (;;) {
<span class="fc" id="L447">                final double u = nextUniform(0.0, 1);</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                if (u &lt;= p1) {</span>
<span class="fc" id="L449">                    final double n = nextGaussian(0d, 1d);</span>
<span class="fc" id="L450">                    x = n * FastMath.sqrt(lambda + halfDelta) - 0.5d;</span>
<span class="pc bpc" id="L451" title="1 of 4 branches missed.">                    if (x &gt; delta || x &lt; -lambda) {</span>
<span class="nc" id="L452">                        continue;</span>
                    }
<span class="fc bfc" id="L454" title="All 2 branches covered.">                    y = x &lt; 0 ? FastMath.floor(x) : FastMath.ceil(x);</span>
<span class="fc" id="L455">                    final double e = nextExponential(1d);</span>
<span class="fc" id="L456">                    v = -e - (n * n / 2) + c1;</span>
<span class="fc" id="L457">                } else {</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                    if (u &gt; p1 + p2) {</span>
<span class="fc" id="L459">                        y = lambda;</span>
<span class="fc" id="L460">                        break;</span>
                    } else {
<span class="fc" id="L462">                        x = delta + (twolpd / delta) * nextExponential(1d);</span>
<span class="fc" id="L463">                        y = FastMath.ceil(x);</span>
<span class="fc" id="L464">                        v = -nextExponential(1d) - delta * (x + 1) / twolpd;</span>
                    }
                }
<span class="fc bfc" id="L467" title="All 2 branches covered.">                a = x &lt; 0 ? 1 : 0;</span>
<span class="fc" id="L468">                t = y * (y + 1) / (2 * lambda);</span>
<span class="fc bfc" id="L469" title="All 4 branches covered.">                if (v &lt; -t &amp;&amp; a == 0) {</span>
<span class="fc" id="L470">                    y = lambda + y;</span>
<span class="fc" id="L471">                    break;</span>
                }
<span class="fc" id="L473">                qr = t * ((2 * y + 1) / (6 * lambda) - 1);</span>
<span class="fc" id="L474">                qa = qr - (t * t) / (3 * (lambda + a * (y + 1)));</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">                if (v &lt; qa) {</span>
<span class="fc" id="L476">                    y = lambda + y;</span>
<span class="fc" id="L477">                    break;</span>
                }
<span class="fc bfc" id="L479" title="All 2 branches covered.">                if (v &gt; qr) {</span>
<span class="fc" id="L480">                    continue;</span>
                }
<span class="fc bfc" id="L482" title="All 2 branches covered.">                if (v &lt; y * logLambda - ArithmeticUtils.factorialLog((int) (y + lambda)) + logLambdaFactorial) {</span>
<span class="fc" id="L483">                    y = lambda + y;</span>
<span class="fc" id="L484">                    break;</span>
                }
<span class="fc" id="L486">            }</span>
<span class="fc" id="L487">            return y2 + (long) y;</span>
        }
    }

    /**
     * Generate a random value from a Normal (a.k.a. Gaussian) distribution with
     * the given mean, &lt;code&gt;mu&lt;/code&gt; and the given standard deviation,
     * &lt;code&gt;sigma&lt;/code&gt;.
     *
     * @param mu
     *            the mean of the distribution
     * @param sigma
     *            the standard deviation of the distribution
     * @return the random Normal value
     * @throws NotStrictlyPositiveException if {@code sigma &lt;= 0}.
     */
    public double nextGaussian(double mu, double sigma) {
<span class="fc bfc" id="L504" title="All 2 branches covered.">        if (sigma &lt;= 0) {</span>
<span class="fc" id="L505">            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sigma);</span>
        }
<span class="fc" id="L507">        return sigma * getRan().nextGaussian() + mu;</span>
    }

    /**
     * Returns a random value from an Exponential distribution with the given
     * mean.
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses the Algorithm SA (Ahrens)
     * from p. 876 in:
     * [1]: Ahrens, J. H. and Dieter, U. (1972). Computer methods for
     * sampling from the exponential and normal distributions.
     * Communications of the ACM, 15, 873-882.
     * &lt;/p&gt;
     *
     * @param mean the mean of the distribution
     * @return the random Exponential value
     * @throws NotStrictlyPositiveException if {@code mean &lt;= 0}.
     */
    public double nextExponential(double mean) {
<span class="fc bfc" id="L526" title="All 2 branches covered.">        if (mean &lt;= 0.0) {</span>
<span class="fc" id="L527">            throw new NotStrictlyPositiveException(LocalizedFormats.MEAN, mean);</span>
        }

        // Step 1:
<span class="fc" id="L531">        double a = 0;</span>
<span class="fc" id="L532">        double u = this.nextUniform(0, 1);</span>

        // Step 2 and 3:
<span class="fc bfc" id="L535" title="All 2 branches covered.">        while (u &lt; 0.5) {</span>
<span class="fc" id="L536">            a += EXPONENTIAL_SA_QI[0];</span>
<span class="fc" id="L537">            u *= 2;</span>
        }

        // Step 4 (now u &gt;= 0.5):
<span class="fc" id="L541">        u += u - 1;</span>

        // Step 5:
<span class="fc bfc" id="L544" title="All 2 branches covered.">        if (u &lt;= EXPONENTIAL_SA_QI[0]) {</span>
<span class="fc" id="L545">            return mean * (a + u);</span>
        }

        // Step 6:
<span class="fc" id="L549">        int i = 0; // Should be 1, be we iterate before it in while using 0</span>
<span class="fc" id="L550">        double u2 = this.nextUniform(0, 1);</span>
<span class="fc" id="L551">        double umin = u2;</span>

        // Step 7 and 8:
        do {
<span class="fc" id="L555">            ++i;</span>
<span class="fc" id="L556">            u2 = this.nextUniform(0, 1);</span>

<span class="fc bfc" id="L558" title="All 2 branches covered.">            if (u2 &lt; umin) {</span>
<span class="fc" id="L559">                umin = u2;</span>
            }

            // Step 8:
<span class="fc bfc" id="L563" title="All 2 branches covered.">        } while (u &gt; EXPONENTIAL_SA_QI[i]); // Ensured to exit since EXPONENTIAL_SA_QI[MAX] = 1</span>

<span class="fc" id="L565">        return mean * (a + umin * EXPONENTIAL_SA_QI[0]);</span>
    }

    /**
     * {@inheritDoc}
     * &lt;p&gt;
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: scales the output of
     * Random.nextDouble(), but rejects 0 values (i.e., will generate another
     * random double if Random.nextDouble() returns 0). This is necessary to
     * provide a symmetric output interval (both endpoints excluded).
     * &lt;/p&gt;
     *
     * @param lower
     *            the lower bound.
     * @param upper
     *            the upper bound.
     * @return a uniformly distributed random value from the interval (lower,
     *         upper)
     * @throws NumberIsTooLargeException if {@code lower &gt;= upper}.
     */
    public double nextUniform(double lower, double upper) {
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (lower &gt;= upper) {</span>
<span class="fc" id="L587">            throw new NumberIsTooLargeException(LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,</span>
<span class="fc" id="L588">                                                lower, upper, false);</span>
        }
<span class="fc" id="L590">        final RandomGenerator generator = getRan();</span>

        // ensure nextDouble() isn't 0.0
<span class="fc" id="L593">        double u = generator.nextDouble();</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">        while (u &lt;= 0.0) {</span>
<span class="nc" id="L595">            u = generator.nextDouble();</span>
        }

<span class="fc" id="L598">        return lower + u * (upper - lower);</span>
    }

    /**
     * Generates a random value from the {@link BetaDistribution Beta Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param alpha first distribution shape parameter
     * @param beta second distribution shape parameter
     * @return random value sampled from the beta(alpha, beta) distribution
     * @since 2.2
     */
    public double nextBeta(double alpha, double beta) {
<span class="fc" id="L612">        return nextInversionDeviate(new BetaDistribution(alpha, beta));</span>
    }

    /**
     * Generates a random value from the {@link BinomialDistribution Binomial Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param numberOfTrials number of trials of the Binomial distribution
     * @param probabilityOfSuccess probability of success of the Binomial distribution
     * @return random value sampled from the Binomial(numberOfTrials, probabilityOfSuccess) distribution
     * @since 2.2
     */
    public int nextBinomial(int numberOfTrials, double probabilityOfSuccess) {
<span class="fc" id="L626">        return nextInversionDeviate(new BinomialDistribution(numberOfTrials, probabilityOfSuccess));</span>
    }

    /**
     * Generates a random value from the {@link CauchyDistribution Cauchy Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param median the median of the Cauchy distribution
     * @param scale the scale parameter of the Cauchy distribution
     * @return random value sampled from the Cauchy(median, scale) distribution
     * @since 2.2
     */
    public double nextCauchy(double median, double scale) {
<span class="fc" id="L640">        return nextInversionDeviate(new CauchyDistribution(median, scale));</span>
    }

    /**
     * Generates a random value from the {@link ChiSquaredDistribution ChiSquare Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param df the degrees of freedom of the ChiSquare distribution
     * @return random value sampled from the ChiSquare(df) distribution
     * @since 2.2
     */
    public double nextChiSquare(double df) {
<span class="fc" id="L653">        return nextInversionDeviate(new ChiSquaredDistribution(df));</span>
    }

    /**
     * Generates a random value from the {@link FDistribution F Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param numeratorDf the numerator degrees of freedom of the F distribution
     * @param denominatorDf the denominator degrees of freedom of the F distribution
     * @return random value sampled from the F(numeratorDf, denominatorDf) distribution
     * @since 2.2
     */
    public double nextF(double numeratorDf, double denominatorDf) {
<span class="fc" id="L667">        return nextInversionDeviate(new FDistribution(numeratorDf, denominatorDf));</span>
    }

    /**
     * &lt;p&gt;Generates a random value from the
     * {@link org.apache.commons.math.distribution.GammaDistribution Gamma Distribution}.&lt;/p&gt;
     *
     * &lt;p&gt;This implementation uses the following algorithms: &lt;/p&gt;
     *
     * &lt;p&gt;For 0 &lt; shape &lt; 1: &lt;br/&gt;
     * Ahrens, J. H. and Dieter, U., &lt;i&gt;Computer methods for
     * sampling from gamma, beta, Poisson and binomial distributions.&lt;/i&gt;
     * Computing, 12, 223-246, 1974.&lt;/p&gt;
     *
     * &lt;p&gt;For shape &gt;= 1: &lt;br/&gt;
     * Marsaglia and Tsang, &lt;i&gt;A Simple Method for Generating
     * Gamma Variables.&lt;/i&gt; ACM Transactions on Mathematical Software,
     * Volume 26 Issue 3, September, 2000.&lt;/p&gt;
     *
     * @param shape the median of the Gamma distribution
     * @param scale the scale parameter of the Gamma distribution
     * @return random value sampled from the Gamma(shape, scale) distribution
     * @since 2.2
     */
    public double nextGamma(double shape, double scale) {
<span class="fc bfc" id="L692" title="All 2 branches covered.">        if (shape &lt; 1) {</span>
            // [1]: p. 228, Algorithm GS

            while (true) {
                // Step 1:
<span class="fc" id="L697">                final double u = this.nextUniform(0, 1);</span>
<span class="fc" id="L698">                final double bGS = 1 + shape/FastMath.E;</span>
<span class="fc" id="L699">                final double p = bGS*u;</span>

<span class="fc bfc" id="L701" title="All 2 branches covered.">                if (p &lt;= 1) {</span>
                    // Step 2:

<span class="fc" id="L704">                    final double x = FastMath.pow(p, 1/shape);</span>
<span class="fc" id="L705">                    final double u2 = this.nextUniform(0.0, 1);</span>

<span class="fc bfc" id="L707" title="All 2 branches covered.">                    if (u2 &gt; FastMath.exp(-x)) {</span>
                        // Reject
<span class="fc" id="L709">                        continue;</span>
                    } else {
<span class="fc" id="L711">                        return scale*x;</span>
                    }
                } else {
                    // Step 3:

<span class="fc" id="L716">                    final double x = -1 * FastMath.log((bGS-p)/shape);</span>
<span class="fc" id="L717">                    final double u2 = this.nextUniform(0, 1);</span>

<span class="fc bfc" id="L719" title="All 2 branches covered.">                    if (u2 &gt; FastMath.pow(x, shape - 1)) {</span>
                        // Reject
<span class="fc" id="L721">                        continue;</span>
                    } else {
<span class="fc" id="L723">                        return scale*x;</span>
                    }
                }
            }
        }

        // Now shape &gt;= 1

<span class="fc" id="L731">        final RandomGenerator generator = this.getRan();</span>
<span class="fc" id="L732">        final double d = shape - 0.333333333333333333;</span>
<span class="fc" id="L733">        final double c = 1.0 / (3*FastMath.sqrt(d));</span>

        while (true) {
<span class="fc" id="L736">            final double x = generator.nextGaussian();</span>
<span class="fc" id="L737">            final double v = (1+c*x)*(1+c*x)*(1+c*x);</span>

<span class="pc bpc" id="L739" title="1 of 2 branches missed.">            if (v &lt;= 0) {</span>
<span class="nc" id="L740">                continue;</span>
            }

<span class="fc" id="L743">            final double xx = x*x;</span>
<span class="fc" id="L744">            final double u = this.nextUniform(0, 1);</span>

            // Squeeze
<span class="fc bfc" id="L747" title="All 2 branches covered.">            if (u &lt; 1 - 0.0331*xx*xx) {</span>
<span class="fc" id="L748">                return scale*d*v;</span>
            }

<span class="fc bfc" id="L751" title="All 2 branches covered.">            if (FastMath.log(u) &lt; 0.5*xx + d*(1 - v + FastMath.log(v))) {</span>
<span class="fc" id="L752">                return scale*d*v;</span>
            }
<span class="fc" id="L754">        }</span>
    }

    /**
     * Generates a random value from the {@link HypergeometricDistribution Hypergeometric Distribution}.
     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}
     * to generate random values.
     *
     * @param populationSize the population size of the Hypergeometric distribution
     * @param numberOfSuccesses number of successes in the population of the Hypergeometric distribution
     * @param sampleSize the sample size of the Hypergeometric distribution
     * @return random value sampled from the Hypergeometric(numberOfSuccesses, sampleSize) distribution
     * @since 2.2
     */
    public int nextHypergeometric(int populationSize, int numberOfSuccesses, int sampleSize) {
<span class="fc" id="L769">        return nextInversionDeviate(new HypergeometricDistribution(populationSize, numberOfSuccesses, sampleSize));</span>
    }

    /**
     * Generates a random value from the {@link PascalDistribution Pascal Distribution}.
     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}
     * to generate random values.
     *
     * @param r the number of successes of the Pascal distribution
     * @param p the probability of success of the Pascal distribution
     * @return random value sampled from the Pascal(r, p) distribution
     * @since 2.2
     */
    public int nextPascal(int r, double p) {
<span class="fc" id="L783">        return nextInversionDeviate(new PascalDistribution(r, p));</span>
    }

    /**
     * Generates a random value from the {@link TDistribution T Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param df the degrees of freedom of the T distribution
     * @return random value from the T(df) distribution
     * @since 2.2
     */
    public double nextT(double df) {
<span class="fc" id="L796">        return nextInversionDeviate(new TDistribution(df));</span>
    }

    /**
     * Generates a random value from the {@link WeibullDistribution Weibull Distribution}.
     * This implementation uses {@link #nextInversionDeviate(ContinuousDistribution) inversion}
     * to generate random values.
     *
     * @param shape the shape parameter of the Weibull distribution
     * @param scale the scale parameter of the Weibull distribution
     * @return random value sampled from the Weibull(shape, size) distribution
     * @since 2.2
     */
    public double nextWeibull(double shape, double scale) {
<span class="fc" id="L810">        return nextInversionDeviate(new WeibullDistribution(shape, scale));</span>
    }

    /**
     * Generates a random value from the {@link ZipfDistribution Zipf Distribution}.
     * This implementation uses {@link #nextInversionDeviate(IntegerDistribution) inversion}
     * to generate random values.
     *
     * @param numberOfElements the number of elements of the ZipfDistribution
     * @param exponent the exponent of the ZipfDistribution
     * @return random value sampled from the Zipf(numberOfElements, exponent) distribution
     * @since 2.2
     */
    public int nextZipf(int numberOfElements, double exponent) {
<span class="fc" id="L824">        return nextInversionDeviate(new ZipfDistribution(numberOfElements, exponent));</span>
    }

    /**
     * Returns the RandomGenerator used to generate non-secure random data.
     * &lt;p&gt;
     * Creates and initializes a default generator if null. Uses a {@link Well19937c}
     * generator with {@code System.currentTimeMillis() + System.identityHashCode(this))} as the default seed.
     * &lt;/p&gt;
     *
     * @return the Random used to generate random data
     * @since 1.1
     */
    private RandomGenerator getRan() {
<span class="fc bfc" id="L838" title="All 2 branches covered.">        if (rand == null) {</span>
<span class="fc" id="L839">            rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));</span>
        }
<span class="fc" id="L841">        return rand;</span>
    }

    /**
     * Returns the SecureRandom used to generate secure random data.
     * &lt;p&gt;
     * Creates and initializes if null.  Uses
     * {@code System.currentTimeMillis() + System.identityHashCode(this)} as the default seed.
     * &lt;/p&gt;
     *
     * @return the SecureRandom used to generate secure random data
     */
    private SecureRandom getSecRan() {
<span class="fc bfc" id="L854" title="All 2 branches covered.">        if (secRand == null) {</span>
<span class="fc" id="L855">            secRand = new SecureRandom();</span>
<span class="fc" id="L856">            secRand.setSeed(System.currentTimeMillis() + System.identityHashCode(this));</span>
        }
<span class="fc" id="L858">        return secRand;</span>
    }

    /**
     * Reseeds the random number generator with the supplied seed.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     *
     * @param seed
     *            the seed value to use
     */
    public void reSeed(long seed) {
<span class="fc bfc" id="L871" title="All 2 branches covered.">        if (rand == null) {</span>
<span class="fc" id="L872">            rand = new JDKRandomGenerator();</span>
        }
<span class="fc" id="L874">        rand.setSeed(seed);</span>
<span class="fc" id="L875">    }</span>

    /**
     * Reseeds the secure random number generator with the current time in
     * milliseconds.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     */
    public void reSeedSecure() {
<span class="fc bfc" id="L885" title="All 2 branches covered.">        if (secRand == null) {</span>
<span class="fc" id="L886">            secRand = new SecureRandom();</span>
        }
<span class="fc" id="L888">        secRand.setSeed(System.currentTimeMillis());</span>
<span class="fc" id="L889">    }</span>

    /**
     * Reseeds the secure random number generator with the supplied seed.
     * &lt;p&gt;
     * Will create and initialize if null.
     * &lt;/p&gt;
     *
     * @param seed
     *            the seed value to use
     */
    public void reSeedSecure(long seed) {
<span class="fc bfc" id="L901" title="All 2 branches covered.">        if (secRand == null) {</span>
<span class="fc" id="L902">            secRand = new SecureRandom();</span>
        }
<span class="fc" id="L904">        secRand.setSeed(seed);</span>
<span class="fc" id="L905">    }</span>

    /**
     * Reseeds the random number generator with the current time in
     * milliseconds.
     */
    public void reSeed() {
<span class="fc bfc" id="L912" title="All 2 branches covered.">        if (rand == null) {</span>
<span class="fc" id="L913">            rand = new JDKRandomGenerator();</span>
        }
<span class="fc" id="L915">        rand.setSeed(System.currentTimeMillis());</span>
<span class="fc" id="L916">    }</span>

    /**
     * Sets the PRNG algorithm for the underlying SecureRandom instance using
     * the Security Provider API. The Security Provider API is defined in &lt;a
     * href =
     * &quot;http://java.sun.com/j2se/1.3/docs/guide/security/CryptoSpec.html#AppA&quot;&gt;
     * Java Cryptography Architecture API Specification &amp; Reference.&lt;/a&gt;
     * &lt;p&gt;
     * &lt;strong&gt;USAGE NOTE:&lt;/strong&gt; This method carries &lt;i&gt;significant&lt;/i&gt;
     * overhead and may take several seconds to execute.
     * &lt;/p&gt;
     *
     * @param algorithm
     *            the name of the PRNG algorithm
     * @param provider
     *            the name of the provider
     * @throws NoSuchAlgorithmException
     *             if the specified algorithm is not available
     * @throws NoSuchProviderException
     *             if the specified provider is not installed
     */
    public void setSecureAlgorithm(String algorithm, String provider)
            throws NoSuchAlgorithmException, NoSuchProviderException {
<span class="nc" id="L940">        secRand = SecureRandom.getInstance(algorithm, provider);</span>
<span class="nc" id="L941">    }</span>

    /**
     * Generates an integer array of length &lt;code&gt;k&lt;/code&gt; whose entries are
     * selected randomly, without repetition, from the integers
     * &lt;code&gt;0 through n-1&lt;/code&gt; (inclusive).
     * &lt;p&gt;
     * Generated arrays represent permutations of &lt;code&gt;n&lt;/code&gt; taken
     * &lt;code&gt;k&lt;/code&gt; at a time.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Preconditions:&lt;/strong&gt;
     * &lt;ul&gt;
     * &lt;li&gt; &lt;code&gt;k &lt;= n&lt;/code&gt;&lt;/li&gt;
     * &lt;li&gt; &lt;code&gt;n &gt; 0&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * If the preconditions are not met, an IllegalArgumentException is thrown.
     * &lt;/p&gt;
     * &lt;p&gt;
     * Uses a 2-cycle permutation shuffle. The shuffling process is described &lt;a
     * href=&quot;http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html&quot;&gt;
     * here&lt;/a&gt;.
     * &lt;/p&gt;
     *
     * @param n
     *            domain of the permutation (must be positive)
     * @param k
     *            size of the permutation (must satisfy 0 &lt; k &lt;= n).
     * @return the random permutation as an int array
     * @throws NumberIsTooLargeException if {@code k &gt; n}.
     * @throws NotStrictlyPositiveException if {@code k &lt;= 0}.
     */
    public int[] nextPermutation(int n, int k) {
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">        if (k &gt; n) {</span>
<span class="nc" id="L975">            throw new NumberIsTooLargeException(LocalizedFormats.PERMUTATION_EXCEEDS_N,</span>
<span class="nc" id="L976">                                                k, n, true);</span>
        }
<span class="pc bpc" id="L978" title="1 of 2 branches missed.">        if (k == 0) {</span>
<span class="nc" id="L979">            throw new NotStrictlyPositiveException(LocalizedFormats.PERMUTATION_SIZE,</span>
<span class="nc" id="L980">                                                   k);</span>
        }

<span class="fc" id="L983">        int[] index = getNatural(n);</span>
<span class="fc" id="L984">        shuffle(index, n - k);</span>
<span class="fc" id="L985">        int[] result = new int[k];</span>
<span class="fc bfc" id="L986" title="All 2 branches covered.">        for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L987">            result[i] = index[n - i - 1];</span>
        }

<span class="fc" id="L990">        return result;</span>
    }

    /**
     * Uses a 2-cycle permutation shuffle to generate a random permutation.
     * &lt;strong&gt;Algorithm Description&lt;/strong&gt;: Uses a 2-cycle permutation
     * shuffle to generate a random permutation of &lt;code&gt;c.size()&lt;/code&gt; and
     * then returns the elements whose indexes correspond to the elements of the
     * generated permutation. This technique is described, and proven to
     * generate random samples, &lt;a
     * href=&quot;http://www.maths.abdn.ac.uk/~igc/tch/mx4002/notes/node83.html&quot;&gt;
     * here&lt;/a&gt;
     *
     * @param c
     *            Collection to sample from.
     * @param k
     *            sample size.
     * @return the random sample.
     * @throws NumberIsTooLargeException if {@code k &gt; c.size()}.
     * @throws NotStrictlyPositiveException if {@code k &lt;= 0}.
     */
    public Object[] nextSample(Collection&lt;?&gt; c, int k) {
<span class="fc" id="L1012">        int len = c.size();</span>
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        if (k &gt; len) {</span>
<span class="fc" id="L1014">            throw new NumberIsTooLargeException(LocalizedFormats.SAMPLE_SIZE_EXCEEDS_COLLECTION_SIZE,</span>
<span class="fc" id="L1015">                                                k, len, true);</span>
        }
<span class="fc bfc" id="L1017" title="All 2 branches covered.">        if (k &lt;= 0) {</span>
<span class="fc" id="L1018">            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, k);</span>
        }

<span class="fc" id="L1021">        Object[] objects = c.toArray();</span>
<span class="fc" id="L1022">        int[] index = nextPermutation(len, k);</span>
<span class="fc" id="L1023">        Object[] result = new Object[k];</span>
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        for (int i = 0; i &lt; k; i++) {</span>
<span class="fc" id="L1025">            result[i] = objects[index[i]];</span>
        }
<span class="fc" id="L1027">        return result;</span>
    }

    /**
     * Generate a random deviate from the given distribution using the
     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Inverse_transform_sampling&quot;&gt; inversion method.&lt;/a&gt;
     *
     * @param distribution Continuous distribution to generate a random value from
     * @return a random value sampled from the given distribution
     * @since 2.2
     */
    public double nextInversionDeviate(ContinuousDistribution distribution) {
<span class="fc" id="L1039">        return distribution.inverseCumulativeProbability(nextUniform(0, 1));</span>

    }

    /**
     * Generate a random deviate from the given distribution using the
     * &lt;a href=&quot;http://en.wikipedia.org/wiki/Inverse_transform_sampling&quot;&gt; inversion method.&lt;/a&gt;
     *
     * @param distribution Integer distribution to generate a random value from
     * @return a random value sampled from the given distribution
     * @since 2.2
     */
    public int nextInversionDeviate(IntegerDistribution distribution) {
<span class="fc" id="L1052">        final double target = nextUniform(0, 1);</span>
<span class="fc" id="L1053">        final int glb = distribution.inverseCumulativeProbability(target);</span>
<span class="pc bpc" id="L1054" title="1 of 2 branches missed.">        if (distribution.cumulativeProbability(glb) == 1.0d) { // No mass above</span>
<span class="nc" id="L1055">            return glb;</span>
        } else {
<span class="fc" id="L1057">            return glb + 1;</span>
        }
    }

    // ------------------------Private methods----------------------------------

    /**
     * Uses a 2-cycle permutation shuffle to randomly re-order the last elements
     * of list.
     *
     * @param list
     *            list to be shuffled
     * @param end
     *            element past which shuffling begins
     */
    private void shuffle(int[] list, int end) {
<span class="fc" id="L1073">        int target = 0;</span>
<span class="fc bfc" id="L1074" title="All 2 branches covered.">        for (int i = list.length - 1; i &gt;= end; i--) {</span>
<span class="fc bfc" id="L1075" title="All 2 branches covered.">            if (i == 0) {</span>
<span class="fc" id="L1076">                target = 0;</span>
            } else {
<span class="fc" id="L1078">                target = nextInt(0, i);</span>
            }
<span class="fc" id="L1080">            int temp = list[target];</span>
<span class="fc" id="L1081">            list[target] = list[i];</span>
<span class="fc" id="L1082">            list[i] = temp;</span>
        }
<span class="fc" id="L1084">    }</span>

    /**
     * Returns an array representing n.
     *
     * @param n
     *            the natural number to represent
     * @return array with entries = elements of n
     */
    private int[] getNatural(int n) {
<span class="fc" id="L1094">        int[] natural = new int[n];</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1096">            natural[i] = i;</span>
        }
<span class="fc" id="L1098">        return natural;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>