<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BOBYQAOptimizer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Math</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.math.optimization.direct</a> &gt; <span class="el_source">BOBYQAOptimizer.java</span></div><h1>BOBYQAOptimizer.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.math.optimization.direct;

import java.util.Arrays;

import org.apache.commons.math.analysis.MultivariateFunction;
import org.apache.commons.math.exception.MathIllegalStateException;
import org.apache.commons.math.exception.NumberIsTooSmallException;
import org.apache.commons.math.exception.OutOfRangeException;
import org.apache.commons.math.exception.util.LocalizedFormats;
import org.apache.commons.math.linear.Array2DRowRealMatrix;
import org.apache.commons.math.linear.ArrayRealVector;
import org.apache.commons.math.linear.RealVector;
import org.apache.commons.math.optimization.GoalType;
import org.apache.commons.math.optimization.RealPointValuePair;
import org.apache.commons.math.optimization.MultivariateRealOptimizer;

/**
 * Powell's BOBYQA algorithm. This implementation is translated and
 * adapted from the Fortran version available
 * &lt;a href=&quot;http://plato.asu.edu/ftp/other_software/bobyqa.zip&quot;&gt;here&lt;/a&gt;.
 * See &lt;a href=&quot;http://www.optimization-online.org/DB_HTML/2010/05/2616.html&quot;&gt;
 * this paper&lt;/a&gt; for an introduction.
 * &lt;br/&gt;
 * BOBYQA is particularly well suited for high dimensional problems
 * where derivatives are not available. In most cases it outperforms the
 * {@link PowellOptimizer} significantly. Stochastic algorithms like
 * {@link CMAESOptimizer} succeed more often than BOBYQA, but are more
 * expensive. BOBYQA could also be considered as a replacement of any
 * derivative-based optimizer when the derivatives are approximated by
 * finite differences.
 *
 * @version $Id$
 * @since 3.0
 */
public class BOBYQAOptimizer
    extends BaseAbstractSimpleBoundsScalarOptimizer&lt;MultivariateFunction&gt;
    implements MultivariateRealOptimizer {
    /** Minimum dimension of the problem: {@value} */
    public static final int MINIMUM_PROBLEM_DIMENSION = 2;
    /** Default value for {@link #initialTrustRegionRadius}: {@value} . */
    public static final double DEFAULT_INITIAL_RADIUS = 10.0;
    /** Default value for {@link #stoppingTrustRegionRadius}: {@value} . */
    public static final double DEFAULT_STOPPING_RADIUS = 1E-8;

    private static final double ZERO = 0d;
    private static final double ONE = 1d;
    private static final double TWO = 2d;
    private static final double TEN = 10d;
    private static final double SIXTEEN = 16d;
    private static final double TWO_HUNDRED_FIFTY = 250d;
    private static final double MINUS_ONE = -ONE;
    private static final double HALF = ONE / 2;
    private static final double ONE_OVER_FOUR = ONE / 4;
    private static final double ONE_OVER_EIGHT = ONE / 8;
    private static final double ONE_OVER_TEN = ONE / 10;
    private static final double ONE_OVER_A_THOUSAND = ONE / 1000;

    /**
     * numberOfInterpolationPoints XXX
     */
    private final int numberOfInterpolationPoints;
    /**
     * initialTrustRegionRadius XXX
     */
    private double initialTrustRegionRadius;
    /**
     * stoppingTrustRegionRadius XXX
     */
    private final double stoppingTrustRegionRadius;
    /** Goal type (minimize or maximize). */
    private boolean isMinimize;
    /**
     * Current best values for the variables to be optimized.
     * The vector will be changed in-place to contain the values of the least
     * calculated objective function values.
     */
    private ArrayRealVector currentBest;
    /** Differences between the upper and lower bounds. */
    private double[] boundDifference;
    /**
     * Index of the interpolation point at the trust region center.
     */
    private int trustRegionCenterInterpolationPointIndex;
    /**
     * Last &lt;em&gt;n&lt;/em&gt; columns of matrix H (where &lt;em&gt;n&lt;/em&gt; is the dimension
     * of the problem).
     * XXX &quot;bmat&quot; in the original code.
     */
    private Array2DRowRealMatrix bMatrix;
    /**
     * Factorization of the leading &lt;em&gt;npt&lt;/em&gt; square submatrix of H, this
     * factorization being Z Z&lt;sup&gt;T&lt;/sup&gt;, which provides both the correct
     * rank and positive semi-definiteness.
     * XXX &quot;zmat&quot; in the original code.
     */
    private Array2DRowRealMatrix zMatrix;
    /**
     * Coordinates of the interpolation points relative to {@link #originShift}.
     * XXX &quot;xpt&quot; in the original code.
     */
    private Array2DRowRealMatrix interpolationPoints;
    /**
     * Shift of origin that should reduce the contributions from rounding
     * errors to values of the model and Lagrange functions.
     * XXX &quot;xbase&quot; in the original code.
     */
    private ArrayRealVector originShift;
    /**
     * Values of the objective function at the interpolation points.
     * XXX &quot;fval&quot; in the original code.
     */
    private ArrayRealVector fAtInterpolationPoints;
    /**
     * Displacement from {@link #originShift} of the trust region center.
     * XXX &quot;xopt&quot; in the original code.
     */
    private ArrayRealVector trustRegionCenterOffset;
    /**
     * Gradient of the quadratic model at {@link #originShift} +
     * {@link #trustRegionCenterOffset}.
     * XXX &quot;gopt&quot; in the original code.
     */
    private ArrayRealVector gradientAtTrustRegionCenter;
    /**
     * Differences {@link #getLowerBound()} - {@link #originShift}.
     * All the components of every {@link #trustRegionCenterOffset} are going
     * to satisfy the bounds&lt;br/&gt;
     * {@link #getLowerBound() lowerBound}&lt;sub&gt;i&lt;/sub&gt; &amp;le;
     * {@link #trustRegionCenterOffset}&lt;sub&gt;i&lt;/sub&gt;,&lt;br/&gt;
     * with appropriate equalities when {@link #trustRegionCenterOffset} is
     * on a constraint boundary.
     * XXX &quot;sl&quot; in the original code.
     */
    private ArrayRealVector lowerDifference;
    /**
     * Differences {@link #getUpperBound()} - {@link #originShift}
     * All the components of every {@link #trustRegionCenterOffset} are going
     * to satisfy the bounds&lt;br/&gt;
     *  {@link #trustRegionCenterOffset}&lt;sub&gt;i&lt;/sub&gt; &amp;le;
     *  {@link #getUpperBound() upperBound}&lt;sub&gt;i&lt;/sub&gt;,&lt;br/&gt;
     * with appropriate equalities when {@link #trustRegionCenterOffset} is
     * on a constraint boundary.
     * XXX &quot;su&quot; in the original code.
     */
    private ArrayRealVector upperDifference;
    /** 
     * Parameters of the implicit second derivatives of the quadratic model.
     * XXX &quot;pq&quot; in the original code.
     */
    private ArrayRealVector modelSecondDerivativesParameters;
    /**
     * Point chosen by function {@link #trsbox(double,ArrayRealVector,
     * ArrayRealVector, ArrayRealVector,ArrayRealVector,ArrayRealVector) trsbox}
     * or {@link #altmov(int,double) altmov}.
     * Usually {@link #originShift} + {@link #newPoint} is the vector of
     * variables for the next evaluation of the objective function.
     * It also satisfies the constraints indicated in {@link #lowerDifference}
     * and {@link #upperDifference}.
     * XXX &quot;xnew&quot; in the original code.
     */
    private ArrayRealVector newPoint;
    /**
     * Alternative to {@link #newPoint}, chosen by
     * {@link #altmov(int,double) altmov}.
     * It may replace {@link #newPoint} in order to increase the denominator
     * in the {@link #update() updating procedure}.
     * XXX &quot;xalt&quot; in the original code.
     */
    private ArrayRealVector alternativeNewPoint;
    /**
     * Trial step from {@link #trustRegionCenterOffset} which is usually
     * {@link #newPoint} - {@link #trustRegionCenterOffset}.
     * XXX &quot;d__&quot; in the original code.
     */
    private ArrayRealVector trialStepPoint;
    /**
     * Values of the Lagrange functions at a new point.
     * XXX &quot;vlag&quot; in the original code.
     */
    private ArrayRealVector lagrangeValuesAtNewPoint;
    /**
     * Explicit second derivatives of the quadratic model.
     * XXX &quot;hq&quot; in the original code.
     */
    private ArrayRealVector modelSecondDerivativesValues;

    /**
     * @param numberOfInterpolationPoints Number of interpolation conditions.
     * For a problem of dimension {@code n}, its value must be in the interval
     * {@code [n+2, (n+1)(n+2)/2]}.
     * Choices that exceed {@code 2n+1} are not recommended.
     */
    public BOBYQAOptimizer(int numberOfInterpolationPoints) {
<span class="fc" id="L211">        this(numberOfInterpolationPoints,</span>
             DEFAULT_INITIAL_RADIUS,
             DEFAULT_STOPPING_RADIUS);
<span class="fc" id="L214">    }</span>

    /**
     * @param numberOfInterpolationPoints Number of interpolation conditions.
     * For a problem of dimension {@code n}, its value must be in the interval
     * {@code [n+2, (n+1)(n+2)/2]}.
     * Choices that exceed {@code 2n+1} are not recommended.
     * @param initialTrustRegionRadius Initial trust region radius.
     * @param stoppingTrustRegionRadius Stopping trust region radius.
     */
    public BOBYQAOptimizer(int numberOfInterpolationPoints,
                           double initialTrustRegionRadius,
<span class="fc" id="L226">                           double stoppingTrustRegionRadius) {</span>
<span class="fc" id="L227">        this.numberOfInterpolationPoints = numberOfInterpolationPoints;</span>
<span class="fc" id="L228">        this.initialTrustRegionRadius = initialTrustRegionRadius;</span>
<span class="fc" id="L229">        this.stoppingTrustRegionRadius = stoppingTrustRegionRadius;</span>
<span class="fc" id="L230">    }</span>

    /** {@inheritDoc} */
    @Override
    protected RealPointValuePair doOptimize() {
<span class="fc" id="L235">        final double[] lowerBound = getLowerBound();</span>
<span class="fc" id="L236">        final double[] upperBound = getUpperBound();</span>

        // Validity checks.
<span class="fc" id="L239">        setup(lowerBound, upperBound);</span>

<span class="fc bfc" id="L241" title="All 2 branches covered.">        isMinimize = (getGoalType() == GoalType.MINIMIZE);</span>
<span class="fc" id="L242">        currentBest = new ArrayRealVector(getStartPoint());</span>

<span class="fc" id="L244">        final double value = bobyqa(lowerBound, upperBound);</span>

<span class="fc" id="L246">        return new RealPointValuePair(currentBest.getDataRef(),</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">                                      isMinimize ? value : -value);</span>
    }

    /**
     *     This subroutine seeks the least value of a function of many variables,
     *     by applying a trust region method that forms quadratic models by
     *     interpolation. There is usually some freedom in the interpolation
     *     conditions, which is taken up by minimizing the Frobenius norm of
     *     the change to the second derivative of the model, beginning with the
     *     zero matrix. The values of the variables are constrained by upper and
     *     lower bounds. The arguments of the subroutine are as follows.
     *
     *     N must be set to the number of variables and must be at least two.
     *     NPT is the number of interpolation conditions. Its value must be in
     *       the interval [N+2,(N+1)(N+2)/2]. Choices that exceed 2*N+1 are not
     *       recommended.
     *     Initial values of the variables must be set in X(1),X(2),...,X(N). They
     *       will be changed to the values that give the least calculated F.
     *     For I=1,2,...,N, XL(I) and XU(I) must provide the lower and upper
     *       bounds, respectively, on X(I). The construction of quadratic models
     *       requires XL(I) to be strictly less than XU(I) for each I. Further,
     *       the contribution to a model from changes to the I-th variable is
     *       damaged severely by rounding errors if XU(I)-XL(I) is too small.
     *     RHOBEG and RHOEND must be set to the initial and final values of a trust
     *       region radius, so both must be positive with RHOEND no greater than
     *       RHOBEG. Typically, RHOBEG should be about one tenth of the greatest
     *       expected change to a variable, while RHOEND should indicate the
     *       accuracy that is required in the final values of the variables. An
     *       error return occurs if any of the differences XU(I)-XL(I), I=1,...,N,
     *       is less than 2*RHOBEG.
     *     MAXFUN must be set to an upper bound on the number of calls of CALFUN.
     *     The array W will be used for working space. Its length must be at least
     *       (NPT+5)*(NPT+N)+3*N*(N+5)/2.
     *
     * @param lowerBound Lower bounds.
     * @param upperBound Upper bounds.
     * @return the value of the objective at the optimum.
     */
    private double bobyqa(double[] lowerBound,
                          double[] upperBound) {
<span class="fc" id="L287">        printMethod(); // XXX</span>

<span class="fc" id="L289">        final int n = currentBest.getDimension();</span>

        // Return if there is insufficient space between the bounds. Modify the
        // initial X if necessary in order to avoid conflicts between the bounds
        // and the construction of the first quadratic model. The lower and upper
        // bounds on moves from the updated X are set now, in the ISL and ISU
        // partitions of W, in order to provide useful and exact information about
        // components of X that become within distance RHOBEG from their bounds.

<span class="fc bfc" id="L298" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L299">            final double boundDiff = boundDifference[j];</span>
<span class="fc" id="L300">            lowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));</span>
<span class="fc" id="L301">            upperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));</span>
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">            if (lowerDifference.getEntry(j) &gt;= -initialTrustRegionRadius) {</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">                if (lowerDifference.getEntry(j) &gt;= ZERO) {</span>
<span class="nc" id="L304">                    currentBest.setEntry(j, lowerBound[j]);</span>
<span class="nc" id="L305">                    lowerDifference.setEntry(j, ZERO);</span>
<span class="nc" id="L306">                    upperDifference.setEntry(j, boundDiff);</span>
                } else {
<span class="nc" id="L308">                    currentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);</span>
<span class="nc" id="L309">                    lowerDifference.setEntry(j, -initialTrustRegionRadius);</span>
                    // Computing MAX
<span class="nc" id="L311">                    final double deltaOne = upperBound[j] - currentBest.getEntry(j);</span>
<span class="nc" id="L312">                    upperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));</span>
<span class="nc" id="L313">                }</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">            } else if (upperDifference.getEntry(j) &lt;= initialTrustRegionRadius) {</span>
<span class="pc bpc" id="L315" title="1 of 2 branches missed.">                if (upperDifference.getEntry(j) &lt;= ZERO) {</span>
<span class="nc" id="L316">                    currentBest.setEntry(j, upperBound[j]);</span>
<span class="nc" id="L317">                    lowerDifference.setEntry(j, -boundDiff);</span>
<span class="nc" id="L318">                    upperDifference.setEntry(j, ZERO);</span>
                } else {
<span class="fc" id="L320">                    currentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);</span>
                    // Computing MIN
<span class="fc" id="L322">                    final double deltaOne = lowerBound[j] - currentBest.getEntry(j);</span>
<span class="fc" id="L323">                    final double deltaTwo = -initialTrustRegionRadius;</span>
<span class="fc" id="L324">                    lowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));</span>
<span class="fc" id="L325">                    upperDifference.setEntry(j, initialTrustRegionRadius);</span>
                }
            }
        }

        // Make the call of BOBYQB.

<span class="fc" id="L332">        return bobyqb(lowerBound, upperBound);</span>
    } // bobyqa

    // ----------------------------------------------------------------------------------------

    /**
     *     The arguments N, NPT, X, XL, XU, RHOBEG, RHOEND, IPRINT and MAXFUN
     *       are identical to the corresponding arguments in SUBROUTINE BOBYQA.
     *     XBASE holds a shift of origin that should reduce the contributions
     *       from rounding errors to values of the model and Lagrange functions.
     *     XPT is a two-dimensional array that holds the coordinates of the
     *       interpolation points relative to XBASE.
     *     FVAL holds the values of F at the interpolation points.
     *     XOPT is set to the displacement from XBASE of the trust region centre.
     *     GOPT holds the gradient of the quadratic model at XBASE+XOPT.
     *     HQ holds the explicit second derivatives of the quadratic model.
     *     PQ contains the parameters of the implicit second derivatives of the
     *       quadratic model.
     *     BMAT holds the last N columns of H.
     *     ZMAT holds the factorization of the leading NPT by NPT submatrix of H,
     *       this factorization being ZMAT times ZMAT^T, which provides both the
     *       correct rank and positive semi-definiteness.
     *     NDIM is the first dimension of BMAT and has the value NPT+N.
     *     SL and SU hold the differences XL-XBASE and XU-XBASE, respectively.
     *       All the components of every XOPT are going to satisfy the bounds
     *       SL(I) .LEQ. XOPT(I) .LEQ. SU(I), with appropriate equalities when
     *       XOPT is on a constraint boundary.
     *     XNEW is chosen by SUBROUTINE TRSBOX or ALTMOV. Usually XBASE+XNEW is the
     *       vector of variables for the next call of CALFUN. XNEW also satisfies
     *       the SL and SU constraints in the way that has just been mentioned.
     *     XALT is an alternative to XNEW, chosen by ALTMOV, that may replace XNEW
     *       in order to increase the denominator in the updating of UPDATE.
     *     D is reserved for a trial step from XOPT, which is usually XNEW-XOPT.
     *     VLAG contains the values of the Lagrange functions at a new point X.
     *       They are part of a product that requires VLAG to be of length NDIM.
     *     W is a one-dimensional array that is used for working space. Its length
     *       must be at least 3*NDIM = 3*(NPT+N).
     *
     * @param lowerBound Lower bounds.
     * @param upperBound Upper bounds.
     * @return the value of the objective at the optimum.
     */
    private double bobyqb(double[] lowerBound,
                          double[] upperBound) {
<span class="fc" id="L376">        printMethod(); // XXX</span>

<span class="fc" id="L378">        final int n = currentBest.getDimension();</span>
<span class="fc" id="L379">        final int npt = numberOfInterpolationPoints;</span>
<span class="fc" id="L380">        final int np = n + 1;</span>
<span class="fc" id="L381">        final int nptm = npt - np;</span>
<span class="fc" id="L382">        final int nh = n * np / 2;</span>

<span class="fc" id="L384">        final ArrayRealVector work1 = new ArrayRealVector(n);</span>
<span class="fc" id="L385">        final ArrayRealVector work2 = new ArrayRealVector(npt);</span>
<span class="fc" id="L386">        final ArrayRealVector work3 = new ArrayRealVector(npt);</span>

<span class="fc" id="L388">        double cauchy = Double.NaN;</span>
<span class="fc" id="L389">        double alpha = Double.NaN;</span>
<span class="fc" id="L390">        double dsq = Double.NaN;</span>
<span class="fc" id="L391">        double crvmin = Double.NaN;</span>

        // Set some constants.
        // Parameter adjustments

        // Function Body

        // The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
        // BMAT and ZMAT for the first iteration, with the corresponding values of
        // of NF and KOPT, which are the number of calls of CALFUN so far and the
        // index of the interpolation point at the trust region centre. Then the
        // initial XOPT is set too. The branch to label 720 occurs if MAXFUN is
        // less than NPT. GOPT will be updated if KOPT is different from KBASE.

<span class="fc" id="L405">        trustRegionCenterInterpolationPointIndex = 0;</span>

<span class="fc" id="L407">        prelim(lowerBound, upperBound);</span>
<span class="fc" id="L408">        double xoptsq = ZERO;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L410">            trustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));</span>
            // Computing 2nd power
<span class="fc" id="L412">            final double deltaOne = trustRegionCenterOffset.getEntry(i);</span>
<span class="fc" id="L413">            xoptsq += deltaOne * deltaOne;</span>
        }
<span class="fc" id="L415">        double fsave = fAtInterpolationPoints.getEntry(0);</span>
<span class="fc" id="L416">        final int kbase = 0;</span>

        // Complete the settings that are required for the iterative procedure.

<span class="fc" id="L420">        int ntrits = 0;</span>
<span class="fc" id="L421">        int itest = 0;</span>
<span class="fc" id="L422">        int knew = 0;</span>
<span class="fc" id="L423">        int nfsav = getEvaluations();</span>
<span class="fc" id="L424">        double rho = initialTrustRegionRadius;</span>
<span class="fc" id="L425">        double delta = rho;</span>
<span class="fc" id="L426">        double diffa = ZERO;</span>
<span class="fc" id="L427">        double diffb = ZERO;</span>
<span class="fc" id="L428">        double diffc = ZERO;</span>
<span class="fc" id="L429">        double f = ZERO;</span>
<span class="fc" id="L430">        double beta = ZERO;</span>
<span class="fc" id="L431">        double adelt = ZERO;</span>
<span class="fc" id="L432">        double denom = ZERO;</span>
<span class="fc" id="L433">        double ratio = ZERO;</span>
<span class="fc" id="L434">        double dnorm = ZERO;</span>
<span class="fc" id="L435">        double scaden = ZERO;</span>
<span class="fc" id="L436">        double biglsq = ZERO;</span>
<span class="fc" id="L437">        double distsq = ZERO;</span>

        // Update GOPT if necessary before the first iteration and after each
        // call of RESCUE that makes a call of CALFUN.

<span class="fc" id="L442">        int state = 20;</span>
<span class="pc bpc" id="L443" title="1 of 10 branches missed.">        for(;;) switch (state) {</span>
        case 20: {
<span class="fc" id="L445">            printState(20); // XXX</span>
<span class="fc bfc" id="L446" title="All 2 branches covered.">            if (trustRegionCenterInterpolationPointIndex != kbase) {</span>
<span class="fc" id="L447">                int ih = 0;</span>
<span class="fc bfc" id="L448" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc bfc" id="L449" title="All 2 branches covered.">                    for (int i = 0; i &lt;= j; i++) {</span>
<span class="fc bfc" id="L450" title="All 2 branches covered.">                        if (i &lt; j) {</span>
<span class="fc" id="L451">                            gradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));</span>
                        }
<span class="fc" id="L453">                        gradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));</span>
<span class="fc" id="L454">                        ih++;</span>
                    }
                }
<span class="pc bpc" id="L457" title="1 of 2 branches missed.">                if (getEvaluations() &gt; npt) {</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="nc" id="L459">                        double temp = ZERO;</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">                        for (int j = 0; j &lt; n; j++) {</span>
<span class="nc" id="L461">                            temp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);</span>
                        }
<span class="nc" id="L463">                        temp *= modelSecondDerivativesParameters.getEntry(k);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">                        for (int i = 0; i &lt; n; i++) {</span>
<span class="nc" id="L465">                            gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));</span>
                        }
                    }
<span class="nc" id="L468">                    throw new PathIsExploredException(); // XXX</span>
                }
            }

            // Generate the next point in the trust region that provides a small value
            // of the quadratic model subject to the constraints on the variables.
            // The int NTRITS is set to the number &quot;trust region&quot; iterations that
            // have occurred since the last &quot;alternative&quot; iteration. If the length
            // of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to
            // label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.

        }
        case 60: {
<span class="fc" id="L481">            printState(60); // XXX</span>
<span class="fc" id="L482">            final ArrayRealVector gnew = new ArrayRealVector(n);</span>
<span class="fc" id="L483">            final ArrayRealVector xbdi = new ArrayRealVector(n);</span>
<span class="fc" id="L484">            final ArrayRealVector s = new ArrayRealVector(n);</span>
<span class="fc" id="L485">            final ArrayRealVector hs = new ArrayRealVector(n);</span>
<span class="fc" id="L486">            final ArrayRealVector hred = new ArrayRealVector(n);</span>

<span class="fc" id="L488">            final double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,</span>
                                              hs, hred);
<span class="fc" id="L490">            dsq = dsqCrvmin[0];</span>
<span class="fc" id="L491">            crvmin = dsqCrvmin[1];</span>

            // Computing MIN
<span class="fc" id="L494">            double deltaOne = delta;</span>
<span class="fc" id="L495">            double deltaTwo = Math.sqrt(dsq);</span>
<span class="fc" id="L496">            dnorm = Math.min(deltaOne, deltaTwo);</span>
<span class="fc bfc" id="L497" title="All 2 branches covered.">            if (dnorm &lt; HALF * rho) {</span>
<span class="fc" id="L498">                ntrits = -1;</span>
                // Computing 2nd power
<span class="fc" id="L500">                deltaOne = TEN * rho;</span>
<span class="fc" id="L501">                distsq = deltaOne * deltaOne;</span>
<span class="fc bfc" id="L502" title="All 2 branches covered.">                if (getEvaluations() &lt;= nfsav + 2) {</span>
<span class="fc" id="L503">                    state = 650; break;</span>
                }

                // The following choice between labels 650 and 680 depends on whether or
                // not our work with the current RHO seems to be complete. Either RHO is
                // decreased or termination occurs if the errors in the quadratic model at
                // the last three interpolation points compare favourably with predictions
                // of likely improvements to the model within distance HALF*RHO of XOPT.

                // Computing MAX
<span class="fc" id="L513">                deltaOne = Math.max(diffa, diffb);</span>
<span class="fc" id="L514">                final double errbig = Math.max(deltaOne, diffc);</span>
<span class="fc" id="L515">                final double frhosq = rho * ONE_OVER_EIGHT * rho;</span>
<span class="fc bfc" id="L516" title="All 4 branches covered.">                if (crvmin &gt; ZERO &amp;&amp;</span>
                    errbig &gt; frhosq * crvmin) {
<span class="fc" id="L518">                    state = 650; break;</span>
                }
<span class="fc" id="L520">                final double bdtol = errbig / rho;</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L522">                    double bdtest = bdtol;</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                    if (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {</span>
<span class="nc" id="L524">                        bdtest = work1.getEntry(j);</span>
                    }
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">                    if (newPoint.getEntry(j) == upperDifference.getEntry(j)) {</span>
<span class="nc" id="L527">                        bdtest = -work1.getEntry(j);</span>
                    }
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">                    if (bdtest &lt; bdtol) {</span>
<span class="nc" id="L530">                        double curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">                        for (int k = 0; k &lt; npt; k++) {</span>
                            // Computing 2nd power
<span class="nc" id="L533">                            final double d1 = interpolationPoints.getEntry(k, j);</span>
<span class="nc" id="L534">                            curv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);</span>
                        }
<span class="nc" id="L536">                        bdtest += HALF * curv * rho;</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">                        if (bdtest &lt; bdtol) {</span>
<span class="nc" id="L538">                            state = 650; break;</span>
                        }
<span class="nc" id="L540">                        throw new PathIsExploredException(); // XXX</span>
                    }
                }
<span class="fc" id="L543">                state = 680; break;</span>
            }
<span class="fc" id="L545">            ++ntrits;</span>

            // Severe cancellation is likely to occur if XOPT is too far from XBASE.
            // If the following test holds, then XBASE is shifted so that XOPT becomes
            // zero. The appropriate changes are made to BMAT and to the second
            // derivatives of the current model, beginning with the changes to BMAT
            // that do not depend on ZMAT. VLAG is used temporarily for working space.

        }
        case 90: {
<span class="fc" id="L555">            printState(90); // XXX</span>
<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (dsq &lt;= xoptsq * ONE_OVER_A_THOUSAND) {</span>
<span class="fc" id="L557">                final double fracsq = xoptsq * ONE_OVER_FOUR;</span>
<span class="fc" id="L558">                double sumpq = ZERO;</span>
                // final RealVector sumVector
                //     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));
<span class="fc bfc" id="L561" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L562">                    sumpq += modelSecondDerivativesParameters.getEntry(k);</span>
<span class="fc" id="L563">                    double sum = -HALF * xoptsq;</span>
<span class="fc bfc" id="L564" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L565">                        sum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);</span>
                    }
                    // sum = sumVector.getEntry(k); // XXX &quot;testAckley&quot; and &quot;testDiffPow&quot; fail.
<span class="fc" id="L568">                    work2.setEntry(k, sum);</span>
<span class="fc" id="L569">                    final double temp = fracsq - HALF * sum;</span>
<span class="fc bfc" id="L570" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L571">                        work1.setEntry(i, bMatrix.getEntry(k, i));</span>
<span class="fc" id="L572">                        lagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L573">                        final int ip = npt + i;</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">                        for (int j = 0; j &lt;= i; j++) {</span>
<span class="fc" id="L575">                            bMatrix.setEntry(ip, j,</span>
<span class="fc" id="L576">                                          bMatrix.getEntry(ip, j)</span>
<span class="fc" id="L577">                                          + work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)</span>
<span class="fc" id="L578">                                          + lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));</span>
                        }
                    }
                }

                // Then the revisions of BMAT that depend on ZMAT are calculated.

<span class="fc bfc" id="L585" title="All 2 branches covered.">                for (int m = 0; m &lt; nptm; m++) {</span>
<span class="fc" id="L586">                    double sumz = ZERO;</span>
<span class="fc" id="L587">                    double sumw = ZERO;</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L589">                        sumz += zMatrix.getEntry(k, m);</span>
<span class="fc" id="L590">                        lagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));</span>
<span class="fc" id="L591">                        sumw += lagrangeValuesAtNewPoint.getEntry(k);</span>
                    }
<span class="fc bfc" id="L593" title="All 2 branches covered.">                    for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L594">                        double sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);</span>
<span class="fc bfc" id="L595" title="All 2 branches covered.">                        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L596">                            sum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);</span>
                        }
<span class="fc" id="L598">                        work1.setEntry(j, sum);</span>
<span class="fc bfc" id="L599" title="All 2 branches covered.">                        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L600">                            bMatrix.setEntry(k, j,</span>
<span class="fc" id="L601">                                          bMatrix.getEntry(k, j)</span>
<span class="fc" id="L602">                                          + sum * zMatrix.getEntry(k, m));</span>
                        }
                    }
<span class="fc bfc" id="L605" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L606">                        final int ip = i + npt;</span>
<span class="fc" id="L607">                        final double temp = work1.getEntry(i);</span>
<span class="fc bfc" id="L608" title="All 2 branches covered.">                        for (int j = 0; j &lt;= i; j++) {</span>
<span class="fc" id="L609">                            bMatrix.setEntry(ip, j,</span>
<span class="fc" id="L610">                                          bMatrix.getEntry(ip, j)</span>
<span class="fc" id="L611">                                          + temp * work1.getEntry(j));</span>
                        }
                    }
                }

                // The following instructions complete the shift, including the changes
                // to the second derivative parameters of the quadratic model.

<span class="fc" id="L619">                int ih = 0;</span>
<span class="fc bfc" id="L620" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L621">                    work1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L623">                        work1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));</span>
<span class="fc" id="L624">                        interpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));</span>
                    }
<span class="fc bfc" id="L626" title="All 2 branches covered.">                    for (int i = 0; i &lt;= j; i++) {</span>
<span class="fc" id="L627">                         modelSecondDerivativesValues.setEntry(ih,</span>
<span class="fc" id="L628">                                    modelSecondDerivativesValues.getEntry(ih)</span>
<span class="fc" id="L629">                                    + work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)</span>
<span class="fc" id="L630">                                    + trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));</span>
<span class="fc" id="L631">                        bMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));</span>
<span class="fc" id="L632">                        ih++;</span>
                    }
                }
<span class="fc bfc" id="L635" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L636">                    originShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L637">                    newPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L638">                    lowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L639">                    upperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L640">                    trustRegionCenterOffset.setEntry(i, ZERO);</span>
                }
<span class="fc" id="L642">                xoptsq = ZERO;</span>
            }
<span class="fc bfc" id="L644" title="All 2 branches covered.">            if (ntrits == 0) {</span>
<span class="fc" id="L645">                state = 210; break;</span>
            }
<span class="fc" id="L647">            state = 230; break;</span>

            // XBASE is also moved to XOPT by a call of RESCUE. This calculation is
            // more expensive than the previous shift, because new matrices BMAT and
            // ZMAT are generated from scratch, which may include the replacement of
            // interpolation points whose positions seem to be causing near linear
            // dependence in the interpolation conditions. Therefore RESCUE is called
            // only if rounding errors have reduced by at least a factor of two the
            // denominator of the formula for updating the H matrix. It provides a
            // useful safeguard, but is not invoked in most applications of BOBYQA.

        }
        case 210: {
<span class="fc" id="L660">            printState(210); // XXX</span>
            // Pick two alternative vectors of variables, relative to XBASE, that
            // are suitable as new positions of the KNEW-th interpolation point.
            // Firstly, XNEW is set to the point on a line through XOPT and another
            // interpolation point that minimizes the predicted value of the next
            // denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL
            // and SU bounds. Secondly, XALT is set to the best feasible point on
            // a constrained version of the Cauchy step of the KNEW-th Lagrange
            // function, the corresponding value of the square of this function
            // being returned in CAUCHY. The choice between these alternatives is
            // going to be made when the denominator is calculated.

<span class="fc" id="L672">            final double[] alphaCauchy = altmov(knew, adelt);</span>
<span class="fc" id="L673">            alpha = alphaCauchy[0];</span>
<span class="fc" id="L674">            cauchy = alphaCauchy[1];</span>

<span class="fc bfc" id="L676" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L677">                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
            }

            // Calculate VLAG and BETA for the current choice of D. The scalar
            // product of D with XPT(K,.) is going to be held in W(NPT+K) for
            // use when VQUAD is calculated.

        }
        case 230: {
<span class="fc" id="L686">            printState(230); // XXX</span>
<span class="fc bfc" id="L687" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L688">                double suma = ZERO;</span>
<span class="fc" id="L689">                double sumb = ZERO;</span>
<span class="fc" id="L690">                double sum = ZERO;</span>
<span class="fc bfc" id="L691" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L692">                    suma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);</span>
<span class="fc" id="L693">                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);</span>
<span class="fc" id="L694">                    sum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);</span>
                }
<span class="fc" id="L696">                work3.setEntry(k, suma * (HALF * suma + sumb));</span>
<span class="fc" id="L697">                lagrangeValuesAtNewPoint.setEntry(k, sum);</span>
<span class="fc" id="L698">                work2.setEntry(k, suma);</span>
            }
<span class="fc" id="L700">            beta = ZERO;</span>
<span class="fc bfc" id="L701" title="All 2 branches covered.">            for (int m = 0; m &lt; nptm; m++) {</span>
<span class="fc" id="L702">                double sum = ZERO;</span>
<span class="fc bfc" id="L703" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L704">                    sum += zMatrix.getEntry(k, m) * work3.getEntry(k);</span>
                }
<span class="fc" id="L706">                beta -= sum * sum;</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L708">                    lagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));</span>
                }
            }
<span class="fc" id="L711">            dsq = ZERO;</span>
<span class="fc" id="L712">            double bsum = ZERO;</span>
<span class="fc" id="L713">            double dx = ZERO;</span>
<span class="fc bfc" id="L714" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
                // Computing 2nd power
<span class="fc" id="L716">                final double d1 = trialStepPoint.getEntry(j);</span>
<span class="fc" id="L717">                dsq += d1 * d1;</span>
<span class="fc" id="L718">                double sum = ZERO;</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L720">                    sum += work3.getEntry(k) * bMatrix.getEntry(k, j);</span>
                }
<span class="fc" id="L722">                bsum += sum * trialStepPoint.getEntry(j);</span>
<span class="fc" id="L723">                final int jp = npt + j;</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L725">                    sum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);</span>
                }
<span class="fc" id="L727">                lagrangeValuesAtNewPoint.setEntry(jp, sum);</span>
<span class="fc" id="L728">                bsum += sum * trialStepPoint.getEntry(j);</span>
<span class="fc" id="L729">                dx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);</span>
            }

<span class="fc" id="L732">            beta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original</span>
            // beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX &quot;testAckley&quot; and &quot;testDiffPow&quot; fail.
            // beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX &quot;testDiffPow&quot; fails.

<span class="fc" id="L736">            lagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,</span>
<span class="fc" id="L737">                          lagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);</span>

            // If NTRITS is zero, the denominator may be increased by replacing
            // the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if
            // rounding errors have damaged the chosen denominator.

<span class="fc bfc" id="L743" title="All 2 branches covered.">            if (ntrits == 0) {</span>
                // Computing 2nd power
<span class="fc" id="L745">                final double d1 = lagrangeValuesAtNewPoint.getEntry(knew);</span>
<span class="fc" id="L746">                denom = d1 * d1 + alpha * beta;</span>
<span class="pc bpc" id="L747" title="1 of 4 branches missed.">                if (denom &lt; cauchy &amp;&amp; cauchy &gt; ZERO) {</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L749">                        newPoint.setEntry(i, alternativeNewPoint.getEntry(i));</span>
<span class="fc" id="L750">                        trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
                    }
<span class="fc" id="L752">                    cauchy = ZERO; // XXX Useful statement?</span>
<span class="fc" id="L753">                    state = 230; break;</span>
                }
                // Alternatively, if NTRITS is positive, then set KNEW to the index of
                // the next interpolation point to be deleted to make room for a trust
                // region step. Again RESCUE may be called if rounding errors have damaged_
                // the chosen denominator, which is the reason for attempting to select
                // KNEW before calculating the next value of the objective function.

<span class="fc" id="L761">            } else {</span>
<span class="fc" id="L762">                final double delsq = delta * delta;</span>
<span class="fc" id="L763">                scaden = ZERO;</span>
<span class="fc" id="L764">                biglsq = ZERO;</span>
<span class="fc" id="L765">                knew = 0;</span>
<span class="fc bfc" id="L766" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">                    if (k == trustRegionCenterInterpolationPointIndex) {</span>
<span class="fc" id="L768">                        continue;</span>
                    }
<span class="fc" id="L770">                    double hdiag = ZERO;</span>
<span class="fc bfc" id="L771" title="All 2 branches covered.">                    for (int m = 0; m &lt; nptm; m++) {</span>
                        // Computing 2nd power
<span class="fc" id="L773">                        final double d1 = zMatrix.getEntry(k, m);</span>
<span class="fc" id="L774">                        hdiag += d1 * d1;</span>
                    }
                    // Computing 2nd power
<span class="fc" id="L777">                    final double d2 = lagrangeValuesAtNewPoint.getEntry(k);</span>
<span class="fc" id="L778">                    final double den = beta * hdiag + d2 * d2;</span>
<span class="fc" id="L779">                    distsq = ZERO;</span>
<span class="fc bfc" id="L780" title="All 2 branches covered.">                    for (int j = 0; j &lt; n; j++) {</span>
                        // Computing 2nd power
<span class="fc" id="L782">                        final double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);</span>
<span class="fc" id="L783">                        distsq += d3 * d3;</span>
                    }
                    // Computing MAX
                    // Computing 2nd power
<span class="fc" id="L787">                    final double d4 = distsq / delsq;</span>
<span class="fc" id="L788">                    final double temp = Math.max(ONE, d4 * d4);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">                    if (temp * den &gt; scaden) {</span>
<span class="fc" id="L790">                        scaden = temp * den;</span>
<span class="fc" id="L791">                        knew = k;</span>
<span class="fc" id="L792">                        denom = den;</span>
                    }
                    // Computing MAX
                    // Computing 2nd power
<span class="fc" id="L796">                    final double d5 = lagrangeValuesAtNewPoint.getEntry(k);</span>
<span class="fc" id="L797">                    biglsq = Math.max(biglsq, temp * (d5 * d5));</span>
                }
            }

            // Put the variables for the next calculation of the objective function
            //   in XNEW, with any adjustments for the bounds.

            // Calculate the value of the objective function at XBASE+XNEW, unless
            //   the limit on the number of calculations of F has been reached.

        }
        case 360: {
<span class="fc" id="L809">            printState(360); // XXX</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
                // Computing MIN
                // Computing MAX
<span class="fc" id="L813">                final double d3 = lowerBound[i];</span>
<span class="fc" id="L814">                final double d4 = originShift.getEntry(i) + newPoint.getEntry(i);</span>
<span class="fc" id="L815">                final double d1 = Math.max(d3, d4);</span>
<span class="fc" id="L816">                final double d2 = upperBound[i];</span>
<span class="fc" id="L817">                currentBest.setEntry(i, Math.min(d1, d2));</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">                if (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {</span>
<span class="nc" id="L819">                    currentBest.setEntry(i, lowerBound[i]);</span>
                }
<span class="pc bpc" id="L821" title="1 of 2 branches missed.">                if (newPoint.getEntry(i) == upperDifference.getEntry(i)) {</span>
<span class="nc" id="L822">                    currentBest.setEntry(i, upperBound[i]);</span>
                }
            }

<span class="fc" id="L826">            f = computeObjectiveValue(currentBest.toArray());</span>

<span class="fc bfc" id="L828" title="All 2 branches covered.">            if (!isMinimize)</span>
<span class="fc" id="L829">                f = -f;</span>
<span class="fc bfc" id="L830" title="All 2 branches covered.">            if (ntrits == -1) {</span>
<span class="fc" id="L831">                fsave = f;</span>
<span class="fc" id="L832">                state = 720; break;</span>
            }

            // Use the quadratic model to predict the change in F due to the step D,
            //   and set DIFF to the error of this prediction.

<span class="fc" id="L838">            final double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);</span>
<span class="fc" id="L839">            double vquad = ZERO;</span>
<span class="fc" id="L840">            int ih = 0;</span>
<span class="fc bfc" id="L841" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L842">                vquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">                for (int i = 0; i &lt;= j; i++) {</span>
<span class="fc" id="L844">                    double temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">                    if (i == j) {</span>
<span class="fc" id="L846">                        temp *= HALF;</span>
                    }
<span class="fc" id="L848">                    vquad += modelSecondDerivativesValues.getEntry(ih) * temp;</span>
<span class="fc" id="L849">                    ih++;</span>
               }
            }
<span class="fc bfc" id="L852" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
                // Computing 2nd power
<span class="fc" id="L854">                final double d1 = work2.getEntry(k);</span>
<span class="fc" id="L855">                final double d2 = d1 * d1; // &quot;d1&quot; must be squared first to prevent test failures.</span>
<span class="fc" id="L856">                vquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;</span>
            }
<span class="fc" id="L858">            final double diff = f - fopt - vquad;</span>
<span class="fc" id="L859">            diffc = diffb;</span>
<span class="fc" id="L860">            diffb = diffa;</span>
<span class="fc" id="L861">            diffa = Math.abs(diff);</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">            if (dnorm &gt; rho) {</span>
<span class="fc" id="L863">                nfsav = getEvaluations();</span>
            }

            // Pick the next value of DELTA after a trust region step.

<span class="fc bfc" id="L868" title="All 2 branches covered.">            if (ntrits &gt; 0) {</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">                if (vquad &gt;= ZERO) {</span>
<span class="nc" id="L870">                    throw new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);</span>
                }
<span class="fc" id="L872">                ratio = (f - fopt) / vquad;</span>
<span class="fc" id="L873">                final double hDelta = HALF * delta;</span>
<span class="fc bfc" id="L874" title="All 2 branches covered.">                if (ratio &lt;= ONE_OVER_TEN) {</span>
                    // Computing MIN
<span class="fc" id="L876">                    delta = Math.min(hDelta, dnorm);</span>
<span class="fc bfc" id="L877" title="All 2 branches covered.">                } else if (ratio &lt;= .7) {</span>
                    // Computing MAX
<span class="fc" id="L879">                    delta = Math.max(hDelta, dnorm);</span>
                } else {
                    // Computing MAX
<span class="fc" id="L882">                    delta = Math.max(hDelta, 2 * dnorm);</span>
                }
<span class="fc bfc" id="L884" title="All 2 branches covered.">                if (delta &lt;= rho * 1.5) {</span>
<span class="fc" id="L885">                    delta = rho;</span>
                }

                // Recalculate KNEW and DENOM if the new F is less than FOPT.

<span class="fc bfc" id="L890" title="All 2 branches covered.">                if (f &lt; fopt) {</span>
<span class="fc" id="L891">                    final int ksav = knew;</span>
<span class="fc" id="L892">                    final double densav = denom;</span>
<span class="fc" id="L893">                    final double delsq = delta * delta;</span>
<span class="fc" id="L894">                    scaden = ZERO;</span>
<span class="fc" id="L895">                    biglsq = ZERO;</span>
<span class="fc" id="L896">                    knew = 0;</span>
<span class="fc bfc" id="L897" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L898">                        double hdiag = ZERO;</span>
<span class="fc bfc" id="L899" title="All 2 branches covered.">                        for (int m = 0; m &lt; nptm; m++) {</span>
                            // Computing 2nd power
<span class="fc" id="L901">                            final double d1 = zMatrix.getEntry(k, m);</span>
<span class="fc" id="L902">                            hdiag += d1 * d1;</span>
                        }
                        // Computing 2nd power
<span class="fc" id="L905">                        final double d1 = lagrangeValuesAtNewPoint.getEntry(k);</span>
<span class="fc" id="L906">                        final double den = beta * hdiag + d1 * d1;</span>
<span class="fc" id="L907">                        distsq = ZERO;</span>
<span class="fc bfc" id="L908" title="All 2 branches covered.">                        for (int j = 0; j &lt; n; j++) {</span>
                            // Computing 2nd power
<span class="fc" id="L910">                            final double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);</span>
<span class="fc" id="L911">                            distsq += d2 * d2;</span>
                        }
                        // Computing MAX
                        // Computing 2nd power
<span class="fc" id="L915">                        final double d3 = distsq / delsq;</span>
<span class="fc" id="L916">                        final double temp = Math.max(ONE, d3 * d3);</span>
<span class="fc bfc" id="L917" title="All 2 branches covered.">                        if (temp * den &gt; scaden) {</span>
<span class="fc" id="L918">                            scaden = temp * den;</span>
<span class="fc" id="L919">                            knew = k;</span>
<span class="fc" id="L920">                            denom = den;</span>
                        }
                        // Computing MAX
                        // Computing 2nd power
<span class="fc" id="L924">                        final double d4 = lagrangeValuesAtNewPoint.getEntry(k);</span>
<span class="fc" id="L925">                        final double d5 = temp * (d4 * d4);</span>
<span class="fc" id="L926">                        biglsq = Math.max(biglsq, d5);</span>
                    }
<span class="pc bpc" id="L928" title="1 of 2 branches missed.">                    if (scaden &lt;= HALF * biglsq) {</span>
<span class="nc" id="L929">                        knew = ksav;</span>
<span class="nc" id="L930">                        denom = densav;</span>
                    }
                }
            }

            // Update BMAT and ZMAT, so that the KNEW-th interpolation point can be
            // moved. Also update the second derivative terms of the model.

<span class="fc" id="L938">            update(beta, denom, knew);</span>

<span class="fc" id="L940">            ih = 0;</span>
<span class="fc" id="L941">            final double pqold = modelSecondDerivativesParameters.getEntry(knew);</span>
<span class="fc" id="L942">            modelSecondDerivativesParameters.setEntry(knew, ZERO);</span>
<span class="fc bfc" id="L943" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L944">                final double temp = pqold * interpolationPoints.getEntry(knew, i);</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">                for (int j = 0; j &lt;= i; j++) {</span>
<span class="fc" id="L946">                    modelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));</span>
<span class="fc" id="L947">                    ih++;</span>
                }
            }
<span class="fc bfc" id="L950" title="All 2 branches covered.">            for (int m = 0; m &lt; nptm; m++) {</span>
<span class="fc" id="L951">                final double temp = diff * zMatrix.getEntry(knew, m);</span>
<span class="fc bfc" id="L952" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L953">                    modelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));</span>
                }
            }

            // Include the new interpolation point, and make the changes to GOPT at
            // the old XOPT that are caused by the updating of the quadratic model.

<span class="fc" id="L960">            fAtInterpolationPoints.setEntry(knew,  f);</span>
<span class="fc bfc" id="L961" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L962">                interpolationPoints.setEntry(knew, i, newPoint.getEntry(i));</span>
<span class="fc" id="L963">                work1.setEntry(i, bMatrix.getEntry(knew, i));</span>
            }
<span class="fc bfc" id="L965" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L966">                double suma = ZERO;</span>
<span class="fc bfc" id="L967" title="All 2 branches covered.">                for (int m = 0; m &lt; nptm; m++) {</span>
<span class="fc" id="L968">                    suma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);</span>
                }
<span class="fc" id="L970">                double sumb = ZERO;</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L972">                    sumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);</span>
                }
<span class="fc" id="L974">                final double temp = suma * sumb;</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L976">                    work1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));</span>
                }
            }
<span class="fc bfc" id="L979" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L980">                gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));</span>
            }

            // Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.

<span class="fc bfc" id="L985" title="All 2 branches covered.">            if (f &lt; fopt) {</span>
<span class="fc" id="L986">                trustRegionCenterInterpolationPointIndex = knew;</span>
<span class="fc" id="L987">                xoptsq = ZERO;</span>
<span class="fc" id="L988">                ih = 0;</span>
<span class="fc bfc" id="L989" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L990">                    trustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));</span>
                    // Computing 2nd power
<span class="fc" id="L992">                    final double d1 = trustRegionCenterOffset.getEntry(j);</span>
<span class="fc" id="L993">                    xoptsq += d1 * d1;</span>
<span class="fc bfc" id="L994" title="All 2 branches covered.">                    for (int i = 0; i &lt;= j; i++) {</span>
<span class="fc bfc" id="L995" title="All 2 branches covered.">                        if (i &lt; j) {</span>
<span class="fc" id="L996">                            gradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));</span>
                        }
<span class="fc" id="L998">                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));</span>
<span class="fc" id="L999">                        ih++;</span>
                    }
                }
<span class="fc bfc" id="L1002" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1003">                    double temp = ZERO;</span>
<span class="fc bfc" id="L1004" title="All 2 branches covered.">                    for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1005">                        temp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);</span>
                    }
<span class="fc" id="L1007">                    temp *= modelSecondDerivativesParameters.getEntry(k);</span>
<span class="fc bfc" id="L1008" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1009">                        gradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));</span>
                    }
                }
            }

            // Calculate the parameters of the least Frobenius norm interpolant to
            // the current data, the gradient of this interpolant at XOPT being put
            // into VLAG(NPT+I), I=1,2,...,N.

<span class="fc bfc" id="L1018" title="All 2 branches covered.">            if (ntrits &gt; 0) {</span>
<span class="fc bfc" id="L1019" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1020">                    lagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));</span>
<span class="fc" id="L1021">                    work3.setEntry(k, ZERO);</span>
                }
<span class="fc bfc" id="L1023" title="All 2 branches covered.">                for (int j = 0; j &lt; nptm; j++) {</span>
<span class="fc" id="L1024">                    double sum = ZERO;</span>
<span class="fc bfc" id="L1025" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1026">                        sum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);</span>
                    }
<span class="fc bfc" id="L1028" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1029">                        work3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));</span>
                    }
                }
<span class="fc bfc" id="L1032" title="All 2 branches covered.">                for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1033">                    double sum = ZERO;</span>
<span class="fc bfc" id="L1034" title="All 2 branches covered.">                    for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1035">                        sum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);</span>
                    }
<span class="fc" id="L1037">                    work2.setEntry(k, work3.getEntry(k));</span>
<span class="fc" id="L1038">                    work3.setEntry(k, sum * work3.getEntry(k));</span>
                }
<span class="fc" id="L1040">                double gqsq = ZERO;</span>
<span class="fc" id="L1041">                double gisq = ZERO;</span>
<span class="fc bfc" id="L1042" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1043">                    double sum = ZERO;</span>
<span class="fc bfc" id="L1044" title="All 2 branches covered.">                    for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1045">                        sum += bMatrix.getEntry(k, i) *</span>
<span class="fc" id="L1046">                            lagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);</span>
                    }
<span class="pc bpc" id="L1048" title="1 of 2 branches missed.">                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {</span>
                        // Computing MIN
                        // Computing 2nd power
<span class="nc" id="L1051">                        final double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));</span>
<span class="nc" id="L1052">                        gqsq += d1 * d1;</span>
                        // Computing 2nd power
<span class="nc" id="L1054">                        final double d2 = Math.min(ZERO, sum);</span>
<span class="nc" id="L1055">                        gisq += d2 * d2;</span>
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">                    } else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {</span>
                        // Computing MAX
                        // Computing 2nd power
<span class="nc" id="L1059">                        final double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));</span>
<span class="nc" id="L1060">                        gqsq += d1 * d1;</span>
                        // Computing 2nd power
<span class="nc" id="L1062">                        final double d2 = Math.max(ZERO, sum);</span>
<span class="nc" id="L1063">                        gisq += d2 * d2;</span>
<span class="nc" id="L1064">                    } else {</span>
                        // Computing 2nd power
<span class="fc" id="L1066">                        final double d1 = gradientAtTrustRegionCenter.getEntry(i);</span>
<span class="fc" id="L1067">                        gqsq += d1 * d1;</span>
<span class="fc" id="L1068">                        gisq += sum * sum;</span>
                    }
<span class="fc" id="L1070">                    lagrangeValuesAtNewPoint.setEntry(npt + i, sum);</span>
                }

                // Test whether to replace the new quadratic model by the least Frobenius
                // norm interpolant, making the replacement if the test is satisfied.

<span class="fc" id="L1076">                ++itest;</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">                if (gqsq &lt; TEN * gisq) {</span>
<span class="fc" id="L1078">                    itest = 0;</span>
                }
<span class="fc bfc" id="L1080" title="All 2 branches covered.">                if (itest &gt;= 3) {</span>
<span class="fc bfc" id="L1081" title="All 2 branches covered.">                    for (int i = 0, max = Math.max(npt, nh); i &lt; max; i++) {</span>
<span class="fc bfc" id="L1082" title="All 2 branches covered.">                        if (i &lt; n) {</span>
<span class="fc" id="L1083">                            gradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));</span>
                        }
<span class="fc bfc" id="L1085" title="All 2 branches covered.">                        if (i &lt; npt) {</span>
<span class="fc" id="L1086">                            modelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));</span>
                        }
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">                        if (i &lt; nh) {</span>
<span class="fc" id="L1089">                            modelSecondDerivativesValues.setEntry(i, ZERO);</span>
                        }
<span class="fc" id="L1091">                        itest = 0;</span>
                    }
                }
            }

            // If a trust region step has provided a sufficient decrease in F, then
            // branch for another trust region calculation. The case NTRITS=0 occurs
            // when the new interpolation point was reached by an alternative step.

<span class="fc bfc" id="L1100" title="All 2 branches covered.">            if (ntrits == 0) {</span>
<span class="fc" id="L1101">                state = 60; break;</span>
            }
<span class="fc bfc" id="L1103" title="All 2 branches covered.">            if (f &lt;= fopt + ONE_OVER_TEN * vquad) {</span>
<span class="fc" id="L1104">                state = 60; break;</span>
            }

            // Alternatively, find out if the interpolation points are close enough
            //   to the best point so far.

            // Computing MAX
            // Computing 2nd power
<span class="fc" id="L1112">            final double d1 = TWO * delta;</span>
            // Computing 2nd power
<span class="fc" id="L1114">            final double d2 = TEN * rho;</span>
<span class="fc" id="L1115">            distsq = Math.max(d1 * d1, d2 * d2);</span>
        }
        case 650: {
<span class="fc" id="L1118">            printState(650); // XXX</span>
<span class="fc" id="L1119">            knew = -1;</span>
<span class="fc bfc" id="L1120" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1121">                double sum = ZERO;</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
                    // Computing 2nd power
<span class="fc" id="L1124">                    final double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);</span>
<span class="fc" id="L1125">                    sum += d1 * d1;</span>
                }
<span class="fc bfc" id="L1127" title="All 2 branches covered.">                if (sum &gt; distsq) {</span>
<span class="fc" id="L1128">                    knew = k;</span>
<span class="fc" id="L1129">                    distsq = sum;</span>
                }
            }

            // If KNEW is positive, then ALTMOV finds alternative new positions for
            // the KNEW-th interpolation point within distance ADELT of XOPT. It is
            // reached via label 90. Otherwise, there is a branch to label 60 for
            // another trust region iteration, unless the calculations with the
            // current RHO are complete.

<span class="fc bfc" id="L1139" title="All 2 branches covered.">            if (knew &gt;= 0) {</span>
<span class="fc" id="L1140">                final double dist = Math.sqrt(distsq);</span>
<span class="fc bfc" id="L1141" title="All 2 branches covered.">                if (ntrits == -1) {</span>
                    // Computing MIN
<span class="fc" id="L1143">                    delta = Math.min(ONE_OVER_TEN * delta, HALF * dist);</span>
<span class="fc bfc" id="L1144" title="All 2 branches covered.">                    if (delta &lt;= rho * 1.5) {</span>
<span class="fc" id="L1145">                        delta = rho;</span>
                    }
                }
<span class="fc" id="L1148">                ntrits = 0;</span>
                // Computing MAX
                // Computing MIN
<span class="fc" id="L1151">                final double d1 = Math.min(ONE_OVER_TEN * dist, delta);</span>
<span class="fc" id="L1152">                adelt = Math.max(d1, rho);</span>
<span class="fc" id="L1153">                dsq = adelt * adelt;</span>
<span class="fc" id="L1154">                state = 90; break;</span>
            }
<span class="fc bfc" id="L1156" title="All 2 branches covered.">            if (ntrits == -1) {</span>
<span class="fc" id="L1157">                state = 680; break;</span>
            }
<span class="fc bfc" id="L1159" title="All 2 branches covered.">            if (ratio &gt; ZERO) {</span>
<span class="fc" id="L1160">                state = 60; break;</span>
            }
<span class="fc bfc" id="L1162" title="All 2 branches covered.">            if (Math.max(delta, dnorm) &gt; rho) {</span>
<span class="fc" id="L1163">                state = 60; break;</span>
            }

            // The calculations with the current value of RHO are complete. Pick the
            //   next values of RHO and DELTA.
        }
        case 680: {
<span class="fc" id="L1170">            printState(680); // XXX</span>
<span class="fc bfc" id="L1171" title="All 2 branches covered.">            if (rho &gt; stoppingTrustRegionRadius) {</span>
<span class="fc" id="L1172">                delta = HALF * rho;</span>
<span class="fc" id="L1173">                ratio = rho / stoppingTrustRegionRadius;</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">                if (ratio &lt;= SIXTEEN) {</span>
<span class="fc" id="L1175">                    rho = stoppingTrustRegionRadius;</span>
<span class="fc bfc" id="L1176" title="All 2 branches covered.">                } else if (ratio &lt;= TWO_HUNDRED_FIFTY) {</span>
<span class="fc" id="L1177">                    rho = Math.sqrt(ratio) * stoppingTrustRegionRadius;</span>
                } else {
<span class="fc" id="L1179">                    rho *= ONE_OVER_TEN;</span>
                }
<span class="fc" id="L1181">                delta = Math.max(delta, rho);</span>
<span class="fc" id="L1182">                ntrits = 0;</span>
<span class="fc" id="L1183">                nfsav = getEvaluations();</span>
<span class="fc" id="L1184">                state = 60; break;</span>
            }

            // Return from the calculation, after another Newton-Raphson step, if
            //   it is too short to have been tried before.

<span class="fc bfc" id="L1190" title="All 2 branches covered.">            if (ntrits == -1) {</span>
<span class="fc" id="L1191">                state = 360; break;</span>
            }
        }
        case 720: {
<span class="fc" id="L1195">            printState(720); // XXX</span>
<span class="fc bfc" id="L1196" title="All 2 branches covered.">            if (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) &lt;= fsave) {</span>
<span class="fc bfc" id="L1197" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
                    // Computing MIN
                    // Computing MAX
<span class="fc" id="L1200">                    final double d3 = lowerBound[i];</span>
<span class="fc" id="L1201">                    final double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);</span>
<span class="fc" id="L1202">                    final double d1 = Math.max(d3, d4);</span>
<span class="fc" id="L1203">                    final double d2 = upperBound[i];</span>
<span class="fc" id="L1204">                    currentBest.setEntry(i, Math.min(d1, d2));</span>
<span class="pc bpc" id="L1205" title="1 of 2 branches missed.">                    if (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {</span>
<span class="nc" id="L1206">                        currentBest.setEntry(i, lowerBound[i]);</span>
                    }
<span class="pc bpc" id="L1208" title="1 of 2 branches missed.">                    if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {</span>
<span class="nc" id="L1209">                        currentBest.setEntry(i, upperBound[i]);</span>
                    }
                }
<span class="fc" id="L1212">                f = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);</span>
            }
<span class="fc" id="L1214">            return f;</span>
        }
        default: {
<span class="nc" id="L1217">            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, &quot;bobyqb&quot;);</span>
        }}
    } // bobyqb

    // ----------------------------------------------------------------------------------------

    /**
     *     The arguments N, NPT, XPT, XOPT, BMAT, ZMAT, NDIM, SL and SU all have
     *       the same meanings as the corresponding arguments of BOBYQB.
     *     KOPT is the index of the optimal interpolation point.
     *     KNEW is the index of the interpolation point that is going to be moved.
     *     ADELT is the current trust region bound.
     *     XNEW will be set to a suitable new position for the interpolation point
     *       XPT(KNEW,.). Specifically, it satisfies the SL, SU and trust region
     *       bounds and it should provide a large denominator in the next call of
     *       UPDATE. The step XNEW-XOPT from XOPT is restricted to moves along the
     *       straight lines through XOPT and another interpolation point.
     *     XALT also provides a large value of the modulus of the KNEW-th Lagrange
     *       function subject to the constraints that have been mentioned, its main
     *       difference from XNEW being that XALT-XOPT is a constrained version of
     *       the Cauchy step within the trust region. An exception is that XALT is
     *       not calculated if all components of GLAG (see below) are zero.
     *     ALPHA will be set to the KNEW-th diagonal element of the H matrix.
     *     CAUCHY will be set to the square of the KNEW-th Lagrange function at
     *       the step XALT-XOPT from XOPT for the vector XALT that is returned,
     *       except that CAUCHY is set to zero if XALT is not calculated.
     *     GLAG is a working space vector of length N for the gradient of the
     *       KNEW-th Lagrange function at XOPT.
     *     HCOL is a working space vector of length NPT for the second derivative
     *       coefficients of the KNEW-th Lagrange function.
     *     W is a working space vector of length 2N that is going to hold the
     *       constrained Cauchy step from XOPT of the Lagrange function, followed
     *       by the downhill version of XALT when the uphill step is calculated.
     *
     *     Set the first NPT components of W to the leading elements of the
     *     KNEW-th column of the H matrix.
     * @param knew
     * @param adelt
     */
    private double[] altmov(
            int knew,
            double adelt
    ) {
<span class="fc" id="L1260">        printMethod(); // XXX</span>

<span class="fc" id="L1262">        final int n = currentBest.getDimension();</span>
<span class="fc" id="L1263">        final int npt = numberOfInterpolationPoints;</span>

<span class="fc" id="L1265">        final ArrayRealVector glag = new ArrayRealVector(n);</span>
<span class="fc" id="L1266">        final ArrayRealVector hcol = new ArrayRealVector(npt);</span>

<span class="fc" id="L1268">        final ArrayRealVector work1 = new ArrayRealVector(n);</span>
<span class="fc" id="L1269">        final ArrayRealVector work2 = new ArrayRealVector(n);</span>

<span class="fc bfc" id="L1271" title="All 2 branches covered.">        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1272">            hcol.setEntry(k, ZERO);</span>
        }
<span class="fc bfc" id="L1274" title="All 2 branches covered.">        for (int j = 0, max = npt - n - 1; j &lt; max; j++) {</span>
<span class="fc" id="L1275">            final double tmp = zMatrix.getEntry(knew, j);</span>
<span class="fc bfc" id="L1276" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1277">                hcol.setEntry(k, hcol.getEntry(k) + tmp * zMatrix.getEntry(k, j));</span>
            }
        }
<span class="fc" id="L1280">        final double alpha = hcol.getEntry(knew);</span>
<span class="fc" id="L1281">        final double ha = HALF * alpha;</span>

        // Calculate the gradient of the KNEW-th Lagrange function at XOPT.

<span class="fc bfc" id="L1285" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1286">            glag.setEntry(i, bMatrix.getEntry(knew, i));</span>
        }
<span class="fc bfc" id="L1288" title="All 2 branches covered.">        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1289">            double tmp = ZERO;</span>
<span class="fc bfc" id="L1290" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1291">                tmp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);</span>
            }
<span class="fc" id="L1293">            tmp *= hcol.getEntry(k);</span>
<span class="fc bfc" id="L1294" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1295">                glag.setEntry(i, glag.getEntry(i) + tmp * interpolationPoints.getEntry(k, i));</span>
            }
        }

        // Search for a large denominator along the straight lines through XOPT
        // and another interpolation point. SLBD and SUBD will be lower and upper
        // bounds on the step along each of these lines in turn. PREDSQ will be
        // set to the square of the predicted denominator for each line. PRESAV
        // will be set to the largest admissible value of PREDSQ that occurs.

<span class="fc" id="L1305">        double presav = ZERO;</span>
<span class="fc" id="L1306">        double step = Double.NaN;</span>
<span class="fc" id="L1307">        int ksav = 0;</span>
<span class="fc" id="L1308">        int ibdsav = 0;</span>
<span class="fc" id="L1309">        double stpsav = 0;</span>
<span class="fc bfc" id="L1310" title="All 2 branches covered.">        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc bfc" id="L1311" title="All 2 branches covered.">            if (k == trustRegionCenterInterpolationPointIndex) {</span>
<span class="fc" id="L1312">                continue;</span>
            }
<span class="fc" id="L1314">            double dderiv = ZERO;</span>
<span class="fc" id="L1315">            double distsq = ZERO;</span>
<span class="fc bfc" id="L1316" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1317">                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);</span>
<span class="fc" id="L1318">                dderiv += glag.getEntry(i) * tmp;</span>
<span class="fc" id="L1319">                distsq += tmp * tmp;</span>
            }
<span class="fc" id="L1321">            double subd = adelt / Math.sqrt(distsq);</span>
<span class="fc" id="L1322">            double slbd = -subd;</span>
<span class="fc" id="L1323">            int ilbd = 0;</span>
<span class="fc" id="L1324">            int iubd = 0;</span>
<span class="fc" id="L1325">            final double sumin = Math.min(ONE, subd);</span>

            // Revise SLBD and SUBD if necessary because of the bounds in SL and SU.

<span class="fc bfc" id="L1329" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1330">                final double tmp = interpolationPoints.getEntry(k, i) - trustRegionCenterOffset.getEntry(i);</span>
<span class="fc bfc" id="L1331" title="All 2 branches covered.">                if (tmp &gt; ZERO) {</span>
<span class="pc bpc" id="L1332" title="1 of 2 branches missed.">                    if (slbd * tmp &lt; lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {</span>
<span class="nc" id="L1333">                        slbd = (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;</span>
<span class="nc" id="L1334">                        ilbd = -i - 1;</span>
                    }
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">                    if (subd * tmp &gt; upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {</span>
                        // Computing MAX
<span class="nc" id="L1338">                        subd = Math.max(sumin,</span>
<span class="nc" id="L1339">                                        (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);</span>
<span class="nc" id="L1340">                        iubd = i + 1;</span>
                    }
<span class="fc bfc" id="L1342" title="All 2 branches covered.">                } else if (tmp &lt; ZERO) {</span>
<span class="pc bpc" id="L1343" title="1 of 2 branches missed.">                    if (slbd * tmp &gt; upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {</span>
<span class="nc" id="L1344">                        slbd = (upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp;</span>
<span class="nc" id="L1345">                        ilbd = i + 1;</span>
                    }
<span class="pc bpc" id="L1347" title="1 of 2 branches missed.">                    if (subd * tmp &lt; lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) {</span>
                        // Computing MAX
<span class="nc" id="L1349">                        subd = Math.max(sumin,</span>
<span class="nc" id="L1350">                                        (lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i)) / tmp);</span>
<span class="nc" id="L1351">                        iubd = -i - 1;</span>
                    }
                }
            }

            // Seek a large modulus of the KNEW-th Lagrange function when the index
            // of the other interpolation point on the line through XOPT is KNEW.

<span class="fc" id="L1359">            step = slbd;</span>
<span class="fc" id="L1360">            int isbd = ilbd;</span>
<span class="fc" id="L1361">            double vlag = Double.NaN;</span>
<span class="fc bfc" id="L1362" title="All 2 branches covered.">            if (k == knew) {</span>
<span class="fc" id="L1363">                final double diff = dderiv - ONE;</span>
<span class="fc" id="L1364">                vlag = slbd * (dderiv - slbd * diff);</span>
<span class="fc" id="L1365">                final double d1 = subd * (dderiv - subd * diff);</span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">                if (Math.abs(d1) &gt; Math.abs(vlag)) {</span>
<span class="fc" id="L1367">                    step = subd;</span>
<span class="fc" id="L1368">                    vlag = d1;</span>
<span class="fc" id="L1369">                    isbd = iubd;</span>
                }
<span class="fc" id="L1371">                final double d2 = HALF * dderiv;</span>
<span class="fc" id="L1372">                final double d3 = d2 - diff * slbd;</span>
<span class="fc" id="L1373">                final double d4 = d2 - diff * subd;</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">                if (d3 * d4 &lt; ZERO) {</span>
<span class="fc" id="L1375">                    final double d5 = d2 * d2 / diff;</span>
<span class="pc bpc" id="L1376" title="1 of 2 branches missed.">                    if (Math.abs(d5) &gt; Math.abs(vlag)) {</span>
<span class="nc" id="L1377">                        step = d2 / diff;</span>
<span class="nc" id="L1378">                        vlag = d5;</span>
<span class="nc" id="L1379">                        isbd = 0;</span>
                    }
                }

                // Search along each of the other lines through XOPT and another point.

<span class="fc" id="L1385">            } else {</span>
<span class="fc" id="L1386">                vlag = slbd * (ONE - slbd);</span>
<span class="fc" id="L1387">                final double tmp = subd * (ONE - subd);</span>
<span class="pc bpc" id="L1388" title="1 of 2 branches missed.">                if (Math.abs(tmp) &gt; Math.abs(vlag)) {</span>
<span class="nc" id="L1389">                    step = subd;</span>
<span class="nc" id="L1390">                    vlag = tmp;</span>
<span class="nc" id="L1391">                    isbd = iubd;</span>
                }
<span class="fc bfc" id="L1393" title="All 2 branches covered.">                if (subd &gt; HALF) {</span>
<span class="pc bpc" id="L1394" title="1 of 2 branches missed.">                    if (Math.abs(vlag) &lt; ONE_OVER_FOUR) {</span>
<span class="nc" id="L1395">                        step = HALF;</span>
<span class="nc" id="L1396">                        vlag = ONE_OVER_FOUR;</span>
<span class="nc" id="L1397">                        isbd = 0;</span>
                    }
                }
<span class="fc" id="L1400">                vlag *= dderiv;</span>
            }

            // Calculate PREDSQ for the current line search and maintain PRESAV.

<span class="fc" id="L1405">            final double tmp = step * (ONE - step) * distsq;</span>
<span class="fc" id="L1406">            final double predsq = vlag * vlag * (vlag * vlag + ha * tmp * tmp);</span>
<span class="fc bfc" id="L1407" title="All 2 branches covered.">            if (predsq &gt; presav) {</span>
<span class="fc" id="L1408">                presav = predsq;</span>
<span class="fc" id="L1409">                ksav = k;</span>
<span class="fc" id="L1410">                stpsav = step;</span>
<span class="fc" id="L1411">                ibdsav = isbd;</span>
            }
        }

        // Construct XNEW in a way that satisfies the bound constraints exactly.

<span class="fc bfc" id="L1417" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1418">            final double tmp = trustRegionCenterOffset.getEntry(i) + stpsav * (interpolationPoints.getEntry(ksav, i) - trustRegionCenterOffset.getEntry(i));</span>
<span class="fc" id="L1419">            newPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),</span>
<span class="fc" id="L1420">                                      Math.min(upperDifference.getEntry(i), tmp)));</span>
        }
<span class="pc bpc" id="L1422" title="1 of 2 branches missed.">        if (ibdsav &lt; 0) {</span>
<span class="nc" id="L1423">            newPoint.setEntry(-ibdsav - 1, lowerDifference.getEntry(-ibdsav - 1));</span>
        }
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">        if (ibdsav &gt; 0) {</span>
<span class="nc" id="L1426">            newPoint.setEntry(ibdsav - 1, upperDifference.getEntry(ibdsav - 1));</span>
        }

        // Prepare for the iterative method that assembles the constrained Cauchy
        // step in W. The sum of squares of the fixed components of W is formed in
        // WFIXSQ, and the free components of W are set to BIGSTP.

<span class="fc" id="L1433">        final double bigstp = adelt + adelt;</span>
<span class="fc" id="L1434">        int iflag = 0;</span>
<span class="fc" id="L1435">        double cauchy = Double.NaN;</span>
<span class="fc" id="L1436">        double csave = ZERO;</span>
        while (true) {
<span class="fc" id="L1438">            double wfixsq = ZERO;</span>
<span class="fc" id="L1439">            double ggfree = ZERO;</span>
<span class="fc bfc" id="L1440" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1441">                final double glagValue = glag.getEntry(i);</span>
<span class="fc" id="L1442">                work1.setEntry(i, ZERO);</span>
<span class="fc bfc" id="L1443" title="All 2 branches covered.">                if (Math.min(trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i), glagValue) &gt; ZERO ||</span>
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">                    Math.max(trustRegionCenterOffset.getEntry(i) - upperDifference.getEntry(i), glagValue) &lt; ZERO) {</span>
<span class="fc" id="L1445">                    work1.setEntry(i, bigstp);</span>
                    // Computing 2nd power
<span class="fc" id="L1447">                    ggfree += glagValue * glagValue;</span>
                }
            }
<span class="pc bpc" id="L1450" title="1 of 2 branches missed.">            if (ggfree == ZERO) {</span>
<span class="nc" id="L1451">                return new double[] { alpha, ZERO };</span>
            }

            // Investigate whether more components of W can be fixed.
<span class="fc" id="L1455">            final double tmp1 = adelt * adelt - wfixsq;</span>
<span class="pc bpc" id="L1456" title="1 of 2 branches missed.">            if (tmp1 &gt; ZERO) {</span>
<span class="fc" id="L1457">                step = Math.sqrt(tmp1 / ggfree);</span>
<span class="fc" id="L1458">                ggfree = ZERO;</span>
<span class="fc bfc" id="L1459" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L1460" title="1 of 2 branches missed.">                    if (work1.getEntry(i) == bigstp) {</span>
<span class="fc" id="L1461">                        final double tmp2 = trustRegionCenterOffset.getEntry(i) - step * glag.getEntry(i);</span>
<span class="pc bpc" id="L1462" title="1 of 2 branches missed.">                        if (tmp2 &lt;= lowerDifference.getEntry(i)) {</span>
<span class="nc" id="L1463">                            work1.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
                            // Computing 2nd power
<span class="nc" id="L1465">                            final double d1 = work1.getEntry(i);</span>
<span class="nc" id="L1466">                            wfixsq += d1 * d1;</span>
<span class="pc bpc" id="L1467" title="1 of 2 branches missed.">                        } else if (tmp2 &gt;= upperDifference.getEntry(i)) {</span>
<span class="nc" id="L1468">                            work1.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
                            // Computing 2nd power
<span class="nc" id="L1470">                            final double d1 = work1.getEntry(i);</span>
<span class="nc" id="L1471">                            wfixsq += d1 * d1;</span>
<span class="nc" id="L1472">                        } else {</span>
                            // Computing 2nd power
<span class="fc" id="L1474">                            final double d1 = glag.getEntry(i);</span>
<span class="fc" id="L1475">                            ggfree += d1 * d1;</span>
                        }
                    }
                }
            }

            // Set the remaining free components of W and all components of XALT,
            // except that W may be scaled later.

<span class="fc" id="L1484">            double gw = ZERO;</span>
<span class="fc bfc" id="L1485" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1486">                final double glagValue = glag.getEntry(i);</span>
<span class="pc bpc" id="L1487" title="1 of 2 branches missed.">                if (work1.getEntry(i) == bigstp) {</span>
<span class="fc" id="L1488">                    work1.setEntry(i, -step * glagValue);</span>
<span class="fc" id="L1489">                    final double min = Math.min(upperDifference.getEntry(i),</span>
<span class="fc" id="L1490">                                                trustRegionCenterOffset.getEntry(i) + work1.getEntry(i));</span>
<span class="fc" id="L1491">                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i), min));</span>
<span class="pc bnc" id="L1492" title="All 2 branches missed.">                } else if (work1.getEntry(i) == ZERO) {</span>
<span class="nc" id="L1493">                    alternativeNewPoint.setEntry(i, trustRegionCenterOffset.getEntry(i));</span>
<span class="nc bnc" id="L1494" title="All 2 branches missed.">                } else if (glagValue &gt; ZERO) {</span>
<span class="nc" id="L1495">                    alternativeNewPoint.setEntry(i, lowerDifference.getEntry(i));</span>
                } else {
<span class="nc" id="L1497">                    alternativeNewPoint.setEntry(i, upperDifference.getEntry(i));</span>
                }
<span class="fc" id="L1499">                gw += glagValue * work1.getEntry(i);</span>
            }

            // Set CURV to the curvature of the KNEW-th Lagrange function along W.
            // Scale W by a factor less than one if that can reduce the modulus of
            // the Lagrange function at XOPT+W. Set CAUCHY to the final value of
            // the square of this function.

<span class="fc" id="L1507">            double curv = ZERO;</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1509">                double tmp = ZERO;</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">                for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1511">                    tmp += interpolationPoints.getEntry(k, j) * work1.getEntry(j);</span>
                }
<span class="fc" id="L1513">                curv += hcol.getEntry(k) * tmp * tmp;</span>
            }
<span class="fc bfc" id="L1515" title="All 2 branches covered.">            if (iflag == 1) {</span>
<span class="fc" id="L1516">                curv = -curv;</span>
            }
<span class="fc bfc" id="L1518" title="All 2 branches covered.">            if (curv &gt; -gw &amp;&amp;</span>
<span class="fc bfc" id="L1519" title="All 2 branches covered.">                curv &lt; -gw * (ONE + Math.sqrt(TWO))) {</span>
<span class="fc" id="L1520">                final double scale = -gw / curv;</span>
<span class="fc bfc" id="L1521" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1522">                    final double tmp = trustRegionCenterOffset.getEntry(i) + scale * work1.getEntry(i);</span>
<span class="fc" id="L1523">                    alternativeNewPoint.setEntry(i, Math.max(lowerDifference.getEntry(i),</span>
<span class="fc" id="L1524">                                              Math.min(upperDifference.getEntry(i), tmp)));</span>
                }
                // Computing 2nd power
<span class="fc" id="L1527">                final double d1 = HALF * gw * scale;</span>
<span class="fc" id="L1528">                cauchy = d1 * d1;</span>
<span class="fc" id="L1529">            } else {</span>
                // Computing 2nd power
<span class="fc" id="L1531">                final double d1 = gw + HALF * curv;</span>
<span class="fc" id="L1532">                cauchy = d1 * d1;</span>
            }

            // If IFLAG is zero, then XALT is calculated as before after reversing
            // the sign of GLAG. Thus two XALT vectors become available. The one that
            // is chosen is the one that gives the larger value of CAUCHY.

<span class="fc bfc" id="L1539" title="All 2 branches covered.">            if (iflag == 0) {</span>
<span class="fc bfc" id="L1540" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1541">                    glag.setEntry(i, -glag.getEntry(i));</span>
<span class="fc" id="L1542">                    work2.setEntry(i, alternativeNewPoint.getEntry(i));</span>
                }
<span class="fc" id="L1544">                csave = cauchy;</span>
<span class="fc" id="L1545">                iflag = 1;</span>
            } else {
                break;
            }
<span class="fc" id="L1549">        }</span>
<span class="fc bfc" id="L1550" title="All 2 branches covered.">        if (csave &gt; cauchy) {</span>
<span class="fc bfc" id="L1551" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1552">                alternativeNewPoint.setEntry(i, work2.getEntry(i));</span>
            }
<span class="fc" id="L1554">            cauchy = csave;</span>
        }

<span class="fc" id="L1557">        return new double[] { alpha, cauchy };</span>
    } // altmov

    // ----------------------------------------------------------------------------------------

    /**
     *     SUBROUTINE PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,
     *     BMAT and ZMAT for the first iteration, and it maintains the values of
     *     NF and KOPT. The vector X is also changed by PRELIM.
     *
     *     The arguments N, NPT, X, XL, XU, RHOBEG, IPRINT and MAXFUN are the
     *       same as the corresponding arguments in SUBROUTINE BOBYQA.
     *     The arguments XBASE, XPT, FVAL, HQ, PQ, BMAT, ZMAT, NDIM, SL and SU
     *       are the same as the corresponding arguments in BOBYQB, the elements
     *       of SL and SU being set in BOBYQA.
     *     GOPT is usually the gradient of the quadratic model at XOPT+XBASE, but
     *       it is set by PRELIM to the gradient of the quadratic model at XBASE.
     *       If XOPT is nonzero, BOBYQB will change it to its usual value later.
     *     NF is maintaned as the number of calls of CALFUN so far.
     *     KOPT will be such that the least calculated value of F so far is at
     *       the point XPT(KOPT,.)+XBASE in the space of the variables.
     *
     * @param lowerBound Lower bounds.
     * @param upperBound Upper bounds.
     */
    private void prelim(double[] lowerBound,
                        double[] upperBound) {
<span class="fc" id="L1584">        printMethod(); // XXX</span>

<span class="fc" id="L1586">        final int n = currentBest.getDimension();</span>
<span class="fc" id="L1587">        final int npt = numberOfInterpolationPoints;</span>
<span class="fc" id="L1588">        final int ndim = bMatrix.getRowDimension();</span>

<span class="fc" id="L1590">        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;</span>
<span class="fc" id="L1591">        final double recip = 1d / rhosq;</span>
<span class="fc" id="L1592">        final int np = n + 1;</span>

        // Set XBASE to the initial vector of variables, and set the initial
        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.

<span class="fc bfc" id="L1597" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1598">            originShift.setEntry(j, currentBest.getEntry(j));</span>
<span class="fc bfc" id="L1599" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1600">                interpolationPoints.setEntry(k, j, ZERO);</span>
            }
<span class="fc bfc" id="L1602" title="All 2 branches covered.">            for (int i = 0; i &lt; ndim; i++) {</span>
<span class="fc" id="L1603">                bMatrix.setEntry(i, j, ZERO);</span>
            }
        }
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        for (int i = 0, max = n * np / 2; i &lt; max; i++) {</span>
<span class="fc" id="L1607">            modelSecondDerivativesValues.setEntry(i, ZERO);</span>
        }
<span class="fc bfc" id="L1609" title="All 2 branches covered.">        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc" id="L1610">            modelSecondDerivativesParameters.setEntry(k, ZERO);</span>
<span class="fc bfc" id="L1611" title="All 2 branches covered.">            for (int j = 0, max = npt - np; j &lt; max; j++) {</span>
<span class="fc" id="L1612">                zMatrix.setEntry(k, j, ZERO);</span>
            }
        }

        // Begin the initialization procedure. NF becomes one more than the number
        // of function values so far. The coordinates of the displacement of the
        // next initial interpolation point from XBASE are set in XPT(NF+1,.).

<span class="fc" id="L1620">        int ipt = 0;</span>
<span class="fc" id="L1621">        int jpt = 0;</span>
<span class="fc" id="L1622">        double fbeg = Double.NaN;</span>
        do {
<span class="fc" id="L1624">            final int nfm = getEvaluations();</span>
<span class="fc" id="L1625">            final int nfx = nfm - n;</span>
<span class="fc" id="L1626">            final int nfmm = nfm - 1;</span>
<span class="fc" id="L1627">            final int nfxm = nfx - 1;</span>
<span class="fc" id="L1628">            double stepa = 0;</span>
<span class="fc" id="L1629">            double stepb = 0;</span>
<span class="pc bpc" id="L1630" title="1 of 2 branches missed.">            if (nfm &lt;= 2 * n) {</span>
<span class="fc bfc" id="L1631" title="All 4 branches covered.">                if (nfm &gt;= 1 &amp;&amp;</span>
                    nfm &lt;= n) {
<span class="fc" id="L1633">                    stepa = initialTrustRegionRadius;</span>
<span class="pc bpc" id="L1634" title="1 of 2 branches missed.">                    if (upperDifference.getEntry(nfmm) == ZERO) {</span>
<span class="nc" id="L1635">                        stepa = -stepa;</span>
<span class="nc" id="L1636">                        throw new PathIsExploredException(); // XXX</span>
                    }
<span class="fc" id="L1638">                    interpolationPoints.setEntry(nfm, nfmm, stepa);</span>
<span class="fc bfc" id="L1639" title="All 2 branches covered.">                } else if (nfm &gt; n) {</span>
<span class="fc" id="L1640">                    stepa = interpolationPoints.getEntry(nfx, nfxm);</span>
<span class="fc" id="L1641">                    stepb = -initialTrustRegionRadius;</span>
<span class="pc bpc" id="L1642" title="1 of 2 branches missed.">                    if (lowerDifference.getEntry(nfxm) == ZERO) {</span>
<span class="nc" id="L1643">                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));</span>
<span class="nc" id="L1644">                        throw new PathIsExploredException(); // XXX</span>
                    }
<span class="pc bpc" id="L1646" title="1 of 2 branches missed.">                    if (upperDifference.getEntry(nfxm) == ZERO) {</span>
<span class="nc" id="L1647">                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));</span>
<span class="nc" id="L1648">                        throw new PathIsExploredException(); // XXX</span>
                    }
<span class="fc" id="L1650">                    interpolationPoints.setEntry(nfm, nfxm, stepb);</span>
                }
            } else {
<span class="nc" id="L1653">                final int tmp1 = (nfm - np) / n;</span>
<span class="nc" id="L1654">                jpt = nfm - tmp1 * n - n;</span>
<span class="nc" id="L1655">                ipt = jpt + tmp1;</span>
<span class="nc bnc" id="L1656" title="All 2 branches missed.">                if (ipt &gt; n) {</span>
<span class="nc" id="L1657">                    final int tmp2 = jpt;</span>
<span class="nc" id="L1658">                    jpt = ipt - n;</span>
<span class="nc" id="L1659">                    ipt = tmp2;</span>
<span class="nc" id="L1660">                    throw new PathIsExploredException(); // XXX</span>
                }
<span class="nc" id="L1662">                interpolationPoints.setEntry(nfm, ipt, interpolationPoints.getEntry(ipt, ipt));</span>
<span class="nc" id="L1663">                interpolationPoints.setEntry(nfm, jpt, interpolationPoints.getEntry(jpt, jpt));</span>
            }

            // Calculate the next value of F. The least function value so far and
            // its index are required.

<span class="fc bfc" id="L1669" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L1670">                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],</span>
<span class="fc" id="L1671">                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),</span>
                                                 upperBound[j]));
<span class="pc bpc" id="L1673" title="1 of 2 branches missed.">                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {</span>
<span class="nc" id="L1674">                    currentBest.setEntry(j, lowerBound[j]);</span>
                }
<span class="fc bfc" id="L1676" title="All 2 branches covered.">                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {</span>
<span class="fc" id="L1677">                    currentBest.setEntry(j, upperBound[j]);</span>
                }
            }

<span class="fc" id="L1681">            final double objectiveValue = computeObjectiveValue(currentBest.toArray());</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">            final double f = isMinimize ? objectiveValue : -objectiveValue;</span>
<span class="fc" id="L1683">            final int numEval = getEvaluations(); // nfm + 1</span>
<span class="fc" id="L1684">            fAtInterpolationPoints.setEntry(nfm, f);</span>

<span class="fc bfc" id="L1686" title="All 2 branches covered.">            if (numEval == 1) {</span>
<span class="fc" id="L1687">                fbeg = f;</span>
<span class="fc" id="L1688">                trustRegionCenterInterpolationPointIndex = 0;</span>
<span class="fc bfc" id="L1689" title="All 2 branches covered.">            } else if (f &lt; fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {</span>
<span class="fc" id="L1690">                trustRegionCenterInterpolationPointIndex = nfm;</span>
            }

            // Set the nonzero initial elements of BMAT and the quadratic model in the
            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions
            // of the NF-th and (NF-N)-th interpolation points may be switched, in
            // order that the function value at the first of them contributes to the
            // off-diagonal second derivative terms of the initial quadratic model.

<span class="pc bpc" id="L1699" title="1 of 2 branches missed.">            if (numEval &lt;= 2 * n + 1) {</span>
<span class="fc bfc" id="L1700" title="All 4 branches covered.">                if (numEval &gt;= 2 &amp;&amp;</span>
                    numEval &lt;= n + 1) {
<span class="fc" id="L1702">                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);</span>
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">                    if (npt &lt; numEval + n) {</span>
<span class="nc" id="L1704">                        final double oneOverStepA = ONE / stepa;</span>
<span class="nc" id="L1705">                        bMatrix.setEntry(0, nfmm, -oneOverStepA);</span>
<span class="nc" id="L1706">                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);</span>
<span class="nc" id="L1707">                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);</span>
<span class="nc" id="L1708">                        throw new PathIsExploredException(); // XXX</span>
                    }
<span class="fc bfc" id="L1710" title="All 2 branches covered.">                } else if (numEval &gt;= n + 2) {</span>
<span class="fc" id="L1711">                    final int ih = nfx * (nfx + 1) / 2 - 1;</span>
<span class="fc" id="L1712">                    final double tmp = (f - fbeg) / stepb;</span>
<span class="fc" id="L1713">                    final double diff = stepb - stepa;</span>
<span class="fc" id="L1714">                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);</span>
<span class="fc" id="L1715">                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);</span>
<span class="pc bpc" id="L1716" title="1 of 2 branches missed.">                    if (stepa * stepb &lt; ZERO) {</span>
<span class="fc bfc" id="L1717" title="All 2 branches covered.">                        if (f &lt; fAtInterpolationPoints.getEntry(nfm - n)) {</span>
<span class="fc" id="L1718">                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));</span>
<span class="fc" id="L1719">                            fAtInterpolationPoints.setEntry(nfm - n, f);</span>
<span class="fc bfc" id="L1720" title="All 2 branches covered.">                            if (trustRegionCenterInterpolationPointIndex == nfm) {</span>
<span class="fc" id="L1721">                                trustRegionCenterInterpolationPointIndex = nfm - n;</span>
                            }
<span class="fc" id="L1723">                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);</span>
<span class="fc" id="L1724">                            interpolationPoints.setEntry(nfm, nfxm, stepa);</span>
                        }
                    }
<span class="fc" id="L1727">                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));</span>
<span class="fc" id="L1728">                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));</span>
<span class="fc" id="L1729">                    bMatrix.setEntry(nfm - n, nfxm,</span>
<span class="fc" id="L1730">                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));</span>
<span class="fc" id="L1731">                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));</span>
<span class="fc" id="L1732">                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);</span>
                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX &quot;testAckley&quot; and &quot;testDiffPow&quot; fail.
<span class="fc" id="L1734">                    zMatrix.setEntry(nfm - n, nfxm,</span>
<span class="fc" id="L1735">                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));</span>
<span class="fc" id="L1736">                }</span>

                // Set the off-diagonal second derivatives of the Lagrange functions and
                // the initial quadratic model.

            } else {
<span class="nc" id="L1742">                zMatrix.setEntry(0, nfxm, recip);</span>
<span class="nc" id="L1743">                zMatrix.setEntry(nfm, nfxm, recip);</span>
<span class="nc" id="L1744">                zMatrix.setEntry(ipt, nfxm, -recip);</span>
<span class="nc" id="L1745">                zMatrix.setEntry(jpt, nfxm, -recip);</span>

<span class="nc" id="L1747">                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;</span>
<span class="nc" id="L1748">                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);</span>
<span class="nc" id="L1749">                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);</span>
<span class="nc" id="L1750">                throw new PathIsExploredException(); // XXX</span>
            }
<span class="fc bfc" id="L1752" title="All 2 branches covered.">        } while (getEvaluations() &lt; npt);</span>
<span class="fc" id="L1753">    } // prelim</span>


    // ----------------------------------------------------------------------------------------

    /**
     *     A version of the truncated conjugate gradient is applied. If a line
     *     search is restricted by a constraint, then the procedure is restarted,
     *     the values of the variables that are at their bounds being fixed. If
     *     the trust region boundary is reached, then further changes may be made
     *     to D, each one being in the two dimensional space that is spanned
     *     by the current D and the gradient of Q at XOPT+D, staying on the trust
     *     region boundary. Termination occurs when the reduction in Q seems to
     *     be close to the greatest reduction that can be achieved.
     *     The arguments N, NPT, XPT, XOPT, GOPT, HQ, PQ, SL and SU have the same
     *       meanings as the corresponding arguments of BOBYQB.
     *     DELTA is the trust region radius for the present calculation, which
     *       seeks a small value of the quadratic model within distance DELTA of
     *       XOPT subject to the bounds on the variables.
     *     XNEW will be set to a new vector of variables that is approximately
     *       the one that minimizes the quadratic model within the trust region
     *       subject to the SL and SU constraints on the variables. It satisfies
     *       as equations the bounds that become active during the calculation.
     *     D is the calculated trial step from XOPT, generated iteratively from an
     *       initial value of zero. Thus XNEW is XOPT+D after the final iteration.
     *     GNEW holds the gradient of the quadratic model at XOPT+D. It is updated
     *       when D is updated.
     *     xbdi.get( is a working space vector. For I=1,2,...,N, the element xbdi.get((I) is
     *       set to -1.0, 0.0, or 1.0, the value being nonzero if and only if the
     *       I-th variable has become fixed at a bound, the bound being SL(I) or
     *       SU(I) in the case xbdi.get((I)=-1.0 or xbdi.get((I)=1.0, respectively. This
     *       information is accumulated during the construction of XNEW.
     *     The arrays S, HS and HRED are also used for working space. They hold the
     *       current search direction, and the changes in the gradient of Q along S
     *       and the reduced D, respectively, where the reduced D is the same as D,
     *       except that the components of the fixed variables are zero.
     *     DSQ will be set to the square of the length of XNEW-XOPT.
     *     CRVMIN is set to zero if D reaches the trust region boundary. Otherwise
     *       it is set to the least curvature of H that occurs in the conjugate
     *       gradient searches that are not restricted by any constraints. The
     *       value CRVMIN=-1.0D0 is set, however, if all of these searches are
     *       constrained.
     * @param delta
     * @param gnew
     * @param xbdi
     * @param s
     * @param hs
     * @param hred
     */
    private double[] trsbox(
            double delta,
            ArrayRealVector gnew,
            ArrayRealVector xbdi,
            ArrayRealVector s,
            ArrayRealVector hs,
            ArrayRealVector hred
    ) {
<span class="fc" id="L1810">        printMethod(); // XXX</span>

<span class="fc" id="L1812">        final int n = currentBest.getDimension();</span>
<span class="fc" id="L1813">        final int npt = numberOfInterpolationPoints;</span>

<span class="fc" id="L1815">        double dsq = Double.NaN;</span>
<span class="fc" id="L1816">        double crvmin = Double.NaN;</span>

        // Local variables
        double ds;
        int iu;
<span class="fc" id="L1821">        double dhd, dhs, cth, shs, sth, ssq, beta=0, sdec, blen;</span>
<span class="fc" id="L1822">        int iact = -1;</span>
<span class="fc" id="L1823">        int nact = 0;</span>
<span class="fc" id="L1824">        double angt = 0, qred;</span>
        int isav;
<span class="fc" id="L1826">        double temp = 0, xsav = 0, xsum = 0, angbd = 0, dredg = 0, sredg = 0;</span>
        int iterc;
<span class="fc" id="L1828">        double resid = 0, delsq = 0, ggsav = 0, tempa = 0, tempb = 0,</span>
<span class="fc" id="L1829">        redmax = 0, dredsq = 0, redsav = 0, gredsq = 0, rednew = 0;</span>
<span class="fc" id="L1830">        int itcsav = 0;</span>
<span class="fc" id="L1831">        double rdprev = 0, rdnext = 0, stplen = 0, stepsq = 0;</span>
<span class="fc" id="L1832">        int itermax = 0;</span>

        // Set some constants.

        // Function Body

        // The sign of GOPT(I) gives the sign of the change to the I-th variable
        // that will reduce Q from its value at XOPT. Thus xbdi.get((I) shows whether
        // or not to fix the I-th variable at one of its bounds initially, with
        // NACT being set to the number of fixed variables. D and GNEW are also
        // set for the first iteration. DELSQ is the upper bound on the sum of
        // squares of the free variables. QRED is the reduction in Q so far.

<span class="fc" id="L1845">        iterc = 0;</span>
<span class="fc" id="L1846">        nact = 0;</span>
<span class="fc bfc" id="L1847" title="All 2 branches covered.">        for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1848">            xbdi.setEntry(i, ZERO);</span>
<span class="pc bpc" id="L1849" title="1 of 2 branches missed.">            if (trustRegionCenterOffset.getEntry(i) &lt;= lowerDifference.getEntry(i)) {</span>
<span class="nc bnc" id="L1850" title="All 2 branches missed.">                if (gradientAtTrustRegionCenter.getEntry(i) &gt;= ZERO) {</span>
<span class="nc" id="L1851">                    xbdi.setEntry(i, MINUS_ONE);</span>
                }
<span class="pc bpc" id="L1853" title="1 of 2 branches missed.">            } else if (trustRegionCenterOffset.getEntry(i) &gt;= upperDifference.getEntry(i)) {</span>
<span class="nc bnc" id="L1854" title="All 2 branches missed.">                if (gradientAtTrustRegionCenter.getEntry(i) &lt;= ZERO) {</span>
<span class="nc" id="L1855">                    xbdi.setEntry(i, ONE);</span>
                }
            }
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">            if (xbdi.getEntry(i) != ZERO) {</span>
<span class="nc" id="L1859">                ++nact;</span>
            }
<span class="fc" id="L1861">            trialStepPoint.setEntry(i, ZERO);</span>
<span class="fc" id="L1862">            gnew.setEntry(i, gradientAtTrustRegionCenter.getEntry(i));</span>
        }
<span class="fc" id="L1864">        delsq = delta * delta;</span>
<span class="fc" id="L1865">        qred = ZERO;</span>
<span class="fc" id="L1866">        crvmin = MINUS_ONE;</span>

        // Set the next search direction of the conjugate gradient method. It is
        // the steepest descent direction initially and when the iterations are
        // restarted because a variable has just been fixed by a bound, and of
        // course the components of the fixed variables are zero. ITERMAX is an
        // upper bound on the indices of the conjugate gradient iterations.

<span class="fc" id="L1874">        int state = 20;</span>
        for(;;) {
<span class="pc bpc" id="L1876" title="3 of 10 branches missed.">            switch (state) {</span>
        case 20: {
<span class="fc" id="L1878">            printState(20); // XXX</span>
<span class="fc" id="L1879">            beta = ZERO;</span>
        }
        case 30: {
<span class="fc" id="L1882">            printState(30); // XXX</span>
<span class="fc" id="L1883">            stepsq = ZERO;</span>
<span class="fc bfc" id="L1884" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L1885" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) != ZERO) {</span>
<span class="nc" id="L1886">                    s.setEntry(i, ZERO);</span>
<span class="fc bfc" id="L1887" title="All 2 branches covered.">                } else if (beta == ZERO) {</span>
<span class="fc" id="L1888">                    s.setEntry(i, -gnew.getEntry(i));</span>
                } else {
<span class="fc" id="L1890">                    s.setEntry(i, beta * s.getEntry(i) - gnew.getEntry(i));</span>
                }
                // Computing 2nd power
<span class="fc" id="L1893">                final double d1 = s.getEntry(i);</span>
<span class="fc" id="L1894">                stepsq += d1 * d1;</span>
            }
<span class="fc bfc" id="L1896" title="All 2 branches covered.">            if (stepsq == ZERO) {</span>
<span class="fc" id="L1897">                state = 190; break;</span>
            }
<span class="fc bfc" id="L1899" title="All 2 branches covered.">            if (beta == ZERO) {</span>
<span class="fc" id="L1900">                gredsq = stepsq;</span>
<span class="fc" id="L1901">                itermax = iterc + n - nact;</span>
            }
<span class="fc bfc" id="L1903" title="All 2 branches covered.">            if (gredsq * delsq &lt;= qred * 1e-4 * qred) {</span>
<span class="fc" id="L1904">                state = 190; break;</span>
            }

            // Multiply the search direction by the second derivative matrix of Q and
            // calculate some scalars for the choice of steplength. Then set BLEN to
            // the length of the the step to the trust region boundary and STPLEN to
            // the steplength, ignoring the simple bounds.

<span class="fc" id="L1912">            state = 210; break;</span>
        }
        case 50: {
<span class="fc" id="L1915">            printState(50); // XXX</span>
<span class="fc" id="L1916">            resid = delsq;</span>
<span class="fc" id="L1917">            ds = ZERO;</span>
<span class="fc" id="L1918">            shs = ZERO;</span>
<span class="fc bfc" id="L1919" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L1920" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
                    // Computing 2nd power
<span class="fc" id="L1922">                    final double d1 = trialStepPoint.getEntry(i);</span>
<span class="fc" id="L1923">                    resid -= d1 * d1;</span>
<span class="fc" id="L1924">                    ds += s.getEntry(i) * trialStepPoint.getEntry(i);</span>
<span class="fc" id="L1925">                    shs += s.getEntry(i) * hs.getEntry(i);</span>
                }
            }
<span class="pc bpc" id="L1928" title="1 of 2 branches missed.">            if (resid &lt;= ZERO) {</span>
<span class="nc" id="L1929">                state = 90; break;</span>
            }
<span class="fc" id="L1931">            temp = Math.sqrt(stepsq * resid + ds * ds);</span>
<span class="fc bfc" id="L1932" title="All 2 branches covered.">            if (ds &lt; ZERO) {</span>
<span class="fc" id="L1933">                blen = (temp - ds) / stepsq;</span>
            } else {
<span class="fc" id="L1935">                blen = resid / (temp + ds);</span>
            }
<span class="fc" id="L1937">            stplen = blen;</span>
<span class="fc bfc" id="L1938" title="All 2 branches covered.">            if (shs &gt; ZERO) {</span>
                // Computing MIN
<span class="fc" id="L1940">                stplen = Math.min(blen, gredsq / shs);</span>
            }

            // Reduce STPLEN if necessary in order to preserve the simple bounds,
            // letting IACT be the index of the new constrained variable.

<span class="fc" id="L1946">            iact = -1;</span>
<span class="fc bfc" id="L1947" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L1948" title="1 of 2 branches missed.">                if (s.getEntry(i) != ZERO) {</span>
<span class="fc" id="L1949">                    xsum = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i);</span>
<span class="fc bfc" id="L1950" title="All 2 branches covered.">                    if (s.getEntry(i) &gt; ZERO) {</span>
<span class="fc" id="L1951">                        temp = (upperDifference.getEntry(i) - xsum) / s.getEntry(i);</span>
                    } else {
<span class="fc" id="L1953">                        temp = (lowerDifference.getEntry(i) - xsum) / s.getEntry(i);</span>
                    }
<span class="pc bpc" id="L1955" title="1 of 2 branches missed.">                    if (temp &lt; stplen) {</span>
<span class="nc" id="L1956">                        stplen = temp;</span>
<span class="nc" id="L1957">                        iact = i;</span>
                    }
                }
            }

            // Update CRVMIN, GNEW and D. Set SDEC to the decrease that occurs in Q.

<span class="fc" id="L1964">            sdec = ZERO;</span>
<span class="pc bpc" id="L1965" title="1 of 2 branches missed.">            if (stplen &gt; ZERO) {</span>
<span class="fc" id="L1966">                ++iterc;</span>
<span class="fc" id="L1967">                temp = shs / stepsq;</span>
<span class="pc bpc" id="L1968" title="1 of 4 branches missed.">                if (iact == -1 &amp;&amp; temp &gt; ZERO) {</span>
<span class="fc" id="L1969">                    crvmin = Math.min(crvmin,temp);</span>
<span class="fc bfc" id="L1970" title="All 2 branches covered.">                    if (crvmin == MINUS_ONE) {</span>
<span class="fc" id="L1971">                        crvmin = temp;</span>
                    }
                }
<span class="fc" id="L1974">                ggsav = gredsq;</span>
<span class="fc" id="L1975">                gredsq = ZERO;</span>
<span class="fc bfc" id="L1976" title="All 2 branches covered.">                for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L1977">                    gnew.setEntry(i, gnew.getEntry(i) + stplen * hs.getEntry(i));</span>
<span class="pc bpc" id="L1978" title="1 of 2 branches missed.">                    if (xbdi.getEntry(i) == ZERO) {</span>
                        // Computing 2nd power
<span class="fc" id="L1980">                        final double d1 = gnew.getEntry(i);</span>
<span class="fc" id="L1981">                        gredsq += d1 * d1;</span>
                    }
<span class="fc" id="L1983">                    trialStepPoint.setEntry(i, trialStepPoint.getEntry(i) + stplen * s.getEntry(i));</span>
                }
                // Computing MAX
<span class="fc" id="L1986">                final double d1 = stplen * (ggsav - HALF * stplen * shs);</span>
<span class="fc" id="L1987">                sdec = Math.max(d1, ZERO);</span>
<span class="fc" id="L1988">                qred += sdec;</span>
            }

            // Restart the conjugate gradient method if it has hit a new bound.

<span class="pc bpc" id="L1993" title="1 of 2 branches missed.">            if (iact &gt;= 0) {</span>
<span class="nc" id="L1994">                ++nact;</span>
<span class="nc" id="L1995">                xbdi.setEntry(iact, ONE);</span>
<span class="nc bnc" id="L1996" title="All 2 branches missed.">                if (s.getEntry(iact) &lt; ZERO) {</span>
<span class="nc" id="L1997">                    xbdi.setEntry(iact, MINUS_ONE);</span>
                }
                // Computing 2nd power
<span class="nc" id="L2000">                final double d1 = trialStepPoint.getEntry(iact);</span>
<span class="nc" id="L2001">                delsq -= d1 * d1;</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">                if (delsq &lt;= ZERO) {</span>
<span class="nc" id="L2003">                    state = 190; break;</span>
                }
<span class="nc" id="L2005">                state = 20; break;</span>
            }

            // If STPLEN is less than BLEN, then either apply another conjugate
            // gradient iteration or RETURN.

<span class="fc bfc" id="L2011" title="All 2 branches covered.">            if (stplen &lt; blen) {</span>
<span class="fc bfc" id="L2012" title="All 2 branches covered.">                if (iterc == itermax) {</span>
<span class="fc" id="L2013">                    state = 190; break;</span>
                }
<span class="fc bfc" id="L2015" title="All 2 branches covered.">                if (sdec &lt;= qred * .01) {</span>
<span class="fc" id="L2016">                    state = 190; break;</span>
                }
<span class="fc" id="L2018">                beta = gredsq / ggsav;</span>
<span class="fc" id="L2019">                state = 30; break;</span>
            }
        }
        case 90: {
<span class="fc" id="L2023">            printState(90); // XXX</span>
<span class="fc" id="L2024">            crvmin = ZERO;</span>

            // Prepare for the alternative iteration by calculating some scalars
            // and by multiplying the reduced D by the second derivative matrix of
            // Q, where S holds the reduced D in the call of GGMULT.

        }
        case 100: {
<span class="fc" id="L2032">            printState(100); // XXX</span>
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">            if (nact &gt;= n - 1) {</span>
<span class="nc" id="L2034">                state = 190; break;</span>
            }
<span class="fc" id="L2036">            dredsq = ZERO;</span>
<span class="fc" id="L2037">            dredg = ZERO;</span>
<span class="fc" id="L2038">            gredsq = ZERO;</span>
<span class="fc bfc" id="L2039" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L2040" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
                    // Computing 2nd power
<span class="fc" id="L2042">                    double d1 = trialStepPoint.getEntry(i);</span>
<span class="fc" id="L2043">                    dredsq += d1 * d1;</span>
<span class="fc" id="L2044">                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);</span>
                    // Computing 2nd power
<span class="fc" id="L2046">                    d1 = gnew.getEntry(i);</span>
<span class="fc" id="L2047">                    gredsq += d1 * d1;</span>
<span class="fc" id="L2048">                    s.setEntry(i, trialStepPoint.getEntry(i));</span>
<span class="fc" id="L2049">                } else {</span>
<span class="nc" id="L2050">                    s.setEntry(i, ZERO);</span>
                }
            }
<span class="fc" id="L2053">            itcsav = iterc;</span>
<span class="fc" id="L2054">            state = 210; break;</span>
            // Let the search direction S be a linear combination of the reduced D
            // and the reduced G that is orthogonal to the reduced D.
        }
        case 120: {
<span class="fc" id="L2059">            printState(120); // XXX</span>
<span class="fc" id="L2060">            ++iterc;</span>
<span class="fc" id="L2061">            temp = gredsq * dredsq - dredg * dredg;</span>
<span class="fc bfc" id="L2062" title="All 2 branches covered.">            if (temp &lt;= qred * 1e-4 * qred) {</span>
<span class="fc" id="L2063">                state = 190; break;</span>
            }
<span class="fc" id="L2065">            temp = Math.sqrt(temp);</span>
<span class="fc bfc" id="L2066" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L2067" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
<span class="fc" id="L2068">                    s.setEntry(i, (dredg * trialStepPoint.getEntry(i) - dredsq * gnew.getEntry(i)) / temp);</span>
                } else {
<span class="nc" id="L2070">                    s.setEntry(i, ZERO);</span>
                }
            }
<span class="fc" id="L2073">            sredg = -temp;</span>

            // By considering the simple bounds on the variables, calculate an upper
            // bound on the tangent of half the angle of the alternative iteration,
            // namely ANGBD, except that, if already a free variable has reached a
            // bound, there is a branch back to label 100 after fixing that variable.

<span class="fc" id="L2080">            angbd = ONE;</span>
<span class="fc" id="L2081">            iact = -1;</span>
<span class="fc bfc" id="L2082" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L2083" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
<span class="fc" id="L2084">                    tempa = trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i) - lowerDifference.getEntry(i);</span>
<span class="fc" id="L2085">                    tempb = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i) - trialStepPoint.getEntry(i);</span>
<span class="pc bpc" id="L2086" title="1 of 2 branches missed.">                    if (tempa &lt;= ZERO) {</span>
<span class="nc" id="L2087">                        ++nact;</span>
<span class="nc" id="L2088">                        xbdi.setEntry(i, MINUS_ONE);</span>
<span class="nc" id="L2089">                        state = 100; break;</span>
<span class="pc bpc" id="L2090" title="1 of 2 branches missed.">                    } else if (tempb &lt;= ZERO) {</span>
<span class="nc" id="L2091">                        ++nact;</span>
<span class="nc" id="L2092">                        xbdi.setEntry(i, ONE);</span>
<span class="nc" id="L2093">                        state = 100; break;</span>
                    }
                    // Computing 2nd power
<span class="fc" id="L2096">                    double d1 = trialStepPoint.getEntry(i);</span>
                    // Computing 2nd power
<span class="fc" id="L2098">                    double d2 = s.getEntry(i);</span>
<span class="fc" id="L2099">                    ssq = d1 * d1 + d2 * d2;</span>
                    // Computing 2nd power
<span class="fc" id="L2101">                    d1 = trustRegionCenterOffset.getEntry(i) - lowerDifference.getEntry(i);</span>
<span class="fc" id="L2102">                    temp = ssq - d1 * d1;</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">                    if (temp &gt; ZERO) {</span>
<span class="nc" id="L2104">                        temp = Math.sqrt(temp) - s.getEntry(i);</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">                        if (angbd * temp &gt; tempa) {</span>
<span class="nc" id="L2106">                            angbd = tempa / temp;</span>
<span class="nc" id="L2107">                            iact = i;</span>
<span class="nc" id="L2108">                            xsav = MINUS_ONE;</span>
                        }
                    }
                    // Computing 2nd power
<span class="fc" id="L2112">                    d1 = upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i);</span>
<span class="fc" id="L2113">                    temp = ssq - d1 * d1;</span>
<span class="pc bpc" id="L2114" title="1 of 2 branches missed.">                    if (temp &gt; ZERO) {</span>
<span class="nc" id="L2115">                        temp = Math.sqrt(temp) + s.getEntry(i);</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">                        if (angbd * temp &gt; tempb) {</span>
<span class="nc" id="L2117">                            angbd = tempb / temp;</span>
<span class="nc" id="L2118">                            iact = i;</span>
<span class="nc" id="L2119">                            xsav = ONE;</span>
                        }
                    }
                }
            }

            // Calculate HHD and some curvatures for the alternative iteration.

<span class="fc" id="L2127">            state = 210; break;</span>
        }
        case 150: {
<span class="fc" id="L2130">            printState(150); // XXX</span>
<span class="fc" id="L2131">            shs = ZERO;</span>
<span class="fc" id="L2132">            dhs = ZERO;</span>
<span class="fc" id="L2133">            dhd = ZERO;</span>
<span class="fc bfc" id="L2134" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="pc bpc" id="L2135" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
<span class="fc" id="L2136">                    shs += s.getEntry(i) * hs.getEntry(i);</span>
<span class="fc" id="L2137">                    dhs += trialStepPoint.getEntry(i) * hs.getEntry(i);</span>
<span class="fc" id="L2138">                    dhd += trialStepPoint.getEntry(i) * hred.getEntry(i);</span>
                }
            }

            // Seek the greatest reduction in Q for a range of equally spaced values
            // of ANGT in [0,ANGBD], where ANGT is the tangent of half the angle of
            // the alternative iteration.

<span class="fc" id="L2146">            redmax = ZERO;</span>
<span class="fc" id="L2147">            isav = -1;</span>
<span class="fc" id="L2148">            redsav = ZERO;</span>
<span class="fc" id="L2149">            iu = (int) (angbd * 17. + 3.1);</span>
<span class="fc bfc" id="L2150" title="All 2 branches covered.">            for (int i = 0; i &lt; iu; i++) {</span>
<span class="fc" id="L2151">                angt = angbd * i / iu;</span>
<span class="fc" id="L2152">                sth = (angt + angt) / (ONE + angt * angt);</span>
<span class="fc" id="L2153">                temp = shs + angt * (angt * dhd - dhs - dhs);</span>
<span class="fc" id="L2154">                rednew = sth * (angt * dredg - sredg - HALF * sth * temp);</span>
<span class="fc bfc" id="L2155" title="All 2 branches covered.">                if (rednew &gt; redmax) {</span>
<span class="fc" id="L2156">                    redmax = rednew;</span>
<span class="fc" id="L2157">                    isav = i;</span>
<span class="fc" id="L2158">                    rdprev = redsav;</span>
<span class="fc bfc" id="L2159" title="All 2 branches covered.">                } else if (i == isav + 1) {</span>
<span class="fc" id="L2160">                    rdnext = rednew;</span>
                }
<span class="fc" id="L2162">                redsav = rednew;</span>
            }

            // Return if the reduction is zero. Otherwise, set the sine and cosine
            // of the angle of the alternative iteration, and calculate SDEC.

<span class="fc bfc" id="L2168" title="All 2 branches covered.">            if (isav &lt; 0) {</span>
<span class="fc" id="L2169">                state = 190; break;</span>
            }
<span class="pc bpc" id="L2171" title="1 of 2 branches missed.">            if (isav &lt; iu) {</span>
<span class="fc" id="L2172">                temp = (rdnext - rdprev) / (redmax + redmax - rdprev - rdnext);</span>
<span class="fc" id="L2173">                angt = angbd * (isav + HALF * temp) / iu;</span>
            }
<span class="fc" id="L2175">            cth = (ONE - angt * angt) / (ONE + angt * angt);</span>
<span class="fc" id="L2176">            sth = (angt + angt) / (ONE + angt * angt);</span>
<span class="fc" id="L2177">            temp = shs + angt * (angt * dhd - dhs - dhs);</span>
<span class="fc" id="L2178">            sdec = sth * (angt * dredg - sredg - HALF * sth * temp);</span>
<span class="pc bpc" id="L2179" title="1 of 2 branches missed.">            if (sdec &lt;= ZERO) {</span>
<span class="nc" id="L2180">                state = 190; break;</span>
            }

            // Update GNEW, D and HRED. If the angle of the alternative iteration
            // is restricted by a bound on a free variable, that variable is fixed
            // at the bound.

<span class="fc" id="L2187">            dredg = ZERO;</span>
<span class="fc" id="L2188">            gredsq = ZERO;</span>
<span class="fc bfc" id="L2189" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2190">                gnew.setEntry(i, gnew.getEntry(i) + (cth - ONE) * hred.getEntry(i) + sth * hs.getEntry(i));</span>
<span class="pc bpc" id="L2191" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ZERO) {</span>
<span class="fc" id="L2192">                    trialStepPoint.setEntry(i, cth * trialStepPoint.getEntry(i) + sth * s.getEntry(i));</span>
<span class="fc" id="L2193">                    dredg += trialStepPoint.getEntry(i) * gnew.getEntry(i);</span>
                    // Computing 2nd power
<span class="fc" id="L2195">                    final double d1 = gnew.getEntry(i);</span>
<span class="fc" id="L2196">                    gredsq += d1 * d1;</span>
                }
<span class="fc" id="L2198">                hred.setEntry(i, cth * hred.getEntry(i) + sth * hs.getEntry(i));</span>
            }
<span class="fc" id="L2200">            qred += sdec;</span>
<span class="pc bpc" id="L2201" title="3 of 4 branches missed.">            if (iact &gt;= 0 &amp;&amp; isav == iu) {</span>
<span class="nc" id="L2202">                ++nact;</span>
<span class="nc" id="L2203">                xbdi.setEntry(iact, xsav);</span>
<span class="nc" id="L2204">                state = 100; break;</span>
            }

            // If SDEC is sufficiently small, then RETURN after setting XNEW to
            // XOPT+D, giving careful attention to the bounds.

<span class="fc bfc" id="L2210" title="All 2 branches covered.">            if (sdec &gt; qred * .01) {</span>
<span class="fc" id="L2211">                state = 120; break;</span>
            }
        }
        case 190: {
<span class="fc" id="L2215">            printState(190); // XXX</span>
<span class="fc" id="L2216">            dsq = ZERO;</span>
<span class="fc bfc" id="L2217" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
                // Computing MAX
                // Computing MIN
<span class="fc" id="L2220">                final double min = Math.min(trustRegionCenterOffset.getEntry(i) + trialStepPoint.getEntry(i),</span>
<span class="fc" id="L2221">                                            upperDifference.getEntry(i));</span>
<span class="fc" id="L2222">                newPoint.setEntry(i, Math.max(min, lowerDifference.getEntry(i)));</span>
<span class="pc bpc" id="L2223" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == MINUS_ONE) {</span>
<span class="nc" id="L2224">                    newPoint.setEntry(i, lowerDifference.getEntry(i));</span>
                }
<span class="pc bpc" id="L2226" title="1 of 2 branches missed.">                if (xbdi.getEntry(i) == ONE) {</span>
<span class="nc" id="L2227">                    newPoint.setEntry(i, upperDifference.getEntry(i));</span>
                }
<span class="fc" id="L2229">                trialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));</span>
                // Computing 2nd power
<span class="fc" id="L2231">                final double d1 = trialStepPoint.getEntry(i);</span>
<span class="fc" id="L2232">                dsq += d1 * d1;</span>
            }
<span class="fc" id="L2234">            return new double[] { dsq, crvmin };</span>
            // The following instructions multiply the current S-vector by the second
            // derivative matrix of the quadratic model, putting the product in HS.
            // They are reached from three different parts of the software above and
            // they can be regarded as an external subroutine.
        }
        case 210: {
<span class="fc" id="L2241">            printState(210); // XXX</span>
<span class="fc" id="L2242">            int ih = 0;</span>
<span class="fc bfc" id="L2243" title="All 2 branches covered.">            for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L2244">                hs.setEntry(j, ZERO);</span>
<span class="fc bfc" id="L2245" title="All 2 branches covered.">                for (int i = 0; i &lt;= j; i++) {</span>
<span class="fc bfc" id="L2246" title="All 2 branches covered.">                    if (i &lt; j) {</span>
<span class="fc" id="L2247">                        hs.setEntry(j, hs.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(i));</span>
                    }
<span class="fc" id="L2249">                    hs.setEntry(i, hs.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * s.getEntry(j));</span>
<span class="fc" id="L2250">                    ih++;</span>
                }
            }
<span class="fc" id="L2253">            final RealVector tmp = interpolationPoints.operate(s).ebeMultiply(modelSecondDerivativesParameters);</span>
<span class="fc bfc" id="L2254" title="All 2 branches covered.">            for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc bfc" id="L2255" title="All 2 branches covered.">                if (modelSecondDerivativesParameters.getEntry(k) != ZERO) {</span>
<span class="fc bfc" id="L2256" title="All 2 branches covered.">                    for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2257">                        hs.setEntry(i, hs.getEntry(i) + tmp.getEntry(k) * interpolationPoints.getEntry(k, i));</span>
                    }
                }
            }
<span class="fc bfc" id="L2261" title="All 2 branches covered.">            if (crvmin != ZERO) {</span>
<span class="fc" id="L2262">                state = 50; break;</span>
            }
<span class="fc bfc" id="L2264" title="All 2 branches covered.">            if (iterc &gt; itcsav) {</span>
<span class="fc" id="L2265">                state = 150; break;</span>
            }
<span class="fc bfc" id="L2267" title="All 2 branches covered.">            for (int i = 0; i &lt; n; i++) {</span>
<span class="fc" id="L2268">                hred.setEntry(i, hs.getEntry(i));</span>
            }
<span class="fc" id="L2270">            state = 120; break;</span>
        }
        default: {
<span class="nc" id="L2273">            throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, &quot;trsbox&quot;);</span>
        }}
        }
    } // trsbox

    // ----------------------------------------------------------------------------------------

    /**
     *     The arrays BMAT and ZMAT are updated, as required by the new position
     *     of the interpolation point that has the index KNEW. The vector VLAG has
     *     N+NPT components, set on entry to the first NPT and last N components
     *     of the product Hw in equation (4.11) of the Powell (2006) paper on
     *     NEWUOA. Further, BETA is set on entry to the value of the parameter
     *     with that name, and DENOM is set to the denominator of the updating
     *     formula. Elements of ZMAT may be treated as zero if their moduli are
     *     at most ZTEST. The first NDIM elements of W are used for working space.
     * @param beta
     * @param denom
     * @param knew
     */
    private void update(
            double beta,
            double denom,
            int knew
    ) {
<span class="fc" id="L2298">        printMethod(); // XXX</span>

<span class="fc" id="L2300">        final int n = currentBest.getDimension();</span>
<span class="fc" id="L2301">        final int npt = numberOfInterpolationPoints;</span>
<span class="fc" id="L2302">        final int nptm = npt - n - 1;</span>

        // XXX Should probably be split into two arrays.
<span class="fc" id="L2305">        final ArrayRealVector work = new ArrayRealVector(npt + n);</span>

<span class="fc" id="L2307">        double ztest = ZERO;</span>
<span class="fc bfc" id="L2308" title="All 2 branches covered.">        for (int k = 0; k &lt; npt; k++) {</span>
<span class="fc bfc" id="L2309" title="All 2 branches covered.">            for (int j = 0; j &lt; nptm; j++) {</span>
                // Computing MAX
<span class="fc" id="L2311">                ztest = Math.max(ztest, Math.abs(zMatrix.getEntry(k, j)));</span>
            }
        }
<span class="fc" id="L2314">        ztest *= 1e-20;</span>

        // Apply the rotations that put zeros in the KNEW-th row of ZMAT.

<span class="fc bfc" id="L2318" title="All 2 branches covered.">        for (int j = 1; j &lt; nptm; j++) {</span>
<span class="fc" id="L2319">            final double d1 = zMatrix.getEntry(knew, j);</span>
<span class="fc bfc" id="L2320" title="All 2 branches covered.">            if (Math.abs(d1) &gt; ztest) {</span>
                // Computing 2nd power
<span class="fc" id="L2322">                final double d2 = zMatrix.getEntry(knew, 0);</span>
                // Computing 2nd power
<span class="fc" id="L2324">                final double d3 = zMatrix.getEntry(knew, j);</span>
<span class="fc" id="L2325">                final double d4 = Math.sqrt(d2 * d2 + d3 * d3);</span>
<span class="fc" id="L2326">                final double d5 = zMatrix.getEntry(knew, 0) / d4;</span>
<span class="fc" id="L2327">                final double d6 = zMatrix.getEntry(knew, j) / d4;</span>
<span class="fc bfc" id="L2328" title="All 2 branches covered.">                for (int i = 0; i &lt; npt; i++) {</span>
<span class="fc" id="L2329">                    final double d7 = d5 * zMatrix.getEntry(i, 0) + d6 * zMatrix.getEntry(i, j);</span>
<span class="fc" id="L2330">                    zMatrix.setEntry(i, j, d5 * zMatrix.getEntry(i, j) - d6 * zMatrix.getEntry(i, 0));</span>
<span class="fc" id="L2331">                    zMatrix.setEntry(i, 0, d7);</span>
                }
            }
<span class="fc" id="L2334">            zMatrix.setEntry(knew, j, ZERO);</span>
        }

        // Put the first NPT components of the KNEW-th column of HLAG into W,
        // and calculate the parameters of the updating formula.

<span class="fc bfc" id="L2340" title="All 2 branches covered.">        for (int i = 0; i &lt; npt; i++) {</span>
<span class="fc" id="L2341">            work.setEntry(i, zMatrix.getEntry(knew, 0) * zMatrix.getEntry(i, 0));</span>
        }
<span class="fc" id="L2343">        final double alpha = work.getEntry(knew);</span>
<span class="fc" id="L2344">        final double tau = lagrangeValuesAtNewPoint.getEntry(knew);</span>
<span class="fc" id="L2345">        lagrangeValuesAtNewPoint.setEntry(knew, lagrangeValuesAtNewPoint.getEntry(knew) - ONE);</span>

        // Complete the updating of ZMAT.

<span class="fc" id="L2349">        final double sqrtDenom = Math.sqrt(denom);</span>
<span class="fc" id="L2350">        final double d1 = tau / sqrtDenom;</span>
<span class="fc" id="L2351">        final double d2 = zMatrix.getEntry(knew, 0) / sqrtDenom;</span>
<span class="fc bfc" id="L2352" title="All 2 branches covered.">        for (int i = 0; i &lt; npt; i++) {</span>
<span class="fc" id="L2353">            zMatrix.setEntry(i, 0,</span>
<span class="fc" id="L2354">                          d1 * zMatrix.getEntry(i, 0) - d2 * lagrangeValuesAtNewPoint.getEntry(i));</span>
        }

        // Finally, update the matrix BMAT.

<span class="fc bfc" id="L2359" title="All 2 branches covered.">        for (int j = 0; j &lt; n; j++) {</span>
<span class="fc" id="L2360">            final int jp = npt + j;</span>
<span class="fc" id="L2361">            work.setEntry(jp, bMatrix.getEntry(knew, j));</span>
<span class="fc" id="L2362">            final double d3 = (alpha * lagrangeValuesAtNewPoint.getEntry(jp) - tau * work.getEntry(jp)) / denom;</span>
<span class="fc" id="L2363">            final double d4 = (-beta * work.getEntry(jp) - tau * lagrangeValuesAtNewPoint.getEntry(jp)) / denom;</span>
<span class="fc bfc" id="L2364" title="All 2 branches covered.">            for (int i = 0; i &lt;= jp; i++) {</span>
<span class="fc" id="L2365">                bMatrix.setEntry(i, j,</span>
<span class="fc" id="L2366">                              bMatrix.getEntry(i, j) + d3 * lagrangeValuesAtNewPoint.getEntry(i) + d4 * work.getEntry(i));</span>
<span class="fc bfc" id="L2367" title="All 2 branches covered.">                if (i &gt;= npt) {</span>
<span class="fc" id="L2368">                    bMatrix.setEntry(jp, (i - npt), bMatrix.getEntry(i, j));</span>
                }
            }
        }
<span class="fc" id="L2372">    } // update</span>

    /**
     * Performs validity checks.
     *
     * @param lowerBound Lower bounds (constraints) of the objective variables.
     * @param upperBound Upperer bounds (constraints) of the objective variables.
     */
    private void setup(double[] lowerBound,
                       double[] upperBound) {
<span class="fc" id="L2382">        printMethod(); // XXX</span>

<span class="fc" id="L2384">        double[] init = getStartPoint();</span>
<span class="fc" id="L2385">        final int dimension = init.length;</span>

        // Check problem dimension.
<span class="fc bfc" id="L2388" title="All 2 branches covered.">        if (dimension &lt; MINIMUM_PROBLEM_DIMENSION) {</span>
<span class="fc" id="L2389">            throw new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);</span>
        }
        // Check number of interpolation points.
<span class="fc" id="L2392">        final int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };</span>
<span class="pc bpc" id="L2393" title="2 of 4 branches missed.">        if (numberOfInterpolationPoints &lt; nPointsInterval[0] ||</span>
            numberOfInterpolationPoints &gt; nPointsInterval[1]) {
<span class="nc" id="L2395">            throw new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,</span>
<span class="nc" id="L2396">                                          numberOfInterpolationPoints,</span>
<span class="nc" id="L2397">                                          nPointsInterval[0],</span>
<span class="nc" id="L2398">                                          nPointsInterval[1]);</span>
        }

        // Initialize bound differences.
<span class="fc" id="L2402">        boundDifference = new double[dimension];</span>

<span class="fc" id="L2404">        double requiredMinDiff = 2 * initialTrustRegionRadius;</span>
<span class="fc" id="L2405">        double minDiff = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L2406" title="All 2 branches covered.">        for (int i = 0; i &lt; dimension; i++) {</span>
<span class="fc" id="L2407">            boundDifference[i] = upperBound[i] - lowerBound[i];</span>
<span class="fc" id="L2408">            minDiff = Math.min(minDiff, boundDifference[i]);</span>
        }
<span class="fc bfc" id="L2410" title="All 2 branches covered.">        if (minDiff &lt; requiredMinDiff) {</span>
<span class="fc" id="L2411">            initialTrustRegionRadius = minDiff / 3.0;</span>
        }

        // Initialize the data structures used by the &quot;bobyqa&quot; method.
<span class="fc" id="L2415">        bMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,</span>
                                           dimension);
<span class="fc" id="L2417">        zMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,</span>
                                           numberOfInterpolationPoints - dimension - 1);
<span class="fc" id="L2419">        interpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,</span>
                                                       dimension);
<span class="fc" id="L2421">        originShift = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2422">        fAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);</span>
<span class="fc" id="L2423">        trustRegionCenterOffset = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2424">        gradientAtTrustRegionCenter = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2425">        lowerDifference = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2426">        upperDifference = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2427">        modelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);</span>
<span class="fc" id="L2428">        newPoint = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2429">        alternativeNewPoint = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2430">        trialStepPoint = new ArrayRealVector(dimension);</span>
<span class="fc" id="L2431">        lagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);</span>
<span class="fc" id="L2432">        modelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);</span>
<span class="fc" id="L2433">    }</span>

    /**
     * Creates a new array.
     *
     * @param n Dimension of the returned array.
     * @param value Value for each element.
     * @return an array containing {@code n} elements set to the given
     * {@code value}.
     */
    private static double[] fillNewArray(int n,
                                         double value) {
<span class="nc" id="L2445">        double[] ds = new double[n];</span>
<span class="nc" id="L2446">        Arrays.fill(ds, value);</span>
<span class="nc" id="L2447">        return ds;</span>
    }

    // XXX utility for figuring out call sequence.
    private static String caller(int n) {
<span class="nc" id="L2452">        final Throwable t = new Throwable();</span>
<span class="nc" id="L2453">        final StackTraceElement[] elements = t.getStackTrace();</span>
<span class="nc" id="L2454">        final StackTraceElement e = elements[n];</span>
<span class="nc" id="L2455">        return e.getMethodName() + &quot; (at line &quot; + e.getLineNumber() + &quot;)&quot;;</span>
    }
    // XXX utility for figuring out call sequence.
    private static void printState(int s) {
        //        System.out.println(caller(2) + &quot;: state &quot; + s);
<span class="fc" id="L2460">    }</span>
    // XXX utility for figuring out call sequence.
    private static void printMethod() {
        //        System.out.println(caller(2));
<span class="fc" id="L2464">    }</span>
}

/**
 * Marker for code paths that are not explored with the current unit tests.
 * If the path becomes explored, it should just be removed from the code.
 */
class PathIsExploredException extends RuntimeException {
    private static final long serialVersionUID = 745350979634801853L;

    private static final String PATH_IS_EXPLORED
        = &quot;If this exception is thrown, just remove it from the code&quot;;

    PathIsExploredException() {
<span class="nc" id="L2478">        super(PATH_IS_EXPLORED);</span>
<span class="nc" id="L2479">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>