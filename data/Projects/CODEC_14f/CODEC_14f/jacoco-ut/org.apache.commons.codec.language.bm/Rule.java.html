<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Rule.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Codec</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.codec.language.bm</a> &gt; <span class="el_source">Rule.java</span></div><h1>Rule.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.codec.language.bm;

import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.EnumMap;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Scanner;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.codec.language.bm.Languages.LanguageSet;

/**
 * A phoneme rule.
 * &lt;p&gt;
 * Rules have a pattern, left context, right context, output phoneme, set of languages for which they apply
 * and a logical flag indicating if all languages must be in play. A rule matches if:
 * &lt;ul&gt;
 * &lt;li&gt;the pattern matches at the current position&lt;/li&gt;
 * &lt;li&gt;the string up until the beginning of the pattern matches the left context&lt;/li&gt;
 * &lt;li&gt;the string from the end of the pattern matches the right context&lt;/li&gt;
 * &lt;li&gt;logical is ALL and all languages are in scope; or&lt;/li&gt;
 * &lt;li&gt;logical is any other value and at least one language is in scope&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * Rules are typically generated by parsing rules resources. In normal use, there will be no need for the user
 * to explicitly construct their own.
 * &lt;p&gt;
 * Rules are immutable and thread-safe.
 * &lt;p&gt;
 * &lt;b&gt;Rules resources&lt;/b&gt;
 * &lt;p&gt;
 * Rules are typically loaded from resource files. These are UTF-8 encoded text files. They are systematically
 * named following the pattern:
 * &lt;blockquote&gt;org/apache/commons/codec/language/bm/${NameType#getName}_${RuleType#getName}_${language}.txt&lt;/blockquote&gt;
 * &lt;p&gt;
 * The format of these resources is the following:
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;Rules:&lt;/b&gt; whitespace separated, double-quoted strings. There should be 4 columns to each row, and these
 * will be interpreted as:
 * &lt;ol&gt;
 * &lt;li&gt;pattern&lt;/li&gt;
 * &lt;li&gt;left context&lt;/li&gt;
 * &lt;li&gt;right context&lt;/li&gt;
 * &lt;li&gt;phoneme&lt;/li&gt;
 * &lt;/ol&gt;
 * &lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;End-of-line comments:&lt;/b&gt; Any occurrence of '//' will cause all text following on that line to be discarded
 * as a comment.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Multi-line comments:&lt;/b&gt; Any line starting with '/*' will start multi-line commenting mode. This will skip
 * all content until a line ending in '*' and '/' is found.&lt;/li&gt;
 * &lt;li&gt;&lt;b&gt;Blank lines:&lt;/b&gt; All blank lines will be skipped.&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * @since 1.6
 * @version $Id$
 */
public class Rule {

    public static final class Phoneme implements PhonemeExpr {
<span class="fc" id="L85">        public static final Comparator&lt;Phoneme&gt; COMPARATOR = new Comparator&lt;Phoneme&gt;() {</span>
            @Override
            public int compare(final Phoneme o1, final Phoneme o2) {
<span class="fc bfc" id="L88" title="All 2 branches covered.">                for (int i = 0; i &lt; o1.phonemeText.length(); i++) {</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">                    if (i &gt;= o2.phonemeText.length()) {</span>
<span class="fc" id="L90">                        return +1;</span>
                    }
<span class="fc" id="L92">                    final int c = o1.phonemeText.charAt(i) - o2.phonemeText.charAt(i);</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                    if (c != 0) {</span>
<span class="fc" id="L94">                        return c;</span>
                    }
                }

<span class="fc bfc" id="L98" title="All 2 branches covered.">                if (o1.phonemeText.length() &lt; o2.phonemeText.length()) {</span>
<span class="fc" id="L99">                    return -1;</span>
                }

<span class="fc" id="L102">                return 0;</span>
            }
        };

        private final StringBuilder phonemeText;
        private final Languages.LanguageSet languages;

<span class="fc" id="L109">        public Phoneme(final CharSequence phonemeText, final Languages.LanguageSet languages) {</span>
<span class="fc" id="L110">            this.phonemeText = new StringBuilder(phonemeText);</span>
<span class="fc" id="L111">            this.languages = languages;</span>
<span class="fc" id="L112">        }</span>

        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight) {
<span class="fc" id="L115">            this(phonemeLeft.phonemeText, phonemeLeft.languages);</span>
<span class="fc" id="L116">            this.phonemeText.append(phonemeRight.phonemeText);</span>
<span class="fc" id="L117">        }</span>

        public Phoneme(final Phoneme phonemeLeft, final Phoneme phonemeRight, final Languages.LanguageSet languages) {
<span class="fc" id="L120">            this(phonemeLeft.phonemeText, languages);</span>
<span class="fc" id="L121">            this.phonemeText.append(phonemeRight.phonemeText);</span>
<span class="fc" id="L122">        }</span>

        public Phoneme append(final CharSequence str) {
<span class="fc" id="L125">            this.phonemeText.append(str);</span>
<span class="fc" id="L126">            return this;</span>
        }

        public Languages.LanguageSet getLanguages() {
<span class="fc" id="L130">            return this.languages;</span>
        }

        @Override
        public Iterable&lt;Phoneme&gt; getPhonemes() {
<span class="fc" id="L135">            return Collections.singleton(this);</span>
        }

        public CharSequence getPhonemeText() {
<span class="fc" id="L139">            return this.phonemeText;</span>
        }

        /**
         * @deprecated since 1.9
         */
        @Deprecated
        public Phoneme join(final Phoneme right) {
<span class="nc" id="L147">            return new Phoneme(this.phonemeText.toString() + right.phonemeText.toString(),</span>
<span class="nc" id="L148">                               this.languages.restrictTo(right.languages));</span>
        }

        /**
         * Returns a new Phoneme with the same text but a union of its
         * current language set and the given one.
         *
         * @param lang the language set to merge
         * @return a new Phoneme
         */
        public Phoneme mergeWithLanguage(final LanguageSet lang) {
<span class="fc" id="L159">          return new Phoneme(this.phonemeText.toString(), this.languages.merge(lang));</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L164">          return phonemeText.toString() + &quot;[&quot; + languages + &quot;]&quot;;</span>
        }
    }

    public interface PhonemeExpr {
        Iterable&lt;Phoneme&gt; getPhonemes();
    }

    public static final class PhonemeList implements PhonemeExpr {
        private final List&lt;Phoneme&gt; phonemes;

<span class="fc" id="L175">        public PhonemeList(final List&lt;Phoneme&gt; phonemes) {</span>
<span class="fc" id="L176">            this.phonemes = phonemes;</span>
<span class="fc" id="L177">        }</span>

        @Override
        public List&lt;Phoneme&gt; getPhonemes() {
<span class="fc" id="L181">            return this.phonemes;</span>
        }
    }

    /**
     * A minimal wrapper around the functionality of Pattern that we use, to allow for alternate implementations.
     */
    public interface RPattern {
        boolean isMatch(CharSequence input);
    }

<span class="fc" id="L192">    public static final RPattern ALL_STRINGS_RMATCHER = new RPattern() {</span>
        @Override
        public boolean isMatch(final CharSequence input) {
<span class="fc" id="L195">            return true;</span>
        }
    };

    public static final String ALL = &quot;ALL&quot;;

    private static final String DOUBLE_QUOTE = &quot;\&quot;&quot;;

    private static final String HASH_INCLUDE = &quot;#include&quot;;

<span class="fc" id="L205">    private static final Map&lt;NameType, Map&lt;RuleType, Map&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt;&gt; RULES =</span>
            new EnumMap&lt;NameType, Map&lt;RuleType, Map&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt;&gt;(NameType.class);

    static {
<span class="fc bfc" id="L209" title="All 2 branches covered.">        for (final NameType s : NameType.values()) {</span>
<span class="fc" id="L210">            final Map&lt;RuleType, Map&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt; rts =</span>
                    new EnumMap&lt;RuleType, Map&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt;&gt;(RuleType.class);

<span class="fc bfc" id="L213" title="All 2 branches covered.">            for (final RuleType rt : RuleType.values()) {</span>
<span class="fc" id="L214">                final Map&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt; rs = new HashMap&lt;String, Map&lt;String, List&lt;Rule&gt;&gt;&gt;();</span>

<span class="fc" id="L216">                final Languages ls = Languages.getInstance(s);</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">                for (final String l : ls.getLanguages()) {</span>
                    try {
<span class="fc" id="L219">                        rs.put(l, parseRules(createScanner(s, rt, l), createResourceName(s, rt, l)));</span>
<span class="nc" id="L220">                    } catch (final IllegalStateException e) {</span>
<span class="nc" id="L221">                        throw new IllegalStateException(&quot;Problem processing &quot; + createResourceName(s, rt, l), e);</span>
<span class="fc" id="L222">                    }</span>
<span class="fc" id="L223">                }</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">                if (!rt.equals(RuleType.RULES)) {</span>
<span class="fc" id="L225">                    rs.put(&quot;common&quot;, parseRules(createScanner(s, rt, &quot;common&quot;), createResourceName(s, rt, &quot;common&quot;)));</span>
                }

<span class="fc" id="L228">                rts.put(rt, Collections.unmodifiableMap(rs));</span>
            }

<span class="fc" id="L231">            RULES.put(s, Collections.unmodifiableMap(rts));</span>
        }
<span class="fc" id="L233">    }</span>

    private static boolean contains(final CharSequence chars, final char input) {
<span class="fc bfc" id="L236" title="All 2 branches covered.">        for (int i = 0; i &lt; chars.length(); i++) {</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">            if (chars.charAt(i) == input) {</span>
<span class="fc" id="L238">                return true;</span>
            }
        }
<span class="fc" id="L241">        return false;</span>
    }

    private static String createResourceName(final NameType nameType, final RuleType rt, final String lang) {
<span class="fc" id="L245">        return String.format(&quot;org/apache/commons/codec/language/bm/%s_%s_%s.txt&quot;,</span>
<span class="fc" id="L246">                             nameType.getName(), rt.getName(), lang);</span>
    }

    private static Scanner createScanner(final NameType nameType, final RuleType rt, final String lang) {
<span class="fc" id="L250">        final String resName = createResourceName(nameType, rt, lang);</span>
<span class="fc" id="L251">        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);</span>

<span class="pc bpc" id="L253" title="1 of 2 branches missed.">        if (rulesIS == null) {</span>
<span class="nc" id="L254">            throw new IllegalArgumentException(&quot;Unable to load resource: &quot; + resName);</span>
        }

<span class="fc" id="L257">        return new Scanner(rulesIS, ResourceConstants.ENCODING);</span>
    }

    private static Scanner createScanner(final String lang) {
<span class="fc" id="L261">        final String resName = String.format(&quot;org/apache/commons/codec/language/bm/%s.txt&quot;, lang);</span>
<span class="fc" id="L262">        final InputStream rulesIS = Languages.class.getClassLoader().getResourceAsStream(resName);</span>

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">        if (rulesIS == null) {</span>
<span class="nc" id="L265">            throw new IllegalArgumentException(&quot;Unable to load resource: &quot; + resName);</span>
        }

<span class="fc" id="L268">        return new Scanner(rulesIS, ResourceConstants.ENCODING);</span>
    }

    private static boolean endsWith(final CharSequence input, final CharSequence suffix) {
<span class="fc bfc" id="L272" title="All 2 branches covered.">        if (suffix.length() &gt; input.length()) {</span>
<span class="fc" id="L273">            return false;</span>
        }
<span class="fc bfc" id="L275" title="All 2 branches covered.">        for (int i = input.length() - 1, j = suffix.length() - 1; j &gt;= 0; i--, j--) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            if (input.charAt(i) != suffix.charAt(j)) {</span>
<span class="fc" id="L277">                return false;</span>
            }
        }
<span class="fc" id="L280">        return true;</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a list of Rules that apply
     */
    public static List&lt;Rule&gt; getInstance(final NameType nameType, final RuleType rt,
                                         final Languages.LanguageSet langs) {
<span class="nc" id="L296">        final Map&lt;String, List&lt;Rule&gt;&gt; ruleMap = getInstanceMap(nameType, rt, langs);</span>
<span class="nc" id="L297">        final List&lt;Rule&gt; allRules = new ArrayList&lt;Rule&gt;();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (final List&lt;Rule&gt; rules : ruleMap.values()) {</span>
<span class="nc" id="L299">            allRules.addAll(rules);</span>
<span class="nc" id="L300">        }</span>
<span class="nc" id="L301">        return allRules;</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a list of Rules that apply
     */
    public static List&lt;Rule&gt; getInstance(final NameType nameType, final RuleType rt, final String lang) {
<span class="nc" id="L316">        return getInstance(nameType, rt, LanguageSet.from(new HashSet&lt;String&gt;(Arrays.asList(lang))));</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and languages.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param langs
     *            the set of languages to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9
     */
    public static Map&lt;String, List&lt;Rule&gt;&gt; getInstanceMap(final NameType nameType, final RuleType rt,
                                                         final Languages.LanguageSet langs) {
<span class="fc bfc" id="L333" title="All 2 branches covered.">        return langs.isSingleton() ? getInstanceMap(nameType, rt, langs.getAny()) :</span>
<span class="fc" id="L334">                                     getInstanceMap(nameType, rt, Languages.ANY);</span>
    }

    /**
     * Gets rules for a combination of name type, rule type and a single language.
     *
     * @param nameType
     *            the NameType to consider
     * @param rt
     *            the RuleType to consider
     * @param lang
     *            the language to consider
     * @return a map containing all Rules that apply, grouped by the first character of the rule pattern
     * @since 1.9
     */
    public static Map&lt;String, List&lt;Rule&gt;&gt; getInstanceMap(final NameType nameType, final RuleType rt,
                                                         final String lang) {
<span class="fc" id="L351">        final Map&lt;String, List&lt;Rule&gt;&gt; rules = RULES.get(nameType).get(rt).get(lang);</span>

<span class="fc bfc" id="L353" title="All 2 branches covered.">        if (rules == null) {</span>
<span class="fc" id="L354">            throw new IllegalArgumentException(String.format(&quot;No rules found for %s, %s, %s.&quot;,</span>
<span class="fc" id="L355">                                               nameType.getName(), rt.getName(), lang));</span>
        }

<span class="fc" id="L358">        return rules;</span>
    }

    private static Phoneme parsePhoneme(final String ph) {
<span class="fc" id="L362">        final int open = ph.indexOf(&quot;[&quot;);</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        if (open &gt;= 0) {</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            if (!ph.endsWith(&quot;]&quot;)) {</span>
<span class="nc" id="L365">                throw new IllegalArgumentException(&quot;Phoneme expression contains a '[' but does not end in ']'&quot;);</span>
            }
<span class="fc" id="L367">            final String before = ph.substring(0, open);</span>
<span class="fc" id="L368">            final String in = ph.substring(open + 1, ph.length() - 1);</span>
<span class="fc" id="L369">            final Set&lt;String&gt; langs = new HashSet&lt;String&gt;(Arrays.asList(in.split(&quot;[+]&quot;)));</span>

<span class="fc" id="L371">            return new Phoneme(before, Languages.LanguageSet.from(langs));</span>
        } else {
<span class="fc" id="L373">            return new Phoneme(ph, Languages.ANY_LANGUAGE);</span>
        }
    }

    private static PhonemeExpr parsePhonemeExpr(final String ph) {
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (ph.startsWith(&quot;(&quot;)) { // we have a bracketed list of options</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">            if (!ph.endsWith(&quot;)&quot;)) {</span>
<span class="nc" id="L380">                throw new IllegalArgumentException(&quot;Phoneme starts with '(' so must end with ')'&quot;);</span>
            }

<span class="fc" id="L383">            final List&lt;Phoneme&gt; phs = new ArrayList&lt;Phoneme&gt;();</span>
<span class="fc" id="L384">            final String body = ph.substring(1, ph.length() - 1);</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">            for (final String part : body.split(&quot;[|]&quot;)) {</span>
<span class="fc" id="L386">                phs.add(parsePhoneme(part));</span>
            }
<span class="fc bfc" id="L388" title="All 4 branches covered.">            if (body.startsWith(&quot;|&quot;) || body.endsWith(&quot;|&quot;)) {</span>
<span class="fc" id="L389">                phs.add(new Phoneme(&quot;&quot;, Languages.ANY_LANGUAGE));</span>
            }

<span class="fc" id="L392">            return new PhonemeList(phs);</span>
        } else {
<span class="fc" id="L394">            return parsePhoneme(ph);</span>
        }
    }

    private static Map&lt;String, List&lt;Rule&gt;&gt; parseRules(final Scanner scanner, final String location) {
<span class="fc" id="L399">        final Map&lt;String, List&lt;Rule&gt;&gt; lines = new HashMap&lt;String, List&lt;Rule&gt;&gt;();</span>
<span class="fc" id="L400">        int currentLine = 0;</span>

<span class="fc" id="L402">        boolean inMultilineComment = false;</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">        while (scanner.hasNextLine()) {</span>
<span class="fc" id="L404">            currentLine++;</span>
<span class="fc" id="L405">            final String rawLine = scanner.nextLine();</span>
<span class="fc" id="L406">            String line = rawLine;</span>

<span class="fc bfc" id="L408" title="All 2 branches covered.">            if (inMultilineComment) {</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">                if (line.endsWith(ResourceConstants.EXT_CMT_END)) {</span>
<span class="fc" id="L410">                    inMultilineComment = false;</span>
                }
            } else {
<span class="fc bfc" id="L413" title="All 2 branches covered.">                if (line.startsWith(ResourceConstants.EXT_CMT_START)) {</span>
<span class="fc" id="L414">                    inMultilineComment = true;</span>
                } else {
                    // discard comments
<span class="fc" id="L417">                    final int cmtI = line.indexOf(ResourceConstants.CMT);</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">                    if (cmtI &gt;= 0) {</span>
<span class="fc" id="L419">                        line = line.substring(0, cmtI);</span>
                    }

                    // trim leading-trailing whitespace
<span class="fc" id="L423">                    line = line.trim();</span>

<span class="fc bfc" id="L425" title="All 2 branches covered.">                    if (line.length() == 0) {</span>
<span class="fc" id="L426">                        continue; // empty lines can be safely skipped</span>
                    }

<span class="fc bfc" id="L429" title="All 2 branches covered.">                    if (line.startsWith(HASH_INCLUDE)) {</span>
                        // include statement
<span class="fc" id="L431">                        final String incl = line.substring(HASH_INCLUDE.length()).trim();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">                        if (incl.contains(&quot; &quot;)) {</span>
<span class="nc" id="L433">                            throw new IllegalArgumentException(&quot;Malformed import statement '&quot; + rawLine + &quot;' in &quot; +</span>
                                                               location);
                        } else {
<span class="fc" id="L436">                            lines.putAll(parseRules(createScanner(incl), location + &quot;-&gt;&quot; + incl));</span>
                        }
<span class="fc" id="L438">                    } else {</span>
                        // rule
<span class="fc" id="L440">                        final String[] parts = line.split(&quot;\\s+&quot;);</span>
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">                        if (parts.length != 4) {</span>
<span class="nc" id="L442">                            throw new IllegalArgumentException(&quot;Malformed rule statement split into &quot; + parts.length +</span>
                                                               &quot; parts: &quot; + rawLine + &quot; in &quot; + location);
                        } else {
                            try {
<span class="fc" id="L446">                                final String pat = stripQuotes(parts[0]);</span>
<span class="fc" id="L447">                                final String lCon = stripQuotes(parts[1]);</span>
<span class="fc" id="L448">                                final String rCon = stripQuotes(parts[2]);</span>
<span class="fc" id="L449">                                final PhonemeExpr ph = parsePhonemeExpr(stripQuotes(parts[3]));</span>
<span class="fc" id="L450">                                final int cLine = currentLine;</span>
<span class="fc" id="L451">                                final Rule r = new Rule(pat, lCon, rCon, ph) {</span>
<span class="fc" id="L452">                                    private final int myLine = cLine;</span>
<span class="fc" id="L453">                                    private final String loc = location;</span>

                                    @Override
                                    public String toString() {
<span class="nc" id="L457">                                        final StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L458">                                        sb.append(&quot;Rule&quot;);</span>
<span class="nc" id="L459">                                        sb.append(&quot;{line=&quot;).append(myLine);</span>
<span class="nc" id="L460">                                        sb.append(&quot;, loc='&quot;).append(loc).append('\'');</span>
<span class="nc" id="L461">                                        sb.append(&quot;, pat='&quot;).append(pat).append('\'');</span>
<span class="nc" id="L462">                                        sb.append(&quot;, lcon='&quot;).append(lCon).append('\'');</span>
<span class="nc" id="L463">                                        sb.append(&quot;, rcon='&quot;).append(rCon).append('\'');</span>
<span class="nc" id="L464">                                        sb.append('}');</span>
<span class="nc" id="L465">                                        return sb.toString();</span>
                                    }
                                };
<span class="fc" id="L468">                                final String patternKey = r.pattern.substring(0,1);</span>
<span class="fc" id="L469">                                List&lt;Rule&gt; rules = lines.get(patternKey);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">                                if (rules == null) {</span>
<span class="fc" id="L471">                                    rules = new ArrayList&lt;Rule&gt;();</span>
<span class="fc" id="L472">                                    lines.put(patternKey, rules);</span>
                                }
<span class="fc" id="L474">                                rules.add(r);</span>
<span class="nc" id="L475">                            } catch (final IllegalArgumentException e) {</span>
<span class="nc" id="L476">                                throw new IllegalStateException(&quot;Problem parsing line '&quot; + currentLine + &quot;' in &quot; +</span>
                                                                location, e);
<span class="fc" id="L478">                            }</span>
                        }
                    }
                }
            }
<span class="fc" id="L483">        }</span>

<span class="fc" id="L485">        return lines;</span>
    }

    /**
     * Attempts to compile the regex into direct string ops, falling back to Pattern and Matcher in the worst case.
     *
     * @param regex
     *            the regular expression to compile
     * @return an RPattern that will match this regex
     */
    private static RPattern pattern(final String regex) {
<span class="fc" id="L496">        final boolean startsWith = regex.startsWith(&quot;^&quot;);</span>
<span class="fc" id="L497">        final boolean endsWith = regex.endsWith(&quot;$&quot;);</span>
<span class="fc bfc" id="L498" title="All 4 branches covered.">        final String content = regex.substring(startsWith ? 1 : 0, endsWith ? regex.length() - 1 : regex.length());</span>
<span class="fc" id="L499">        final boolean boxes = content.contains(&quot;[&quot;);</span>

<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (!boxes) {</span>
<span class="fc bfc" id="L502" title="All 4 branches covered.">            if (startsWith &amp;&amp; endsWith) {</span>
                // exact match
<span class="fc bfc" id="L504" title="All 2 branches covered.">                if (content.length() == 0) {</span>
                    // empty
<span class="fc" id="L506">                    return new RPattern() {</span>
                        @Override
                        public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L509" title="All 2 branches covered.">                            return input.length() == 0;</span>
                        }
                    };
                } else {
<span class="fc" id="L513">                    return new RPattern() {</span>
                        @Override
                        public boolean isMatch(final CharSequence input) {
<span class="fc" id="L516">                            return input.equals(content);</span>
                        }
                    };
                }
<span class="pc bpc" id="L520" title="1 of 6 branches missed.">            } else if ((startsWith || endsWith) &amp;&amp; content.length() == 0) {</span>
                // matches every string
<span class="fc" id="L522">                return ALL_STRINGS_RMATCHER;</span>
<span class="fc bfc" id="L523" title="All 2 branches covered.">            } else if (startsWith) {</span>
                // matches from start
<span class="fc" id="L525">                return new RPattern() {</span>
                    @Override
                    public boolean isMatch(final CharSequence input) {
<span class="fc" id="L528">                        return startsWith(input, content);</span>
                    }
                };
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">            } else if (endsWith) {</span>
                // matches from start
<span class="fc" id="L533">                return new RPattern() {</span>
                    @Override
                    public boolean isMatch(final CharSequence input) {
<span class="fc" id="L536">                        return endsWith(input, content);</span>
                    }
                };
            }
        } else {
<span class="fc" id="L541">            final boolean startsWithBox = content.startsWith(&quot;[&quot;);</span>
<span class="fc" id="L542">            final boolean endsWithBox = content.endsWith(&quot;]&quot;);</span>

<span class="fc bfc" id="L544" title="All 4 branches covered.">            if (startsWithBox &amp;&amp; endsWithBox) {</span>
<span class="fc" id="L545">                String boxContent = content.substring(1, content.length() - 1);</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">                if (!boxContent.contains(&quot;[&quot;)) {</span>
                    // box containing alternatives
<span class="fc" id="L548">                    final boolean negate = boxContent.startsWith(&quot;^&quot;);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">                    if (negate) {</span>
<span class="fc" id="L550">                        boxContent = boxContent.substring(1);</span>
                    }
<span class="fc" id="L552">                    final String bContent = boxContent;</span>
<span class="fc bfc" id="L553" title="All 2 branches covered.">                    final boolean shouldMatch = !negate;</span>

<span class="fc bfc" id="L555" title="All 4 branches covered.">                    if (startsWith &amp;&amp; endsWith) {</span>
                        // exact match
<span class="fc" id="L557">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L560" title="All 4 branches covered.">                                return input.length() == 1 &amp;&amp; contains(bContent, input.charAt(0)) == shouldMatch;</span>
                            }
                        };
<span class="fc bfc" id="L563" title="All 2 branches covered.">                    } else if (startsWith) {</span>
                        // first char
<span class="fc" id="L565">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L568" title="All 4 branches covered.">                                return input.length() &gt; 0 &amp;&amp; contains(bContent, input.charAt(0)) == shouldMatch;</span>
                            }
                        };
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">                    } else if (endsWith) {</span>
                        // last char
<span class="fc" id="L573">                        return new RPattern() {</span>
                            @Override
                            public boolean isMatch(final CharSequence input) {
<span class="fc bfc" id="L576" title="All 2 branches covered.">                                return input.length() &gt; 0 &amp;&amp;</span>
<span class="fc bfc" id="L577" title="All 2 branches covered.">                                       contains(bContent, input.charAt(input.length() - 1)) == shouldMatch;</span>
                            }
                        };
                    }
                }
            }
        }

<span class="fc" id="L585">        return new RPattern() {</span>
<span class="fc" id="L586">            Pattern pattern = Pattern.compile(regex);</span>

            @Override
            public boolean isMatch(final CharSequence input) {
<span class="fc" id="L590">                final Matcher matcher = pattern.matcher(input);</span>
<span class="fc" id="L591">                return matcher.find();</span>
            }
        };
    }

    private static boolean startsWith(final CharSequence input, final CharSequence prefix) {
<span class="fc bfc" id="L597" title="All 2 branches covered.">        if (prefix.length() &gt; input.length()) {</span>
<span class="fc" id="L598">            return false;</span>
        }
<span class="fc bfc" id="L600" title="All 2 branches covered.">        for (int i = 0; i &lt; prefix.length(); i++) {</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">            if (input.charAt(i) != prefix.charAt(i)) {</span>
<span class="fc" id="L602">                return false;</span>
            }
        }
<span class="fc" id="L605">        return true;</span>
    }

    private static String stripQuotes(String str) {
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">        if (str.startsWith(DOUBLE_QUOTE)) {</span>
<span class="fc" id="L610">            str = str.substring(1);</span>
        }

<span class="pc bpc" id="L613" title="1 of 2 branches missed.">        if (str.endsWith(DOUBLE_QUOTE)) {</span>
<span class="fc" id="L614">            str = str.substring(0, str.length() - 1);</span>
        }

<span class="fc" id="L617">        return str;</span>
    }

    private final RPattern lContext;

    private final String pattern;

    private final PhonemeExpr phoneme;

    private final RPattern rContext;

    /**
     * Creates a new rule.
     *
     * @param pattern
     *            the pattern
     * @param lContext
     *            the left context
     * @param rContext
     *            the right context
     * @param phoneme
     *            the resulting phoneme
     */
<span class="fc" id="L640">    public Rule(final String pattern, final String lContext, final String rContext, final PhonemeExpr phoneme) {</span>
<span class="fc" id="L641">        this.pattern = pattern;</span>
<span class="fc" id="L642">        this.lContext = pattern(lContext + &quot;$&quot;);</span>
<span class="fc" id="L643">        this.rContext = pattern(&quot;^&quot; + rContext);</span>
<span class="fc" id="L644">        this.phoneme = phoneme;</span>
<span class="fc" id="L645">    }</span>

    /**
     * Gets the left context. This is a regular expression that must match to the left of the pattern.
     *
     * @return the left context Pattern
     */
    public RPattern getLContext() {
<span class="nc" id="L653">        return this.lContext;</span>
    }

    /**
     * Gets the pattern. This is a string-literal that must exactly match.
     *
     * @return the pattern
     */
    public String getPattern() {
<span class="fc" id="L662">        return this.pattern;</span>
    }

    /**
     * Gets the phoneme. If the rule matches, this is the phoneme associated with the pattern match.
     *
     * @return the phoneme
     */
    public PhonemeExpr getPhoneme() {
<span class="fc" id="L671">        return this.phoneme;</span>
    }

    /**
     * Gets the right context. This is a regular expression that must match to the right of the pattern.
     *
     * @return the right context Pattern
     */
    public RPattern getRContext() {
<span class="nc" id="L680">        return this.rContext;</span>
    }

    /**
     * Decides if the pattern and context match the input starting at a position. It is a match if the
     * &lt;code&gt;lContext&lt;/code&gt; matches &lt;code&gt;input&lt;/code&gt; up to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;pattern&lt;/code&gt; matches at i and
     * &lt;code&gt;rContext&lt;/code&gt; matches from the end of the match of &lt;code&gt;pattern&lt;/code&gt; to the end of &lt;code&gt;input&lt;/code&gt;.
     *
     * @param input
     *            the input String
     * @param i
     *            the int position within the input
     * @return true if the pattern and left/right context match, false otherwise
     */
    public boolean patternAndContextMatches(final CharSequence input, final int i) {
<span class="fc bfc" id="L695" title="All 2 branches covered.">        if (i &lt; 0) {</span>
<span class="fc" id="L696">            throw new IndexOutOfBoundsException(&quot;Can not match pattern at negative indexes&quot;);</span>
        }

<span class="fc" id="L699">        final int patternLength = this.pattern.length();</span>
<span class="fc" id="L700">        final int ipl = i + patternLength;</span>

<span class="fc bfc" id="L702" title="All 2 branches covered.">        if (ipl &gt; input.length()) {</span>
            // not enough room for the pattern to match
<span class="fc" id="L704">            return false;</span>
        }

        // evaluate the pattern, left context and right context
        // fail early if any of the evaluations is not successful
<span class="fc bfc" id="L709" title="All 2 branches covered.">        if (!input.subSequence(i, ipl).equals(this.pattern)) {</span>
<span class="fc" id="L710">            return false;</span>
<span class="fc bfc" id="L711" title="All 2 branches covered.">        } else if (!this.rContext.isMatch(input.subSequence(ipl, input.length()))) {</span>
<span class="fc" id="L712">            return false;</span>
        }
<span class="fc" id="L714">        return this.lContext.isMatch(input.subSequence(0, i));</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>