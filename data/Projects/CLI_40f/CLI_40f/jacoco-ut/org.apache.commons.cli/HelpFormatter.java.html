<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HelpFormatter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons CLI</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.cli</a> &gt; <span class="el_source">HelpFormatter.java</span></div><h1>HelpFormatter.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.apache.commons.cli;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

/**
 * A formatter of help messages for command line options.
 *
 * &lt;p&gt;Example:&lt;/p&gt;
 * 
 * &lt;pre&gt;
 * Options options = new Options();
 * options.addOption(OptionBuilder.withLongOpt(&quot;file&quot;)
 *                                .withDescription(&quot;The file to be processed&quot;)
 *                                .hasArg()
 *                                .withArgName(&quot;FILE&quot;)
 *                                .isRequired()
 *                                .create('f'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;version&quot;)
 *                                .withDescription(&quot;Print the version of the application&quot;)
 *                                .create('v'));
 * options.addOption(OptionBuilder.withLongOpt(&quot;help&quot;).create('h'));
 * 
 * String header = &quot;Do something useful with an input file\n\n&quot;;
 * String footer = &quot;\nPlease report issues at http://example.com/issues&quot;;
 * 
 * HelpFormatter formatter = new HelpFormatter();
 * formatter.printHelp(&quot;myapp&quot;, header, options, footer, true);
 * &lt;/pre&gt;
 * 
 * This produces the following output:
 * 
 * &lt;pre&gt;
 * usage: myapp -f &amp;lt;FILE&amp;gt; [-h] [-v]
 * Do something useful with an input file
 * 
 *  -f,--file &amp;lt;FILE&amp;gt;   The file to be processed
 *  -h,--help
 *  -v,--version       Print the version of the application
 * 
 * Please report issues at http://example.com/issues
 * &lt;/pre&gt;
 */
<span class="fc" id="L71">public class HelpFormatter</span>
{
    // --------------------------------------------------------------- Constants

    /** default number of characters per line */
    public static final int DEFAULT_WIDTH = 74;

    /** default padding to the left of each line */
    public static final int DEFAULT_LEFT_PAD = 1;

    /** number of space characters to be prefixed to each description line */
    public static final int DEFAULT_DESC_PAD = 3;

    /** the string to display at the beginning of the usage statement */
    public static final String DEFAULT_SYNTAX_PREFIX = &quot;usage: &quot;;

    /** default prefix for shortOpts */
    public static final String DEFAULT_OPT_PREFIX = &quot;-&quot;;

    /** default prefix for long Option */
    public static final String DEFAULT_LONG_OPT_PREFIX = &quot;--&quot;;

    /** 
     * default separator displayed between a long Option and its value
     * 
     * @since 1.3
     **/
    public static final String DEFAULT_LONG_OPT_SEPARATOR = &quot; &quot;;

    /** default name for an argument */
    public static final String DEFAULT_ARG_NAME = &quot;arg&quot;;

    // -------------------------------------------------------------- Attributes

    /**
     * number of characters per line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setWidth methods instead.
     */
<span class="fc" id="L111">    @Deprecated</span>
    public int defaultWidth = DEFAULT_WIDTH;

    /**
     * amount of padding to the left of each line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setLeftPadding methods instead.
     */
<span class="fc" id="L120">    @Deprecated</span>
    public int defaultLeftPad = DEFAULT_LEFT_PAD;

    /**
     * the number of characters of padding to be prefixed
     * to each description line
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setDescPadding methods instead.
     */
<span class="fc" id="L130">    @Deprecated</span>
    public int defaultDescPad = DEFAULT_DESC_PAD;

    /**
     * the string to display at the beginning of the usage statement
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setSyntaxPrefix methods instead.
     */
<span class="fc" id="L139">    @Deprecated</span>
    public String defaultSyntaxPrefix = DEFAULT_SYNTAX_PREFIX;

    /**
     * the new line string
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setNewLine methods instead.
     */
<span class="fc" id="L148">    @Deprecated</span>
<span class="fc" id="L149">    public String defaultNewLine = System.getProperty(&quot;line.separator&quot;);</span>

    /**
     * the shortOpt prefix
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setOptPrefix methods instead.
     */
<span class="fc" id="L157">    @Deprecated</span>
    public String defaultOptPrefix = DEFAULT_OPT_PREFIX;

    /**
     * the long Opt prefix
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setLongOptPrefix methods instead.
     */
<span class="fc" id="L166">    @Deprecated</span>
    public String defaultLongOptPrefix = DEFAULT_LONG_OPT_PREFIX;

    /**
     * the name of the argument
     *
     * @deprecated Scope will be made private for next major version
     * - use get/setArgName methods instead.
     */
<span class="fc" id="L175">    @Deprecated</span>
    public String defaultArgName = DEFAULT_ARG_NAME;

    /**
     * Comparator used to sort the options when they output in help text
     * 
     * Defaults to case-insensitive alphabetical sorting by option key
     */
<span class="fc" id="L183">    protected Comparator&lt;Option&gt; optionComparator = new OptionComparator();</span>

    /** The separator displayed between the long option and its value. */
<span class="fc" id="L186">    private String longOptSeparator = DEFAULT_LONG_OPT_SEPARATOR;</span>

    /**
     * Sets the 'width'.
     *
     * @param width the new value of 'width'
     */
    public void setWidth(final int width)
    {
<span class="fc" id="L195">        this.defaultWidth = width;</span>
<span class="fc" id="L196">    }</span>

    /**
     * Returns the 'width'.
     *
     * @return the 'width'
     */
    public int getWidth()
    {
<span class="fc" id="L205">        return defaultWidth;</span>
    }

    /**
     * Sets the 'leftPadding'.
     *
     * @param padding the new value of 'leftPadding'
     */
    public void setLeftPadding(final int padding)
    {
<span class="fc" id="L215">        this.defaultLeftPad = padding;</span>
<span class="fc" id="L216">    }</span>

    /**
     * Returns the 'leftPadding'.
     *
     * @return the 'leftPadding'
     */
    public int getLeftPadding()
    {
<span class="fc" id="L225">        return defaultLeftPad;</span>
    }

    /**
     * Sets the 'descPadding'.
     *
     * @param padding the new value of 'descPadding'
     */
    public void setDescPadding(final int padding)
    {
<span class="fc" id="L235">        this.defaultDescPad = padding;</span>
<span class="fc" id="L236">    }</span>

    /**
     * Returns the 'descPadding'.
     *
     * @return the 'descPadding'
     */
    public int getDescPadding()
    {
<span class="fc" id="L245">        return defaultDescPad;</span>
    }

    /**
     * Sets the 'syntaxPrefix'.
     *
     * @param prefix the new value of 'syntaxPrefix'
     */
    public void setSyntaxPrefix(final String prefix)
    {
<span class="fc" id="L255">        this.defaultSyntaxPrefix = prefix;</span>
<span class="fc" id="L256">    }</span>

    /**
     * Returns the 'syntaxPrefix'.
     *
     * @return the 'syntaxPrefix'
     */
    public String getSyntaxPrefix()
    {
<span class="fc" id="L265">        return defaultSyntaxPrefix;</span>
    }

    /**
     * Sets the 'newLine'.
     *
     * @param newline the new value of 'newLine'
     */
    public void setNewLine(final String newline)
    {
<span class="fc" id="L275">        this.defaultNewLine = newline;</span>
<span class="fc" id="L276">    }</span>

    /**
     * Returns the 'newLine'.
     *
     * @return the 'newLine'
     */
    public String getNewLine()
    {
<span class="fc" id="L285">        return defaultNewLine;</span>
    }

    /**
     * Sets the 'optPrefix'.
     *
     * @param prefix the new value of 'optPrefix'
     */
    public void setOptPrefix(final String prefix)
    {
<span class="fc" id="L295">        this.defaultOptPrefix = prefix;</span>
<span class="fc" id="L296">    }</span>

    /**
     * Returns the 'optPrefix'.
     *
     * @return the 'optPrefix'
     */
    public String getOptPrefix()
    {
<span class="fc" id="L305">        return defaultOptPrefix;</span>
    }

    /**
     * Sets the 'longOptPrefix'.
     *
     * @param prefix the new value of 'longOptPrefix'
     */
    public void setLongOptPrefix(final String prefix)
    {
<span class="fc" id="L315">        this.defaultLongOptPrefix = prefix;</span>
<span class="fc" id="L316">    }</span>

    /**
     * Returns the 'longOptPrefix'.
     *
     * @return the 'longOptPrefix'
     */
    public String getLongOptPrefix()
    {
<span class="fc" id="L325">        return defaultLongOptPrefix;</span>
    }

    /**
     * Set the separator displayed between a long option and its value.
     * Ensure that the separator specified is supported by the parser used,
     * typically ' ' or '='.
     * 
     * @param longOptSeparator the separator, typically ' ' or '='.
     * @since 1.3
     */
    public void setLongOptSeparator(final String longOptSeparator)
    {
<span class="fc" id="L338">        this.longOptSeparator = longOptSeparator;</span>
<span class="fc" id="L339">    }</span>

    /**
     * Returns the separator displayed between a long option and its value.
     * 
     * @return the separator
     * @since 1.3
     */
    public String getLongOptSeparator()
    {
<span class="fc" id="L349">        return longOptSeparator;</span>
    }

    /**
     * Sets the 'argName'.
     *
     * @param name the new value of 'argName'
     */
    public void setArgName(final String name)
    {
<span class="fc" id="L359">        this.defaultArgName = name;</span>
<span class="fc" id="L360">    }</span>

    /**
     * Returns the 'argName'.
     *
     * @return the 'argName'
     */
    public String getArgName()
    {
<span class="fc" id="L369">        return defaultArgName;</span>
    }

    /**
     * Comparator used to sort the options when they output in help text.
     * Defaults to case-insensitive alphabetical sorting by option key.
     *
     * @return the {@link Comparator} currently in use to sort the options
     * @since 1.2
     */
    public Comparator&lt;Option&gt; getOptionComparator()
    {
<span class="fc" id="L381">        return optionComparator;</span>
    }

    /**
     * Set the comparator used to sort the options when they output in help text.
     * Passing in a null comparator will keep the options in the order they were declared.
     *
     * @param comparator the {@link Comparator} to use for sorting the options
     * @since 1.2
     */
    public void setOptionComparator(final Comparator&lt;Option&gt; comparator)
    {
<span class="fc" id="L393">        this.optionComparator = comparator;</span>
<span class="fc" id="L394">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     */
    public void printHelp(final String cmdLineSyntax, final Options options)
    {
<span class="fc" id="L406">        printHelp(getWidth(), cmdLineSyntax, null, options, null, false);</span>
<span class="fc" id="L407">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to 
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param options the Options instance
     * @param autoUsage whether to print an automatically generated
     * usage statement
     */
    public void printHelp(final String cmdLineSyntax, final Options options, final boolean autoUsage)
    {
<span class="nc" id="L421">        printHelp(getWidth(), cmdLineSyntax, null, options, null, autoUsage);</span>
<span class="nc" id="L422">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer)
    {
<span class="nc" id="L436">        printHelp(cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L437">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to 
     * System.out.
     *
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated
     * usage statement
     */
    public void printHelp(final String cmdLineSyntax, final String header, final Options options, final String footer, final boolean autoUsage)
    {
<span class="nc" id="L453">        printHelp(getWidth(), cmdLineSyntax, header, options, footer, autoUsage);</span>
<span class="nc" id="L454">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     */
    public void printHelp(final int width, final String cmdLineSyntax, final String header, final Options options, final String footer)
    {
<span class="nc" id="L469">        printHelp(width, cmdLineSyntax, header, options, footer, false);</span>
<span class="nc" id="L470">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.  This method prints help information to
     * System.out.
     *
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated 
     * usage statement
     */
    public void printHelp(final int width, final String cmdLineSyntax, final String header,
                          final Options options, final String footer, final boolean autoUsage)
    {
<span class="fc" id="L488">        final PrintWriter pw = new PrintWriter(System.out);</span>

<span class="fc" id="L490">        printHelp(pw, width, cmdLineSyntax, header, options, getLeftPadding(), getDescPadding(), footer, autoUsage);</span>
<span class="fc" id="L491">        pw.flush();</span>
<span class="fc" id="L492">    }</span>

    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     * @param footer the banner to display at the end of the help
     *
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax, 
                          final String header, final Options options, final int leftPad, 
                          final int descPad, final String footer)
    {
<span class="fc" id="L515">        printHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);</span>
<span class="fc" id="L516">    }</span>


    /**
     * Print the help for &lt;code&gt;options&lt;/code&gt; with the specified
     * command line syntax.
     *
     * @param pw the writer to which the help will be written
     * @param width the number of characters to be displayed on each line
     * @param cmdLineSyntax the syntax for this application
     * @param header the banner to display at the beginning of the help
     * @param options the Options instance
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     * @param footer the banner to display at the end of the help
     * @param autoUsage whether to print an automatically generated
     * usage statement
     *
     * @throws IllegalStateException if there is no room to print a line
     */
    public void printHelp(final PrintWriter pw, final int width, final String cmdLineSyntax,
                          final String header, final Options options, final int leftPad,
                          final int descPad, final String footer, final boolean autoUsage)
    {
<span class="fc bfc" id="L542" title="All 4 branches covered.">        if (cmdLineSyntax == null || cmdLineSyntax.length() == 0)</span>
        {
<span class="fc" id="L544">            throw new IllegalArgumentException(&quot;cmdLineSyntax not provided&quot;);</span>
        }

<span class="fc bfc" id="L547" title="All 2 branches covered.">        if (autoUsage)</span>
        {
<span class="fc" id="L549">            printUsage(pw, width, cmdLineSyntax, options);</span>
        }
        else
        {
<span class="fc" id="L553">            printUsage(pw, width, cmdLineSyntax);</span>
        }

<span class="fc bfc" id="L556" title="All 4 branches covered.">        if (header != null &amp;&amp; header.trim().length() &gt; 0)</span>
        {
<span class="fc" id="L558">            printWrapped(pw, width, header);</span>
        }

<span class="fc" id="L561">        printOptions(pw, width, options, leftPad, descPad);</span>

<span class="fc bfc" id="L563" title="All 4 branches covered.">        if (footer != null &amp;&amp; footer.trim().length() &gt; 0)</span>
        {
<span class="fc" id="L565">            printWrapped(pw, width, footer);</span>
        }
<span class="fc" id="L567">    }</span>

    /**
     * Prints the usage statement for the specified application.
     *
     * @param pw The PrintWriter to print the usage statement 
     * @param width The number of characters to display per line
     * @param app The application name
     * @param options The command line Options
     */
    public void printUsage(final PrintWriter pw, final int width, final String app, final Options options)
    {
        // initialise the string buffer
<span class="fc" id="L580">        final StringBuffer buff = new StringBuffer(getSyntaxPrefix()).append(app).append(&quot; &quot;);</span>

        // create a list for processed option groups
<span class="fc" id="L583">        final Collection&lt;OptionGroup&gt; processedGroups = new ArrayList&lt;OptionGroup&gt;();</span>

<span class="fc" id="L585">        final List&lt;Option&gt; optList = new ArrayList&lt;Option&gt;(options.getOptions());</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L588">            Collections.sort(optList, getOptionComparator());</span>
        }
        // iterate over the options
<span class="fc bfc" id="L591" title="All 2 branches covered.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
            // get the next Option
<span class="fc" id="L594">            final Option option = it.next();</span>

            // check if the option is part of an OptionGroup
<span class="fc" id="L597">            final OptionGroup group = options.getOptionGroup(option);</span>

            // if the option is part of a group 
<span class="fc bfc" id="L600" title="All 2 branches covered.">            if (group != null)</span>
            {
                // and if the group has not already been processed
<span class="fc bfc" id="L603" title="All 2 branches covered.">                if (!processedGroups.contains(group))</span>
                {
                    // add the group to the processed list
<span class="fc" id="L606">                    processedGroups.add(group);</span>


                    // add the usage clause
<span class="fc" id="L610">                    appendOptionGroup(buff, group);</span>
                }

                // otherwise the option was displayed in the group
                // previously so ignore it.
            }

            // if the Option is not part of an OptionGroup
            else
            {
<span class="fc" id="L620">                appendOption(buff, option, option.isRequired());</span>
            }

<span class="fc bfc" id="L623" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L625">                buff.append(&quot; &quot;);</span>
            }
<span class="fc" id="L627">        }</span>


        // call printWrapped
<span class="fc" id="L631">        printWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());</span>
<span class="fc" id="L632">    }</span>

    /**
     * Appends the usage clause for an OptionGroup to a StringBuffer.  
     * The clause is wrapped in square brackets if the group is required.
     * The display of the options is handled by appendOption
     * @param buff the StringBuffer to append to
     * @param group the group to append
     * @see #appendOption(StringBuffer,Option,boolean)
     */
    private void appendOptionGroup(final StringBuffer buff, final OptionGroup group)
    {
<span class="fc bfc" id="L644" title="All 2 branches covered.">        if (!group.isRequired())</span>
        {
<span class="fc" id="L646">            buff.append(&quot;[&quot;);</span>
        }

<span class="fc" id="L649">        final List&lt;Option&gt; optList = new ArrayList&lt;Option&gt;(group.getOptions());</span>
<span class="pc bpc" id="L650" title="1 of 2 branches missed.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L652">            Collections.sort(optList, getOptionComparator());</span>
        }
        // for each option in the OptionGroup
<span class="fc bfc" id="L655" title="All 2 branches covered.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
            // whether the option is required or not is handled at group level
<span class="fc" id="L658">            appendOption(buff, it.next(), true);</span>

<span class="fc bfc" id="L660" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L662">                buff.append(&quot; | &quot;);</span>
            }
        }

<span class="fc bfc" id="L666" title="All 2 branches covered.">        if (!group.isRequired())</span>
        {
<span class="fc" id="L668">            buff.append(&quot;]&quot;);</span>
        }
<span class="fc" id="L670">    }</span>

    /**
     * Appends the usage clause for an Option to a StringBuffer.  
     *
     * @param buff the StringBuffer to append to
     * @param option the Option to append
     * @param required whether the Option is required or not
     */
    private void appendOption(final StringBuffer buff, final Option option, final boolean required)
    {
<span class="fc bfc" id="L681" title="All 2 branches covered.">        if (!required)</span>
        {
<span class="fc" id="L683">            buff.append(&quot;[&quot;);</span>
        }

<span class="fc bfc" id="L686" title="All 2 branches covered.">        if (option.getOpt() != null)</span>
        {
<span class="fc" id="L688">            buff.append(&quot;-&quot;).append(option.getOpt());</span>
        }
        else
        {
<span class="fc" id="L692">            buff.append(&quot;--&quot;).append(option.getLongOpt());</span>
        }
        
        // if the Option has a value and a non blank argname
<span class="fc bfc" id="L696" title="All 6 branches covered.">        if (option.hasArg() &amp;&amp; (option.getArgName() == null || option.getArgName().length() != 0))</span>
        {
<span class="fc bfc" id="L698" title="All 2 branches covered.">            buff.append(option.getOpt() == null ? longOptSeparator : &quot; &quot;);</span>
<span class="fc bfc" id="L699" title="All 2 branches covered.">            buff.append(&quot;&lt;&quot;).append(option.getArgName() != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
        }
        
        // if the Option is not a required option
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if (!required)</span>
        {
<span class="fc" id="L705">            buff.append(&quot;]&quot;);</span>
        }
<span class="fc" id="L707">    }</span>

    /**
     * Print the cmdLineSyntax to the specified writer, using the
     * specified width.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters per line for the usage statement.
     * @param cmdLineSyntax The usage statement.
     */
    public void printUsage(final PrintWriter pw, final int width, final String cmdLineSyntax)
    {
<span class="fc" id="L719">        final int argPos = cmdLineSyntax.indexOf(' ') + 1;</span>

<span class="fc" id="L721">        printWrapped(pw, width, getSyntaxPrefix().length() + argPos, getSyntaxPrefix() + cmdLineSyntax);</span>
<span class="fc" id="L722">    }</span>

    /**
     * Print the help for the specified Options to the specified writer, 
     * using the specified width, left padding and description padding.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     */
    public void printOptions(final PrintWriter pw, final int width, final Options options, 
                             final int leftPad, final int descPad)
    {
<span class="fc" id="L739">        final StringBuffer sb = new StringBuffer();</span>

<span class="fc" id="L741">        renderOptions(sb, width, options, leftPad, descPad);</span>
<span class="fc" id="L742">        pw.println(sb.toString());</span>
<span class="fc" id="L743">    }</span>

    /**
     * Print the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(final PrintWriter pw, final int width, final String text)
    {
<span class="fc" id="L754">        printWrapped(pw, width, 0, text);</span>
<span class="fc" id="L755">    }</span>

    /**
     * Print the specified text to the specified PrintWriter.
     *
     * @param pw The printWriter to write the help to
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be written to the PrintWriter
     */
    public void printWrapped(final PrintWriter pw, final int width, final int nextLineTabStop, final String text)
    {
<span class="fc" id="L767">        final StringBuffer sb = new StringBuffer(text.length());</span>

<span class="fc" id="L769">        renderWrappedTextBlock(sb, width, nextLineTabStop, text);</span>
<span class="fc" id="L770">        pw.println(sb.toString());</span>
<span class="fc" id="L771">    }</span>

    // --------------------------------------------------------------- Protected

    /**
     * Render the specified Options and return the rendered Options
     * in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered Options into.
     * @param width The number of characters to display per line
     * @param options The command line Options
     * @param leftPad the number of characters of padding to be prefixed
     * to each line
     * @param descPad the number of characters of padding to be prefixed
     * to each description line
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderOptions(final StringBuffer sb, final int width, final Options options, final int leftPad, final int descPad)
    {
<span class="fc" id="L791">        final String lpad = createPadding(leftPad);</span>
<span class="fc" id="L792">        final String dpad = createPadding(descPad);</span>

        // first create list containing only &lt;lpad&gt;-a,--aaa where 
        // -a is opt and --aaa is long opt; in parallel look for 
        // the longest opt string this list will be then used to 
        // sort options ascending
<span class="fc" id="L798">        int max = 0;</span>
<span class="fc" id="L799">        final List&lt;StringBuffer&gt; prefixList = new ArrayList&lt;StringBuffer&gt;();</span>

<span class="fc" id="L801">        final List&lt;Option&gt; optList = options.helpOptions();</span>

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">        if (getOptionComparator() != null)</span>
        {
<span class="fc" id="L805">            Collections.sort(optList, getOptionComparator());</span>
        }

<span class="fc bfc" id="L808" title="All 2 branches covered.">        for (final Option option : optList)</span>
        {
<span class="fc" id="L810">            final StringBuffer optBuf = new StringBuffer();</span>

<span class="fc bfc" id="L812" title="All 2 branches covered.">            if (option.getOpt() == null)</span>
            {
<span class="fc" id="L814">                optBuf.append(lpad).append(&quot;   &quot;).append(getLongOptPrefix()).append(option.getLongOpt());</span>
            }
            else
            {
<span class="fc" id="L818">                optBuf.append(lpad).append(getOptPrefix()).append(option.getOpt());</span>

<span class="fc bfc" id="L820" title="All 2 branches covered.">                if (option.hasLongOpt())</span>
                {
<span class="fc" id="L822">                    optBuf.append(',').append(getLongOptPrefix()).append(option.getLongOpt());</span>
                }
            }

<span class="fc bfc" id="L826" title="All 2 branches covered.">            if (option.hasArg())</span>
            {
<span class="fc" id="L828">                final String argName = option.getArgName();</span>
<span class="pc bpc" id="L829" title="1 of 4 branches missed.">                if (argName != null &amp;&amp; argName.length() == 0)</span>
                {
                    // if the option has a blank argname
<span class="nc" id="L832">                    optBuf.append(' ');</span>
                }
                else
                {
<span class="fc bfc" id="L836" title="All 2 branches covered.">                    optBuf.append(option.hasLongOpt() ? longOptSeparator : &quot; &quot;);</span>
<span class="fc bfc" id="L837" title="All 2 branches covered.">                    optBuf.append(&quot;&lt;&quot;).append(argName != null ? option.getArgName() : getArgName()).append(&quot;&gt;&quot;);</span>
                }
            }

<span class="fc" id="L841">            prefixList.add(optBuf);</span>
<span class="fc bfc" id="L842" title="All 2 branches covered.">            max = optBuf.length() &gt; max ? optBuf.length() : max;</span>
<span class="fc" id="L843">        }</span>

<span class="fc" id="L845">        int x = 0;</span>

<span class="fc bfc" id="L847" title="All 2 branches covered.">        for (final Iterator&lt;Option&gt; it = optList.iterator(); it.hasNext();)</span>
        {
<span class="fc" id="L849">            final Option option = it.next();</span>
<span class="fc" id="L850">            final StringBuilder optBuf = new StringBuilder(prefixList.get(x++).toString());</span>

<span class="fc bfc" id="L852" title="All 2 branches covered.">            if (optBuf.length() &lt; max)</span>
            {
<span class="fc" id="L854">                optBuf.append(createPadding(max - optBuf.length()));</span>
            }

<span class="fc" id="L857">            optBuf.append(dpad);</span>

<span class="fc" id="L859">            final int nextLineTabStop = max + descPad;</span>

<span class="pc bpc" id="L861" title="1 of 2 branches missed.">            if (option.getDescription() != null)</span>
            {
<span class="fc" id="L863">                optBuf.append(option.getDescription());</span>
            }

<span class="fc" id="L866">            renderWrappedText(sb, width, nextLineTabStop, optBuf.toString());</span>

<span class="fc bfc" id="L868" title="All 2 branches covered.">            if (it.hasNext())</span>
            {
<span class="fc" id="L870">                sb.append(getNewLine());</span>
            }
<span class="fc" id="L872">        }</span>

<span class="fc" id="L874">        return sb;</span>
    }

    /**
     * Render the specified text and return the rendered Options
     * in a StringBuffer.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     *
     * @return the StringBuffer with the rendered Options contents.
     */
    protected StringBuffer renderWrappedText(final StringBuffer sb, final int width, 
                                             int nextLineTabStop, String text)
    {
<span class="fc" id="L891">        int pos = findWrapPos(text, width, 0);</span>

<span class="fc bfc" id="L893" title="All 2 branches covered.">        if (pos == -1)</span>
        {
<span class="fc" id="L895">            sb.append(rtrim(text));</span>

<span class="fc" id="L897">            return sb;</span>
        }
<span class="fc" id="L899">        sb.append(rtrim(text.substring(0, pos))).append(getNewLine());</span>

<span class="fc bfc" id="L901" title="All 2 branches covered.">        if (nextLineTabStop &gt;= width)</span>
        {
            // stops infinite loop happening
<span class="fc" id="L904">            nextLineTabStop = 1;</span>
        }

        // all following lines must be padded with nextLineTabStop space characters
<span class="fc" id="L908">        final String padding = createPadding(nextLineTabStop);</span>

        while (true)
        {
<span class="fc" id="L912">            text = padding + text.substring(pos).trim();</span>
<span class="fc" id="L913">            pos = findWrapPos(text, width, 0);</span>

<span class="fc bfc" id="L915" title="All 2 branches covered.">            if (pos == -1)</span>
            {
<span class="fc" id="L917">                sb.append(text);</span>

<span class="fc" id="L919">                return sb;</span>
            }

<span class="fc bfc" id="L922" title="All 4 branches covered.">            if (text.length() &gt; width &amp;&amp; pos == nextLineTabStop - 1)</span>
            {
<span class="fc" id="L924">                pos = width;</span>
            }

<span class="fc" id="L927">            sb.append(rtrim(text.substring(0, pos))).append(getNewLine());</span>
        }
    }

    /**
     * Render the specified text width a maximum width. This method differs
     * from renderWrappedText by not removing leading spaces after a new line.
     *
     * @param sb The StringBuffer to place the rendered text into.
     * @param width The number of characters to display per line
     * @param nextLineTabStop The position on the next line for the first tab.
     * @param text The text to be rendered.
     */
    private Appendable renderWrappedTextBlock(final StringBuffer sb, final int width, final int nextLineTabStop, final String text)
    {
        try
        {
<span class="fc" id="L944">            final BufferedReader in = new BufferedReader(new StringReader(text));</span>
            String line;
<span class="fc" id="L946">            boolean firstLine = true;</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">            while ((line = in.readLine()) != null)</span>
            {
<span class="fc bfc" id="L949" title="All 2 branches covered.">                if (!firstLine)</span>
                {
<span class="fc" id="L951">                    sb.append(getNewLine());</span>
                }
                else
                {
<span class="fc" id="L955">                    firstLine = false;</span>
                }
<span class="fc" id="L957">                renderWrappedText(sb, width, nextLineTabStop, line);</span>
            }
        }
<span class="nc" id="L960">        catch (final IOException e) //NOPMD</span>
        {
            // cannot happen
<span class="fc" id="L963">        }</span>

<span class="fc" id="L965">        return sb;</span>
    }

    /**
     * Finds the next text wrap position after &lt;code&gt;startPos&lt;/code&gt; for the
     * text in &lt;code&gt;text&lt;/code&gt; with the column width &lt;code&gt;width&lt;/code&gt;.
     * The wrap point is the last position before startPos+width having a 
     * whitespace character (space, \n, \r). If there is no whitespace character
     * before startPos+width, it will return startPos+width.
     *
     * @param text The text being searched for the wrap position
     * @param width width of the wrapped text
     * @param startPos position from which to start the lookup whitespace
     * character
     * @return position on which the text must be wrapped or -1 if the wrap
     * position is at the end of the text
     */
    protected int findWrapPos(final String text, final int width, final int startPos)
    {
        // the line ends before the max wrap pos or a new line char found
<span class="fc" id="L985">        int pos = text.indexOf('\n', startPos);</span>
<span class="fc bfc" id="L986" title="All 4 branches covered.">        if (pos != -1 &amp;&amp; pos &lt;= width)</span>
        {
<span class="fc" id="L988">            return pos + 1;</span>
        }

<span class="fc" id="L991">        pos = text.indexOf('\t', startPos);</span>
<span class="pc bpc" id="L992" title="1 of 4 branches missed.">        if (pos != -1 &amp;&amp; pos &lt;= width)</span>
        {
<span class="fc" id="L994">            return pos + 1;</span>
        }

<span class="fc bfc" id="L997" title="All 2 branches covered.">        if (startPos + width &gt;= text.length())</span>
        {
<span class="fc" id="L999">            return -1;</span>
        }

        // look for the last whitespace character before startPos+width
<span class="fc bfc" id="L1003" title="All 2 branches covered.">        for (pos = startPos + width; pos &gt;= startPos; --pos)</span>
        {
<span class="fc" id="L1005">            final char c = text.charAt(pos);</span>
<span class="pc bpc" id="L1006" title="2 of 6 branches missed.">            if (c == ' ' || c == '\n' || c == '\r')</span>
            {
<span class="nc" id="L1008">                break;</span>
            }
        }

        // if we found it - just return
<span class="fc bfc" id="L1013" title="All 2 branches covered.">        if (pos &gt; startPos)</span>
        {
<span class="fc" id="L1015">            return pos;</span>
        }

        // if we didn't find one, simply chop at startPos+width
<span class="fc" id="L1019">        pos = startPos + width;</span>

<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">        return pos == text.length() ? -1 : pos;</span>
    }

    /**
     * Return a String of padding of length &lt;code&gt;len&lt;/code&gt;.
     *
     * @param len The length of the String of padding to create.
     *
     * @return The String of padding
     */
    protected String createPadding(final int len)
    {
<span class="fc" id="L1033">        final char[] padding = new char[len];</span>
<span class="fc" id="L1034">        Arrays.fill(padding, ' ');</span>

<span class="fc" id="L1036">        return new String(padding);</span>
    }

    /**
     * Remove the trailing whitespace from the specified String.
     *
     * @param s The String to remove the trailing padding from.
     *
     * @return The String of without the trailing padding
     */
    protected String rtrim(final String s)
    {
<span class="fc bfc" id="L1048" title="All 4 branches covered.">        if (s == null || s.length() == 0)</span>
        {
<span class="fc" id="L1050">            return s;</span>
        }

<span class="fc" id="L1053">        int pos = s.length();</span>

<span class="pc bpc" id="L1055" title="1 of 4 branches missed.">        while (pos &gt; 0 &amp;&amp; Character.isWhitespace(s.charAt(pos - 1)))</span>
        {
<span class="fc" id="L1057">            --pos;</span>
        }

<span class="fc" id="L1060">        return s.substring(0, pos);</span>
    }

    // ------------------------------------------------------ Package protected
    // ---------------------------------------------------------------- Private
    // ---------------------------------------------------------- Inner classes
    /**
     * This class implements the &lt;code&gt;Comparator&lt;/code&gt; interface
     * for comparing Options.
     */
    private static class OptionComparator implements Comparator&lt;Option&gt;, Serializable
    {
        /** The serial version UID. */
        private static final long serialVersionUID = 5305467873966684014L;

        /**
         * Compares its two arguments for order. Returns a negative
         * integer, zero, or a positive integer as the first argument
         * is less than, equal to, or greater than the second.
         *
         * @param opt1 The first Option to be compared.
         * @param opt2 The second Option to be compared.
         * @return a negative integer, zero, or a positive integer as
         *         the first argument is less than, equal to, or greater than the
         *         second.
         */
        public int compare(final Option opt1, final Option opt2)
        {
<span class="fc" id="L1088">            return opt1.getKey().compareToIgnoreCase(opt2.getKey());</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>