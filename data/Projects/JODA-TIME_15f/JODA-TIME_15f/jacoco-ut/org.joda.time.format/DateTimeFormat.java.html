<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DateTimeFormat.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda time</a> &gt; <a href="index.source.html" class="el_package">org.joda.time.format</a> &gt; <span class="el_source">DateTimeFormat.java</span></div><h1>DateTimeFormat.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-2009 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.joda.time.Chronology;
import org.joda.time.DateTime;
import org.joda.time.DateTimeZone;
import org.joda.time.ReadablePartial;

/**
 * Factory that creates instances of DateTimeFormatter from patterns and styles.
 * &lt;p&gt;
 * Datetime formatting is performed by the {@link DateTimeFormatter} class.
 * Three classes provide factory methods to create formatters, and this is one.
 * The others are {@link ISODateTimeFormat} and {@link DateTimeFormatterBuilder}.
 * &lt;p&gt;
 * This class provides two types of factory:
 * &lt;ul&gt;
 * &lt;li&gt;{@link #forPattern(String) Pattern} provides a DateTimeFormatter based on
 * a pattern string that is mostly compatible with the JDK date patterns.
 * &lt;li&gt;{@link #forStyle(String) Style} provides a DateTimeFormatter based on a
 * two character style, representing short, medium, long and full.
 * &lt;/ul&gt;
 * &lt;p&gt;
 * For example, to use a patterm:
 * &lt;pre&gt;
 * DateTime dt = new DateTime();
 * DateTimeFormatter fmt = DateTimeFormat.forPattern(&quot;MMMM, yyyy&quot;);
 * String str = fmt.print(dt);
 * &lt;/pre&gt;
 *
 * The pattern syntax is mostly compatible with java.text.SimpleDateFormat -
 * time zone names cannot be parsed and a few more symbols are supported.
 * All ASCII letters are reserved as pattern letters, which are defined as follows:
 * &lt;blockquote&gt;
 * &lt;pre&gt;
 * Symbol  Meaning                      Presentation  Examples
 * ------  -------                      ------------  -------
 * G       era                          text          AD
 * C       century of era (&amp;gt;=0)         number        20
 * Y       year of era (&amp;gt;=0)            year          1996
 *
 * x       weekyear                     year          1996
 * w       week of weekyear             number        27
 * e       day of week                  number        2
 * E       day of week                  text          Tuesday; Tue
 *
 * y       year                         year          1996
 * D       day of year                  number        189
 * M       month of year                month         July; Jul; 07
 * d       day of month                 number        10
 *
 * a       halfday of day               text          PM
 * K       hour of halfday (0~11)       number        0
 * h       clockhour of halfday (1~12)  number        12
 *
 * H       hour of day (0~23)           number        0
 * k       clockhour of day (1~24)      number        24
 * m       minute of hour               number        30
 * s       second of minute             number        55
 * S       fraction of second           number        978
 *
 * z       time zone                    text          Pacific Standard Time; PST
 * Z       time zone offset/id          zone          -0800; -08:00; America/Los_Angeles
 *
 * '       escape for text              delimiter
 * ''      single quote                 literal       '
 * &lt;/pre&gt;
 * &lt;/blockquote&gt;
 * The count of pattern letters determine the format.
 * &lt;p&gt;
 * &lt;strong&gt;Text&lt;/strong&gt;: If the number of pattern letters is 4 or more,
 * the full form is used; otherwise a short or abbreviated form is used if
 * available.
 * &lt;p&gt;
 * &lt;strong&gt;Number&lt;/strong&gt;: The minimum number of digits. Shorter numbers
 * are zero-padded to this amount.
 * &lt;p&gt;
 * &lt;strong&gt;Year&lt;/strong&gt;: Numeric presentation for year and weekyear fields
 * are handled specially. For example, if the count of 'y' is 2, the year
 * will be displayed as the zero-based year of the century, which is two
 * digits.
 * &lt;p&gt;
 * &lt;strong&gt;Month&lt;/strong&gt;: 3 or over, use text, otherwise use number.
 * &lt;p&gt;
 * &lt;strong&gt;Zone&lt;/strong&gt;: 'Z' outputs offset without a colon, 'ZZ' outputs
 * the offset with a colon, 'ZZZ' or more outputs the zone id.
 * &lt;p&gt;
 * &lt;strong&gt;Zone names&lt;/strong&gt;: Time zone names ('z') cannot be parsed.
 * &lt;p&gt;
 * Any characters in the pattern that are not in the ranges of ['a'..'z']
 * and ['A'..'Z'] will be treated as quoted text. For instance, characters
 * like ':', '.', ' ', '#' and '?' will appear in the resulting time text
 * even they are not embraced within single quotes.
 * &lt;p&gt;
 * DateTimeFormat is thread-safe and immutable, and the formatters it returns
 * are as well.
 *
 * @author Brian S O'Neill
 * @author Maxim Zhao
 * @since 1.0
 * @see ISODateTimeFormat
 * @see DateTimeFormatterBuilder
 */
public class DateTimeFormat {

    /** Style constant for FULL. */
    static final int FULL = 0;  // DateFormat.FULL
    /** Style constant for LONG. */
    static final int LONG = 1;  // DateFormat.LONG
    /** Style constant for MEDIUM. */
    static final int MEDIUM = 2;  // DateFormat.MEDIUM
    /** Style constant for SHORT. */
    static final int SHORT = 3;  // DateFormat.SHORT
    /** Style constant for NONE. */
    static final int NONE = 4;

    /** Type constant for DATE only. */
    static final int DATE = 0;
    /** Type constant for TIME only. */
    static final int TIME = 1;
    /** Type constant for DATETIME. */
    static final int DATETIME = 2;

    /** Maps patterns to formatters, patterns don't vary by locale. */
<span class="fc" id="L147">    private static final Map&lt;String, DateTimeFormatter&gt; cPatternedCache = new HashMap&lt;String, DateTimeFormatter&gt;(7);</span>
    /** Maps patterns to formatters, patterns don't vary by locale. */
<span class="fc" id="L149">    private static final DateTimeFormatter[] cStyleCache = new DateTimeFormatter[25];</span>

    //-----------------------------------------------------------------------
    /**
     * Factory to create a formatter from a pattern string.
     * The pattern string is described above in the class level javadoc.
     * It is very similar to SimpleDateFormat patterns.
     * &lt;p&gt;
     * The format may contain locale specific output, and this will change as
     * you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * For example:
     * &lt;pre&gt;
     * DateTimeFormat.forPattern(pattern).withLocale(Locale.FRANCE).print(dt);
     * &lt;/pre&gt;
     *
     * @param pattern  pattern specification
     * @return the formatter
     * @throws IllegalArgumentException if the pattern is invalid
     */
    public static DateTimeFormatter forPattern(String pattern) {
<span class="fc" id="L170">        return createFormatterForPattern(pattern);</span>
    }

    /**
     * Factory to create a format from a two character style pattern.
     * &lt;p&gt;
     * The first character is the date style, and the second character is the
     * time style. Specify a character of 'S' for short style, 'M' for medium,
     * 'L' for long, and 'F' for full.
     * A date or time may be ommitted by specifying a style character '-'.
     * &lt;p&gt;
     * The returned formatter will dynamically adjust to the locale that
     * the print/parse takes place in. Thus you just call
     * {@link DateTimeFormatter#withLocale(Locale)} and the Short/Medium/Long/Full
     * style for that locale will be output. For example:
     * &lt;pre&gt;
     * DateTimeFormat.forStyle(style).withLocale(Locale.FRANCE).print(dt);
     * &lt;/pre&gt;
     *
     * @param style  two characters from the set {&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;F&quot;, &quot;-&quot;}
     * @return the formatter
     * @throws IllegalArgumentException if the style is invalid
     */
    public static DateTimeFormatter forStyle(String style) {
<span class="fc" id="L194">        return createFormatterForStyle(style);</span>
    }

    /**
     * Returns the pattern used by a particular style and locale.
     * &lt;p&gt;
     * The first character is the date style, and the second character is the
     * time style. Specify a character of 'S' for short style, 'M' for medium,
     * 'L' for long, and 'F' for full.
     * A date or time may be ommitted by specifying a style character '-'.
     *
     * @param style  two characters from the set {&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;F&quot;, &quot;-&quot;}
     * @param locale  locale to use, null means default
     * @return the formatter
     * @throws IllegalArgumentException if the style is invalid
     * @since 1.3
     */
    public static String patternForStyle(String style, Locale locale) {
<span class="nc" id="L212">        DateTimeFormatter formatter = createFormatterForStyle(style);</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">        if (locale == null) {</span>
<span class="nc" id="L214">            locale = Locale.getDefault();</span>
        }
        // Not pretty, but it works.
<span class="nc" id="L217">        return ((StyleFormatter) formatter.getPrinter()).getPattern(locale);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a format that outputs a short date format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter shortDate() {
<span class="fc" id="L230">        return createFormatterForStyleIndex(SHORT, NONE);</span>
    }

    /**
     * Creates a format that outputs a short time format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter shortTime() {
<span class="fc" id="L242">        return createFormatterForStyleIndex(NONE, SHORT);</span>
    }

    /**
     * Creates a format that outputs a short datetime format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter shortDateTime() {
<span class="fc" id="L254">        return createFormatterForStyleIndex(SHORT, SHORT);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a format that outputs a medium date format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter mediumDate() {
<span class="fc" id="L267">        return createFormatterForStyleIndex(MEDIUM, NONE);</span>
    }

    /**
     * Creates a format that outputs a medium time format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter mediumTime() {
<span class="fc" id="L279">        return createFormatterForStyleIndex(NONE, MEDIUM);</span>
    }

    /**
     * Creates a format that outputs a medium datetime format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter mediumDateTime() {
<span class="fc" id="L291">        return createFormatterForStyleIndex(MEDIUM, MEDIUM);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a format that outputs a long date format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter longDate() {
<span class="fc" id="L304">        return createFormatterForStyleIndex(LONG, NONE);</span>
    }

    /**
     * Creates a format that outputs a long time format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter longTime() {
<span class="nc" id="L316">        return createFormatterForStyleIndex(NONE, LONG);</span>
    }

    /**
     * Creates a format that outputs a long datetime format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter longDateTime() {
<span class="nc" id="L328">        return createFormatterForStyleIndex(LONG, LONG);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a format that outputs a full date format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter fullDate() {
<span class="fc" id="L341">        return createFormatterForStyleIndex(FULL, NONE);</span>
    }

    /**
     * Creates a format that outputs a full time format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter fullTime() {
<span class="nc" id="L353">        return createFormatterForStyleIndex(NONE, FULL);</span>
    }

    /**
     * Creates a format that outputs a full datetime format.
     * &lt;p&gt;
     * The format will change as you change the locale of the formatter.
     * Call {@link DateTimeFormatter#withLocale(Locale)} to switch the locale.
     * 
     * @return the formatter
     */
    public static DateTimeFormatter fullDateTime() {
<span class="nc" id="L365">        return createFormatterForStyleIndex(FULL, FULL);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Parses the given pattern and appends the rules to the given
     * DateTimeFormatterBuilder.
     *
     * @param pattern  pattern specification
     * @throws IllegalArgumentException if the pattern is invalid
     */
    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {
<span class="fc" id="L377">        parsePatternTo(builder, pattern);</span>
<span class="fc" id="L378">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Constructor.
     *
     * @since 1.1 (previously private)
     */
    protected DateTimeFormat() {
<span class="fc" id="L387">        super();</span>
<span class="fc" id="L388">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Parses the given pattern and appends the rules to the given
     * DateTimeFormatterBuilder.
     *
     * @param pattern  pattern specification
     * @throws IllegalArgumentException if the pattern is invalid
     * @see #forPattern
     */
    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {
<span class="fc" id="L400">        int length = pattern.length();</span>
<span class="fc" id="L401">        int[] indexRef = new int[1];</span>

<span class="fc bfc" id="L403" title="All 2 branches covered.">        for (int i=0; i&lt;length; i++) {</span>
<span class="fc" id="L404">            indexRef[0] = i;</span>
<span class="fc" id="L405">            String token = parseToken(pattern, indexRef);</span>
<span class="fc" id="L406">            i = indexRef[0];</span>

<span class="fc" id="L408">            int tokenLen = token.length();</span>
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">            if (tokenLen == 0) {</span>
<span class="nc" id="L410">                break;</span>
            }
<span class="fc" id="L412">            char c = token.charAt(0);</span>

<span class="pc bpc" id="L414" title="1 of 21 branches missed.">            switch (c) {</span>
            case 'G': // era designator (text)
<span class="fc" id="L416">                builder.appendEraText();</span>
<span class="fc" id="L417">                break;</span>
            case 'C': // century of era (number)
<span class="fc" id="L419">                builder.appendCenturyOfEra(tokenLen, tokenLen);</span>
<span class="fc" id="L420">                break;</span>
            case 'x': // weekyear (number)
            case 'y': // year (number)
            case 'Y': // year of era (number)
<span class="fc bfc" id="L424" title="All 2 branches covered.">                if (tokenLen == 2) {</span>
<span class="fc" id="L425">                    boolean lenientParse = true;</span>

                    // Peek ahead to next token.
<span class="fc bfc" id="L428" title="All 2 branches covered.">                    if (i + 1 &lt; length) {</span>
<span class="fc" id="L429">                        indexRef[0]++;</span>
<span class="fc bfc" id="L430" title="All 2 branches covered.">                        if (isNumericToken(parseToken(pattern, indexRef))) {</span>
                            // If next token is a number, cannot support
                            // lenient parse, because it will consume digits
                            // that it should not.
<span class="fc" id="L434">                            lenientParse = false;</span>
                        }
<span class="fc" id="L436">                        indexRef[0]--;</span>
                    }

                    // Use pivots which are compatible with SimpleDateFormat.
<span class="fc bfc" id="L440" title="All 2 branches covered.">                    switch (c) {</span>
                    case 'x':
<span class="fc" id="L442">                        builder.appendTwoDigitWeekyear</span>
<span class="fc" id="L443">                            (new DateTime().getWeekyear() - 30, lenientParse);</span>
<span class="fc" id="L444">                        break;</span>
                    case 'y':
                    case 'Y':
                    default:
<span class="fc" id="L448">                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);</span>
                        break;
                    }
<span class="fc" id="L451">                } else {</span>
                    // Try to support long year values.
<span class="fc" id="L453">                    int maxDigits = 9;</span>

                    // Peek ahead to next token.
<span class="fc bfc" id="L456" title="All 2 branches covered.">                    if (i + 1 &lt; length) {</span>
<span class="fc" id="L457">                        indexRef[0]++;</span>
<span class="fc bfc" id="L458" title="All 2 branches covered.">                        if (isNumericToken(parseToken(pattern, indexRef))) {</span>
                            // If next token is a number, cannot support long years.
<span class="fc" id="L460">                            maxDigits = tokenLen;</span>
                        }
<span class="fc" id="L462">                        indexRef[0]--;</span>
                    }

<span class="pc bpc" id="L465" title="1 of 4 branches missed.">                    switch (c) {</span>
                    case 'x':
<span class="fc" id="L467">                        builder.appendWeekyear(tokenLen, maxDigits);</span>
<span class="fc" id="L468">                        break;</span>
                    case 'y':
<span class="fc" id="L470">                        builder.appendYear(tokenLen, maxDigits);</span>
<span class="fc" id="L471">                        break;</span>
                    case 'Y':
<span class="fc" id="L473">                        builder.appendYearOfEra(tokenLen, maxDigits);</span>
                        break;
                    }
                }
<span class="fc" id="L477">                break;</span>
            case 'M': // month of year (text and number)
<span class="fc bfc" id="L479" title="All 2 branches covered.">                if (tokenLen &gt;= 3) {</span>
<span class="fc bfc" id="L480" title="All 2 branches covered.">                    if (tokenLen &gt;= 4) {</span>
<span class="fc" id="L481">                        builder.appendMonthOfYearText();</span>
                    } else {
<span class="fc" id="L483">                        builder.appendMonthOfYearShortText();</span>
                    }
                } else {
<span class="fc" id="L486">                    builder.appendMonthOfYear(tokenLen);</span>
                }
<span class="fc" id="L488">                break;</span>
            case 'd': // day of month (number)
<span class="fc" id="L490">                builder.appendDayOfMonth(tokenLen);</span>
<span class="fc" id="L491">                break;</span>
            case 'a': // am/pm marker (text)
<span class="fc" id="L493">                builder.appendHalfdayOfDayText();</span>
<span class="fc" id="L494">                break;</span>
            case 'h': // clockhour of halfday (number, 1..12)
<span class="fc" id="L496">                builder.appendClockhourOfHalfday(tokenLen);</span>
<span class="fc" id="L497">                break;</span>
            case 'H': // hour of day (number, 0..23)
<span class="fc" id="L499">                builder.appendHourOfDay(tokenLen);</span>
<span class="fc" id="L500">                break;</span>
            case 'k': // clockhour of day (1..24)
<span class="fc" id="L502">                builder.appendClockhourOfDay(tokenLen);</span>
<span class="fc" id="L503">                break;</span>
            case 'K': // hour of halfday (0..11)
<span class="fc" id="L505">                builder.appendHourOfHalfday(tokenLen);</span>
<span class="fc" id="L506">                break;</span>
            case 'm': // minute of hour (number)
<span class="fc" id="L508">                builder.appendMinuteOfHour(tokenLen);</span>
<span class="fc" id="L509">                break;</span>
            case 's': // second of minute (number)
<span class="fc" id="L511">                builder.appendSecondOfMinute(tokenLen);</span>
<span class="fc" id="L512">                break;</span>
            case 'S': // fraction of second (number)
<span class="fc" id="L514">                builder.appendFractionOfSecond(tokenLen, tokenLen);</span>
<span class="fc" id="L515">                break;</span>
            case 'e': // day of week (number)
<span class="fc" id="L517">                builder.appendDayOfWeek(tokenLen);</span>
<span class="fc" id="L518">                break;</span>
            case 'E': // dayOfWeek (text)
<span class="fc bfc" id="L520" title="All 2 branches covered.">                if (tokenLen &gt;= 4) {</span>
<span class="fc" id="L521">                    builder.appendDayOfWeekText();</span>
                } else {
<span class="fc" id="L523">                    builder.appendDayOfWeekShortText();</span>
                }
<span class="fc" id="L525">                break;</span>
            case 'D': // day of year (number)
<span class="fc" id="L527">                builder.appendDayOfYear(tokenLen);</span>
<span class="fc" id="L528">                break;</span>
            case 'w': // week of weekyear (number)
<span class="fc" id="L530">                builder.appendWeekOfWeekyear(tokenLen);</span>
<span class="fc" id="L531">                break;</span>
            case 'z': // time zone (text)
<span class="nc bnc" id="L533" title="All 2 branches missed.">                if (tokenLen &gt;= 4) {</span>
<span class="nc" id="L534">                    builder.appendTimeZoneName();</span>
                } else {
<span class="nc" id="L536">                    builder.appendTimeZoneShortName();</span>
                }
<span class="nc" id="L538">                break;</span>
            case 'Z': // time zone offset
<span class="fc bfc" id="L540" title="All 2 branches covered.">                if (tokenLen == 1) {</span>
<span class="fc" id="L541">                    builder.appendTimeZoneOffset(null, &quot;Z&quot;, false, 2, 2);</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                } else if (tokenLen == 2) {</span>
<span class="fc" id="L543">                    builder.appendTimeZoneOffset(null, &quot;Z&quot;, true, 2, 2);</span>
                } else {
<span class="fc" id="L545">                    builder.appendTimeZoneId();</span>
                }
<span class="fc" id="L547">                break;</span>
            case '\'': // literal text
<span class="fc" id="L549">                String sub = token.substring(1);</span>
<span class="fc bfc" id="L550" title="All 2 branches covered.">                if (sub.length() == 1) {</span>
<span class="fc" id="L551">                    builder.appendLiteral(sub.charAt(0));</span>
                } else {
                    // Create copy of sub since otherwise the temporary quoted
                    // string would still be referenced internally.
<span class="fc" id="L555">                    builder.appendLiteral(new String(sub));</span>
                }
<span class="fc" id="L557">                break;</span>
            default:
<span class="fc" id="L559">                throw new IllegalArgumentException</span>
                    (&quot;Illegal pattern component: &quot; + token);
            }
        }
<span class="fc" id="L563">    }</span>

    /**
     * Parses an individual token.
     * 
     * @param pattern  the pattern string
     * @param indexRef  a single element array, where the input is the start
     *  location and the output is the location after parsing the token
     * @return the parsed token
     */
    private static String parseToken(String pattern, int[] indexRef) {
<span class="fc" id="L574">        StringBuffer buf = new StringBuffer();</span>

<span class="fc" id="L576">        int i = indexRef[0];</span>
<span class="fc" id="L577">        int length = pattern.length();</span>

<span class="fc" id="L579">        char c = pattern.charAt(i);</span>
<span class="pc bpc" id="L580" title="1 of 8 branches missed.">        if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z') {</span>
            // Scan a run of the same character, which indicates a time
            // pattern.
<span class="fc" id="L583">            buf.append(c);</span>

<span class="fc bfc" id="L585" title="All 2 branches covered.">            while (i + 1 &lt; length) {</span>
<span class="fc" id="L586">                char peek = pattern.charAt(i + 1);</span>
<span class="fc bfc" id="L587" title="All 2 branches covered.">                if (peek == c) {</span>
<span class="fc" id="L588">                    buf.append(c);</span>
<span class="fc" id="L589">                    i++;</span>
                } else {
                    break;
                }
<span class="fc" id="L593">            }</span>
        } else {
            // This will identify token as text.
<span class="fc" id="L596">            buf.append('\'');</span>

<span class="fc" id="L598">            boolean inLiteral = false;</span>

<span class="fc bfc" id="L600" title="All 2 branches covered.">            for (; i &lt; length; i++) {</span>
<span class="fc" id="L601">                c = pattern.charAt(i);</span>
                
<span class="fc bfc" id="L603" title="All 2 branches covered.">                if (c == '\'') {</span>
<span class="pc bpc" id="L604" title="1 of 4 branches missed.">                    if (i + 1 &lt; length &amp;&amp; pattern.charAt(i + 1) == '\'') {</span>
                        // '' is treated as escaped '
<span class="fc" id="L606">                        i++;</span>
<span class="fc" id="L607">                        buf.append(c);</span>
                    } else {
<span class="fc bfc" id="L609" title="All 2 branches covered.">                        inLiteral = !inLiteral;</span>
                    }
<span class="pc bpc" id="L611" title="1 of 10 branches missed.">                } else if (!inLiteral &amp;&amp;</span>
                           (c &gt;= 'A' &amp;&amp; c &lt;= 'Z' || c &gt;= 'a' &amp;&amp; c &lt;= 'z')) {
<span class="fc" id="L613">                    i--;</span>
<span class="fc" id="L614">                    break;</span>
                } else {
<span class="fc" id="L616">                    buf.append(c);</span>
                }
            }
        }

<span class="fc" id="L621">        indexRef[0] = i;</span>
<span class="fc" id="L622">        return buf.toString();</span>
    }

    /**
     * Returns true if token should be parsed as a numeric field.
     * 
     * @param token  the token to parse
     * @return true if numeric field
     */
    private static boolean isNumericToken(String token) {
<span class="fc" id="L632">        int tokenLen = token.length();</span>
<span class="pc bpc" id="L633" title="1 of 2 branches missed.">        if (tokenLen &gt; 0) {</span>
<span class="fc" id="L634">            char c = token.charAt(0);</span>
<span class="fc bfc" id="L635" title="All 3 branches covered.">            switch (c) {</span>
            case 'c': // century (number)
            case 'C': // century of era (number)
            case 'x': // weekyear (number)
            case 'y': // year (number)
            case 'Y': // year of era (number)
            case 'd': // day of month (number)
            case 'h': // hour of day (number, 1..12)
            case 'H': // hour of day (number, 0..23)
            case 'm': // minute of hour (number)
            case 's': // second of minute (number)
            case 'S': // fraction of second (number)
            case 'e': // day of week (number)
            case 'D': // day of year (number)
            case 'F': // day of week in month (number)
            case 'w': // week of year (number)
            case 'W': // week of month (number)
            case 'k': // hour of day (1..24)
            case 'K': // hour of day (0..11)
<span class="fc" id="L654">                return true;</span>
            case 'M': // month of year (text and number)
<span class="pc bpc" id="L656" title="1 of 2 branches missed.">                if (tokenLen &lt;= 2) {</span>
<span class="fc" id="L657">                    return true;</span>
                }
            }
        }
            
<span class="fc" id="L662">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Select a format from a custom pattern.
     *
     * @param pattern  pattern specification
     * @throws IllegalArgumentException if the pattern is invalid
     * @see #appendPatternTo
     */
    private static DateTimeFormatter createFormatterForPattern(String pattern) {
<span class="fc bfc" id="L674" title="All 4 branches covered.">        if (pattern == null || pattern.length() == 0) {</span>
<span class="fc" id="L675">            throw new IllegalArgumentException(&quot;Invalid pattern specification&quot;);</span>
        }
<span class="fc" id="L677">        DateTimeFormatter formatter = null;</span>
<span class="fc" id="L678">        synchronized (cPatternedCache) {</span>
<span class="fc" id="L679">            formatter = cPatternedCache.get(pattern);</span>
<span class="fc bfc" id="L680" title="All 2 branches covered.">            if (formatter == null) {</span>
<span class="fc" id="L681">                DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();</span>
<span class="fc" id="L682">                parsePatternTo(builder, pattern);</span>
<span class="fc" id="L683">                formatter = builder.toFormatter();</span>

<span class="fc" id="L685">                cPatternedCache.put(pattern, formatter);</span>
            }
<span class="fc" id="L687">        }</span>
<span class="fc" id="L688">        return formatter;</span>
    }

    /**
     * Select a format from a two character style pattern. The first character
     * is the date style, and the second character is the time style. Specify a
     * character of 'S' for short style, 'M' for medium, 'L' for long, and 'F'
     * for full. A date or time may be ommitted by specifying a style character '-'.
     *
     * @param style  two characters from the set {&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;F&quot;, &quot;-&quot;}
     * @throws IllegalArgumentException if the style is invalid
     */
    private static DateTimeFormatter createFormatterForStyle(String style) {
<span class="fc bfc" id="L701" title="All 4 branches covered.">        if (style == null || style.length() != 2) {</span>
<span class="fc" id="L702">            throw new IllegalArgumentException(&quot;Invalid style specification: &quot; + style);</span>
        }
<span class="fc" id="L704">        int dateStyle = selectStyle(style.charAt(0));</span>
<span class="fc" id="L705">        int timeStyle = selectStyle(style.charAt(1));</span>
<span class="fc bfc" id="L706" title="All 4 branches covered.">        if (dateStyle == NONE &amp;&amp; timeStyle == NONE) {</span>
<span class="fc" id="L707">            throw new IllegalArgumentException(&quot;Style '--' is invalid&quot;);</span>
        }
<span class="fc" id="L709">        return createFormatterForStyleIndex(dateStyle, timeStyle);</span>
    }

    /**
     * Gets the formatter for the specified style.
     * 
     * @param dateStyle  the date style
     * @param timeStyle  the time style
     * @return the formatter
     */
    private static DateTimeFormatter createFormatterForStyleIndex(int dateStyle, int timeStyle) {
<span class="fc" id="L720">        int index = ((dateStyle &lt;&lt; 2) + dateStyle) + timeStyle;</span>
<span class="fc" id="L721">        DateTimeFormatter f = null;</span>
<span class="fc" id="L722">        synchronized (cStyleCache) {</span>
<span class="fc" id="L723">            f = cStyleCache[index];</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">            if (f == null) {</span>
<span class="fc" id="L725">                int type = DATETIME;</span>
<span class="fc bfc" id="L726" title="All 2 branches covered.">                if (dateStyle == NONE) {</span>
<span class="fc" id="L727">                    type = TIME;</span>
<span class="fc bfc" id="L728" title="All 2 branches covered.">                } else if (timeStyle == NONE) {</span>
<span class="fc" id="L729">                    type = DATE;</span>
                }
<span class="fc" id="L731">                StyleFormatter llf = new StyleFormatter(</span>
                        dateStyle, timeStyle, type);
<span class="fc" id="L733">                f = new DateTimeFormatter(llf, llf);</span>
<span class="fc" id="L734">                cStyleCache[index] = f;</span>
            }
<span class="fc" id="L736">        }</span>
<span class="fc" id="L737">        return f;</span>
    }

    /**
     * Gets the JDK style code from the Joda code.
     * 
     * @param ch  the Joda style code
     * @return the JDK style code
     */
    private static int selectStyle(char ch) {
<span class="fc bfc" id="L747" title="All 6 branches covered.">        switch (ch) {</span>
        case 'S':
<span class="fc" id="L749">            return SHORT;</span>
        case 'M':
<span class="fc" id="L751">            return MEDIUM;</span>
        case 'L':
<span class="fc" id="L753">            return LONG;</span>
        case 'F':
<span class="fc" id="L755">            return FULL;</span>
        case '-':
<span class="fc" id="L757">            return NONE;</span>
        default:
<span class="fc" id="L759">            throw new IllegalArgumentException(&quot;Invalid style character: &quot; + ch);</span>
        }
    }

    //-----------------------------------------------------------------------
    static class StyleFormatter
            implements DateTimePrinter, DateTimeParser {

<span class="fc" id="L767">        private static final Map&lt;String, DateTimeFormatter&gt; cCache = new HashMap&lt;String, DateTimeFormatter&gt;();  // manual sync</span>
        
        private final int iDateStyle;
        private final int iTimeStyle;
        private final int iType;

        StyleFormatter(int dateStyle, int timeStyle, int type) {
<span class="fc" id="L774">            super();</span>
<span class="fc" id="L775">            iDateStyle = dateStyle;</span>
<span class="fc" id="L776">            iTimeStyle = timeStyle;</span>
<span class="fc" id="L777">            iType = type;</span>
<span class="fc" id="L778">        }</span>

        public int estimatePrintedLength() {
<span class="fc" id="L781">            return 40;  // guess</span>
        }

        public void printTo(
                StringBuffer buf, long instant, Chronology chrono,
                int displayOffset, DateTimeZone displayZone, Locale locale) {
<span class="fc" id="L787">            DateTimePrinter p = getFormatter(locale).getPrinter();</span>
<span class="fc" id="L788">            p.printTo(buf, instant, chrono, displayOffset, displayZone, locale);</span>
<span class="fc" id="L789">        }</span>

        public void printTo(
                Writer out, long instant, Chronology chrono,
                int displayOffset, DateTimeZone displayZone, Locale locale) throws IOException {
<span class="nc" id="L794">            DateTimePrinter p = getFormatter(locale).getPrinter();</span>
<span class="nc" id="L795">            p.printTo(out, instant, chrono, displayOffset, displayZone, locale);</span>
<span class="nc" id="L796">        }</span>

        public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {
<span class="nc" id="L799">            DateTimePrinter p = getFormatter(locale).getPrinter();</span>
<span class="nc" id="L800">            p.printTo(buf, partial, locale);</span>
<span class="nc" id="L801">        }</span>

        public void printTo(Writer out, ReadablePartial partial, Locale locale) throws IOException {
<span class="nc" id="L804">            DateTimePrinter p = getFormatter(locale).getPrinter();</span>
<span class="nc" id="L805">            p.printTo(out, partial, locale);</span>
<span class="nc" id="L806">        }</span>

        public int estimateParsedLength() {
<span class="nc" id="L809">            return 40;  // guess</span>
        }

        public int parseInto(DateTimeParserBucket bucket, String text, int position) {
<span class="fc" id="L813">            DateTimeParser p = getFormatter(bucket.getLocale()).getParser();</span>
<span class="fc" id="L814">            return p.parseInto(bucket, text, position);</span>
        }

        private DateTimeFormatter getFormatter(Locale locale) {
<span class="fc bfc" id="L818" title="All 2 branches covered.">            locale = (locale == null ? Locale.getDefault() : locale);</span>
<span class="fc" id="L819">            String key = Integer.toString(iType + (iDateStyle &lt;&lt; 4) + (iTimeStyle &lt;&lt; 8)) + locale.toString();</span>
<span class="fc" id="L820">            DateTimeFormatter f = null;</span>
<span class="fc" id="L821">            synchronized (cCache) {</span>
<span class="fc" id="L822">                f = cCache.get(key);</span>
<span class="fc bfc" id="L823" title="All 2 branches covered.">                if (f == null) {</span>
<span class="fc" id="L824">                    String pattern = getPattern(locale);</span>
<span class="fc" id="L825">                    f = DateTimeFormat.forPattern(pattern);</span>
<span class="fc" id="L826">                    cCache.put(key, f);</span>
                }
<span class="fc" id="L828">            }</span>
<span class="fc" id="L829">            return f;</span>
        }

        String getPattern(Locale locale) {
<span class="fc" id="L833">            DateFormat f = null;</span>
<span class="pc bpc" id="L834" title="1 of 4 branches missed.">            switch (iType) {</span>
                case DATE:
<span class="fc" id="L836">                    f = DateFormat.getDateInstance(iDateStyle, locale);</span>
<span class="fc" id="L837">                    break;</span>
                case TIME:
<span class="fc" id="L839">                    f = DateFormat.getTimeInstance(iTimeStyle, locale);</span>
<span class="fc" id="L840">                    break;</span>
                case DATETIME:
<span class="fc" id="L842">                    f = DateFormat.getDateTimeInstance(iDateStyle, iTimeStyle, locale);</span>
                    break;
            }
<span class="pc bpc" id="L845" title="1 of 2 branches missed.">            if (f instanceof SimpleDateFormat == false) {</span>
<span class="nc" id="L846">                throw new IllegalArgumentException(&quot;No datetime pattern for locale: &quot; + locale);</span>
            }
<span class="fc" id="L848">            return ((SimpleDateFormat) f).toPattern();</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>