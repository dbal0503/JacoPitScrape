<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PeriodFormatterBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Joda time</a> &gt; <a href="index.source.html" class="el_package">org.joda.time.format</a> &gt; <span class="el_source">PeriodFormatterBuilder.java</span></div><h1>PeriodFormatterBuilder.java</h1><pre class="source lang-java linenums">/*
 *  Copyright 2001-2009 Stephen Colebourne
 *
 *  Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package org.joda.time.format;

import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Locale;
import java.util.TreeSet;

import org.joda.time.DateTimeConstants;
import org.joda.time.DurationFieldType;
import org.joda.time.PeriodType;
import org.joda.time.ReadWritablePeriod;
import org.joda.time.ReadablePeriod;

/**
 * Factory that creates complex instances of PeriodFormatter via method calls.
 * &lt;p&gt;
 * Period formatting is performed by the {@link PeriodFormatter} class.
 * Three classes provide factory methods to create formatters, and this is one.
 * The others are {@link PeriodFormat} and {@link ISOPeriodFormat}.
 * &lt;p&gt;
 * PeriodFormatterBuilder is used for constructing formatters which are then
 * used to print or parse. The formatters are built by appending specific fields
 * or other formatters to an instance of this builder.
 * &lt;p&gt;
 * For example, a formatter that prints years and months, like &quot;15 years and 8 months&quot;,
 * can be constructed as follows:
 * &lt;p&gt;
 * &lt;pre&gt;
 * PeriodFormatter yearsAndMonths = new PeriodFormatterBuilder()
 *     .printZeroAlways()
 *     .appendYears()
 *     .appendSuffix(&quot; year&quot;, &quot; years&quot;)
 *     .appendSeparator(&quot; and &quot;)
 *     .printZeroRarelyLast()
 *     .appendMonths()
 *     .appendSuffix(&quot; month&quot;, &quot; months&quot;)
 *     .toFormatter();
 * &lt;/pre&gt;
 * &lt;p&gt;
 * PeriodFormatterBuilder itself is mutable and not thread-safe, but the
 * formatters that it builds are thread-safe and immutable.
 *
 * @author Brian S O'Neill
 * @since 1.0
 * @see PeriodFormat
 */
public class PeriodFormatterBuilder {
    private static final int PRINT_ZERO_RARELY_FIRST = 1;
    private static final int PRINT_ZERO_RARELY_LAST = 2;
    private static final int PRINT_ZERO_IF_SUPPORTED = 3;
    private static final int PRINT_ZERO_ALWAYS = 4;
    private static final int PRINT_ZERO_NEVER = 5;
    
    private static final int YEARS = 0;
    private static final int MONTHS = 1;
    private static final int WEEKS = 2;
    private static final int DAYS = 3;
    private static final int HOURS = 4;
    private static final int MINUTES = 5;
    private static final int SECONDS = 6;
    private static final int MILLIS = 7;
    private static final int SECONDS_MILLIS = 8;
    private static final int SECONDS_OPTIONAL_MILLIS = 9;
    private static final int MAX_FIELD = SECONDS_OPTIONAL_MILLIS;

    private int iMinPrintedDigits;
    private int iPrintZeroSetting;
    private int iMaxParsedDigits;
    private boolean iRejectSignedValues;

    private PeriodFieldAffix iPrefix;

    // List of Printers and Parsers used to build a final formatter.
    private List&lt;Object&gt; iElementPairs;
    /** Set to true if the formatter is not a printer. */
    private boolean iNotPrinter;
    /** Set to true if the formatter is not a parser. */
    private boolean iNotParser;

    // Last PeriodFormatter appended of each field type.
    private FieldFormatter[] iFieldFormatters;

<span class="fc" id="L101">    public PeriodFormatterBuilder() {</span>
<span class="fc" id="L102">        clear();</span>
<span class="fc" id="L103">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Constructs a PeriodFormatter using all the appended elements.
     * &lt;p&gt;
     * This is the main method used by applications at the end of the build
     * process to create a usable formatter.
     * &lt;p&gt;
     * Subsequent changes to this builder do not affect the returned formatter.
     * &lt;p&gt;
     * The returned formatter may not support both printing and parsing.
     * The methods {@link PeriodFormatter#isPrinter()} and
     * {@link PeriodFormatter#isParser()} will help you determine the state
     * of the formatter.
     * 
     * @return the newly created formatter
     * @throws IllegalStateException if the builder can produce neither a printer nor a parser
     */
    public PeriodFormatter toFormatter() {
<span class="fc" id="L123">        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);</span>
<span class="fc" id="L124">        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();</span>
<span class="fc" id="L125">        return formatter;</span>
    }

    /**
     * Internal method to create a PeriodPrinter instance using all the
     * appended elements.
     * &lt;p&gt;
     * Most applications will not use this method.
     * If you want a printer in an application, call {@link #toFormatter()}
     * and just use the printing API.
     * &lt;p&gt;
     * Subsequent changes to this builder do not affect the returned printer.
     * 
     * @return the newly created printer, null if builder cannot create a printer
     */
    public PeriodPrinter toPrinter() {
<span class="fc bfc" id="L141" title="All 2 branches covered.">        if (iNotPrinter) {</span>
<span class="fc" id="L142">            return null;</span>
        }
<span class="fc" id="L144">        return toFormatter().getPrinter();</span>
    }

    /**
     * Internal method to create a PeriodParser instance using all the
     * appended elements.
     * &lt;p&gt;
     * Most applications will not use this method.
     * If you want a printer in an application, call {@link #toFormatter()}
     * and just use the printing API.
     * &lt;p&gt;
     * Subsequent changes to this builder do not affect the returned parser.
     * 
     * @return the newly created parser, null if builder cannot create a parser
     */
    public PeriodParser toParser() {
<span class="fc bfc" id="L160" title="All 2 branches covered.">        if (iNotParser) {</span>
<span class="fc" id="L161">            return null;</span>
        }
<span class="fc" id="L163">        return toFormatter().getParser();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Clears out all the appended elements, allowing this builder to be reused.
     */
    public void clear() {
<span class="fc" id="L171">        iMinPrintedDigits = 1;</span>
<span class="fc" id="L172">        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;</span>
<span class="fc" id="L173">        iMaxParsedDigits = 10;</span>
<span class="fc" id="L174">        iRejectSignedValues = false;</span>
<span class="fc" id="L175">        iPrefix = null;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">        if (iElementPairs == null) {</span>
<span class="fc" id="L177">            iElementPairs = new ArrayList&lt;Object&gt;();</span>
        } else {
<span class="fc" id="L179">            iElementPairs.clear();</span>
        }
<span class="fc" id="L181">        iNotPrinter = false;</span>
<span class="fc" id="L182">        iNotParser = false;</span>
<span class="fc" id="L183">        iFieldFormatters = new FieldFormatter[10];</span>
<span class="fc" id="L184">    }</span>

    /**
     * Appends another formatter.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder append(PeriodFormatter formatter) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (formatter == null) {</span>
<span class="nc" id="L193">            throw new IllegalArgumentException(&quot;No formatter supplied&quot;);</span>
        }
<span class="fc" id="L195">        clearPrefix();</span>
<span class="fc" id="L196">        append0(formatter.getPrinter(), formatter.getParser());</span>
<span class="fc" id="L197">        return this;</span>
    }

    /**
     * Appends a printer parser pair.
     * &lt;p&gt;
     * Either the printer or the parser may be null, in which case the builder will
     * be unable to produce a parser or printer repectively.
     *
     * @param printer  appends a printer to the builder, null if printing is not supported
     * @param parser  appends a parser to the builder, null if parsing is not supported
     * @return this PeriodFormatterBuilder
     * @throws IllegalArgumentException if both the printer and parser are null
     */
    public PeriodFormatterBuilder append(PeriodPrinter printer, PeriodParser parser) {
<span class="fc bfc" id="L212" title="All 4 branches covered.">        if (printer == null &amp;&amp; parser == null) {</span>
<span class="fc" id="L213">            throw new IllegalArgumentException(&quot;No printer or parser supplied&quot;);</span>
        }
<span class="fc" id="L215">        clearPrefix();</span>
<span class="fc" id="L216">        append0(printer, parser);</span>
<span class="fc" id="L217">        return this;</span>
    }

    /**
     * Instructs the printer to emit specific text, and the parser to expect it.
     * The parser is case-insensitive.
     *
     * @return this PeriodFormatterBuilder
     * @throws IllegalArgumentException if text is null
     */
    public PeriodFormatterBuilder appendLiteral(String text) {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (text == null) {</span>
<span class="nc" id="L229">            throw new IllegalArgumentException(&quot;Literal must not be null&quot;);</span>
        }
<span class="fc" id="L231">        clearPrefix();</span>
<span class="fc" id="L232">        Literal literal = new Literal(text);</span>
<span class="fc" id="L233">        append0(literal, literal);</span>
<span class="fc" id="L234">        return this;</span>
    }

    /**
     * Set the minimum digits printed for the next and following appended
     * fields. By default, the minimum digits printed is one. If the field value
     * is zero, it is not printed unless a printZero rule is applied.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder minimumPrintedDigits(int minDigits) {
<span class="fc" id="L245">        iMinPrintedDigits = minDigits;</span>
<span class="fc" id="L246">        return this;</span>
    }

    /**
     * Set the maximum digits parsed for the next and following appended
     * fields. By default, the maximum digits parsed is ten.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder maximumParsedDigits(int maxDigits) {
<span class="nc" id="L256">        iMaxParsedDigits = maxDigits;</span>
<span class="nc" id="L257">        return this;</span>
    }

    /**
     * Reject signed values when parsing the next and following appended fields.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder rejectSignedValues(boolean v) {
<span class="nc" id="L266">        iRejectSignedValues = v;</span>
<span class="nc" id="L267">        return this;</span>
    }

    /**
     * Never print zero values for the next and following appended fields,
     * unless no fields would be printed. If no fields are printed, the printer
     * forces the last &quot;printZeroRarely&quot; field to print a zero.
     * &lt;p&gt;
     * This field setting is the default.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder printZeroRarelyLast() {
<span class="fc" id="L280">        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;</span>
<span class="fc" id="L281">        return this;</span>
    }

    /**
     * Never print zero values for the next and following appended fields,
     * unless no fields would be printed. If no fields are printed, the printer
     * forces the first &quot;printZeroRarely&quot; field to print a zero.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder printZeroRarelyFirst() {
<span class="fc" id="L292">        iPrintZeroSetting = PRINT_ZERO_RARELY_FIRST;</span>
<span class="fc" id="L293">        return this;</span>
    }

    /**
     * Print zero values for the next and following appened fields only if the
     * period supports it.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder printZeroIfSupported() {
<span class="fc" id="L303">        iPrintZeroSetting = PRINT_ZERO_IF_SUPPORTED;</span>
<span class="fc" id="L304">        return this;</span>
    }

    /**
     * Always print zero values for the next and following appended fields,
     * even if the period doesn't support it. The parser requires values for
     * fields that always print zero.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder printZeroAlways() {
<span class="fc" id="L315">        iPrintZeroSetting = PRINT_ZERO_ALWAYS;</span>
<span class="fc" id="L316">        return this;</span>
    }

    /**
     * Never print zero values for the next and following appended fields,
     * unless no fields would be printed. If no fields are printed, the printer
     * forces the last &quot;printZeroRarely&quot; field to print a zero.
     * &lt;p&gt;
     * This field setting is the default.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder printZeroNever() {
<span class="fc" id="L329">        iPrintZeroSetting = PRINT_ZERO_NEVER;</span>
<span class="fc" id="L330">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Append a field prefix which applies only to the next appended field. If
     * the field is not printed, neither is the prefix.
     *
     * @param text text to print before field only if field is printed
     * @return this PeriodFormatterBuilder
     * @see #appendSuffix
     */
    public PeriodFormatterBuilder appendPrefix(String text) {
<span class="fc bfc" id="L343" title="All 2 branches covered.">        if (text == null) {</span>
<span class="fc" id="L344">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L346">        return appendPrefix(new SimpleAffix(text));</span>
    }

    /**
     * Append a field prefix which applies only to the next appended field. If
     * the field is not printed, neither is the prefix.
     * &lt;p&gt;
     * During parsing, the singular and plural versions are accepted whether
     * or not the actual value matches plurality.
     *
     * @param singularText text to print if field value is one
     * @param pluralText text to print if field value is not one
     * @return this PeriodFormatterBuilder
     * @see #appendSuffix
     */
    public PeriodFormatterBuilder appendPrefix(String singularText,
                                                 String pluralText) {
<span class="fc bfc" id="L363" title="All 4 branches covered.">        if (singularText == null || pluralText == null) {</span>
<span class="fc" id="L364">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L366">        return appendPrefix(new PluralAffix(singularText, pluralText));</span>
    }

    /**
     * Append a field prefix which applies only to the next appended field. If
     * the field is not printed, neither is the prefix.
     *
     * @param prefix custom prefix
     * @return this PeriodFormatterBuilder
     * @see #appendSuffix
     */
    private PeriodFormatterBuilder appendPrefix(PeriodFieldAffix prefix) {
<span class="pc bpc" id="L378" title="1 of 2 branches missed.">        if (prefix == null) {</span>
<span class="nc" id="L379">            throw new IllegalArgumentException();</span>
        }
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (iPrefix != null) {</span>
<span class="nc" id="L382">            prefix = new CompositeAffix(iPrefix, prefix);</span>
        }
<span class="fc" id="L384">        iPrefix = prefix;</span>
<span class="fc" id="L385">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Instruct the printer to emit an integer years field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendYears() {
<span class="fc" id="L398">        appendField(YEARS);</span>
<span class="fc" id="L399">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer months field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendMonths() {
<span class="fc" id="L411">        appendField(MONTHS);</span>
<span class="fc" id="L412">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer weeks field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendWeeks() {
<span class="fc" id="L424">        appendField(WEEKS);</span>
<span class="fc" id="L425">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer days field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendDays() {
<span class="fc" id="L437">        appendField(DAYS);</span>
<span class="fc" id="L438">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer hours field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendHours() {
<span class="fc" id="L450">        appendField(HOURS);</span>
<span class="fc" id="L451">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer minutes field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendMinutes() {
<span class="fc" id="L463">        appendField(MINUTES);</span>
<span class="fc" id="L464">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer seconds field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendSeconds() {
<span class="fc" id="L476">        appendField(SECONDS);</span>
<span class="fc" id="L477">        return this;</span>
    }

    /**
     * Instruct the printer to emit a combined seconds and millis field, if supported.
     * The millis will overflow into the seconds if necessary.
     * The millis are always output.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendSecondsWithMillis() {
<span class="fc" id="L488">        appendField(SECONDS_MILLIS);</span>
<span class="fc" id="L489">        return this;</span>
    }

    /**
     * Instruct the printer to emit a combined seconds and millis field, if supported.
     * The millis will overflow into the seconds if necessary.
     * The millis are only output if non-zero.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {
<span class="fc" id="L500">        appendField(SECONDS_OPTIONAL_MILLIS);</span>
<span class="fc" id="L501">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer millis field, if supported.
     * &lt;p&gt;
     * The number of printed and parsed digits can be controlled using
     * {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendMillis() {
<span class="fc" id="L513">        appendField(MILLIS);</span>
<span class="fc" id="L514">        return this;</span>
    }

    /**
     * Instruct the printer to emit an integer millis field, if supported.
     * &lt;p&gt;
     * The number of arsed digits can be controlled using {@link #maximumParsedDigits(int)}.
     *
     * @return this PeriodFormatterBuilder
     */
    public PeriodFormatterBuilder appendMillis3Digit() {
<span class="fc" id="L525">        appendField(7, 3);</span>
<span class="fc" id="L526">        return this;</span>
    }

    private void appendField(int type) {
<span class="fc" id="L530">        appendField(type, iMinPrintedDigits);</span>
<span class="fc" id="L531">    }</span>

    private void appendField(int type, int minPrinted) {
<span class="fc" id="L534">        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,</span>
            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);
<span class="fc" id="L536">        append0(field, field);</span>
<span class="fc" id="L537">        iFieldFormatters[type] = field;</span>
<span class="fc" id="L538">        iPrefix = null;</span>
<span class="fc" id="L539">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Append a field suffix which applies only to the last appended field. If
     * the field is not printed, neither is the suffix.
     *
     * @param text text to print after field only if field is printed
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if no field exists to append to
     * @see #appendPrefix
     */
    public PeriodFormatterBuilder appendSuffix(String text) {
<span class="fc bfc" id="L552" title="All 2 branches covered.">        if (text == null) {</span>
<span class="fc" id="L553">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L555">        return appendSuffix(new SimpleAffix(text));</span>
    }

    /**
     * Append a field suffix which applies only to the last appended field. If
     * the field is not printed, neither is the suffix.
     * &lt;p&gt;
     * During parsing, the singular and plural versions are accepted whether or
     * not the actual value matches plurality.
     *
     * @param singularText text to print if field value is one
     * @param pluralText text to print if field value is not one
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if no field exists to append to
     * @see #appendPrefix
     */
    public PeriodFormatterBuilder appendSuffix(String singularText,
                                               String pluralText) {
<span class="fc bfc" id="L573" title="All 4 branches covered.">        if (singularText == null || pluralText == null) {</span>
<span class="fc" id="L574">            throw new IllegalArgumentException();</span>
        }
<span class="fc" id="L576">        return appendSuffix(new PluralAffix(singularText, pluralText));</span>
    }

    /**
     * Append a field suffix which applies only to the last appended field. If
     * the field is not printed, neither is the suffix.
     *
     * @param suffix custom suffix
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if no field exists to append to
     * @see #appendPrefix
     */
    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {
        final Object originalPrinter;
        final Object originalParser;
<span class="fc bfc" id="L591" title="All 2 branches covered.">        if (iElementPairs.size() &gt; 0) {</span>
<span class="fc" id="L592">            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);</span>
<span class="fc" id="L593">            originalParser = iElementPairs.get(iElementPairs.size() - 1);</span>
        } else {
<span class="fc" id="L595">            originalPrinter = null;</span>
<span class="fc" id="L596">            originalParser = null;</span>
        }

<span class="pc bpc" id="L599" title="3 of 8 branches missed.">        if (originalPrinter == null || originalParser == null ||</span>
                originalPrinter != originalParser ||
                !(originalPrinter instanceof FieldFormatter)) {
<span class="fc" id="L602">            throw new IllegalStateException(&quot;No field to apply suffix to&quot;);</span>
        }

<span class="fc" id="L605">        clearPrefix();</span>
<span class="fc" id="L606">        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);</span>
<span class="fc" id="L607">        iElementPairs.set(iElementPairs.size() - 2, newField);</span>
<span class="fc" id="L608">        iElementPairs.set(iElementPairs.size() - 1, newField);</span>
<span class="fc" id="L609">        iFieldFormatters[newField.getFieldType()] = newField;</span>
        
<span class="fc" id="L611">        return this;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Append a separator, which is output if fields are printed both before
     * and after the separator.
     * &lt;p&gt;
     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;).appendHours()&lt;/code&gt;
     * will only output the comma if both the days and hours fields are output.
     * &lt;p&gt;
     * The text will be parsed case-insensitively.
     * &lt;p&gt;
     * Note: appending a separator discontinues any further work on the latest
     * appended field.
     *
     * @param text  the text to use as a separator
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if this separator follows a previous one
     */
    public PeriodFormatterBuilder appendSeparator(String text) {
<span class="fc" id="L632">        return appendSeparator(text, text, null, true, true);</span>
    }

    /**
     * Append a separator, which is output only if fields are printed after the separator.
     * &lt;p&gt;
     * For example,
     * &lt;code&gt;builder.appendDays().appendSeparatorIfFieldsAfter(&quot;,&quot;).appendHours()&lt;/code&gt;
     * will only output the comma if the hours fields is output.
     * &lt;p&gt;
     * The text will be parsed case-insensitively.
     * &lt;p&gt;
     * Note: appending a separator discontinues any further work on the latest
     * appended field.
     *
     * @param text  the text to use as a separator
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if this separator follows a previous one
     */
    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {
<span class="fc" id="L652">        return appendSeparator(text, text, null, false, true);</span>
    }

    /**
     * Append a separator, which is output only if fields are printed before the separator.
     * &lt;p&gt;
     * For example,
     * &lt;code&gt;builder.appendDays().appendSeparatorIfFieldsBefore(&quot;,&quot;).appendHours()&lt;/code&gt;
     * will only output the comma if the days fields is output.
     * &lt;p&gt;
     * The text will be parsed case-insensitively.
     * &lt;p&gt;
     * Note: appending a separator discontinues any further work on the latest
     * appended field.
     *
     * @param text  the text to use as a separator
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if this separator follows a previous one
     */
    public PeriodFormatterBuilder appendSeparatorIfFieldsBefore(String text) {
<span class="fc" id="L672">        return appendSeparator(text, text, null, true, false);</span>
    }

    /**
     * Append a separator, which is output if fields are printed both before
     * and after the separator.
     * &lt;p&gt;
     * This method changes the separator depending on whether it is the last separator
     * to be output.
     * &lt;p&gt;
     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendHours().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendMinutes()&lt;/code&gt;
     * will output '1,2&amp;3' if all three fields are output, '1&amp;2' if two fields are output
     * and '1' if just one field is output.
     * &lt;p&gt;
     * The text will be parsed case-insensitively.
     * &lt;p&gt;
     * Note: appending a separator discontinues any further work on the latest
     * appended field.
     *
     * @param text  the text to use as a separator
     * @param finalText  the text used used if this is the final separator to be printed
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if this separator follows a previous one
     */
    public PeriodFormatterBuilder appendSeparator(String text, String finalText) {
<span class="fc" id="L697">        return appendSeparator(text, finalText, null, true, true);</span>
    }

    /**
     * Append a separator, which is output if fields are printed both before
     * and after the separator.
     * &lt;p&gt;
     * This method changes the separator depending on whether it is the last separator
     * to be output.
     * &lt;p&gt;
     * For example, &lt;code&gt;builder.appendDays().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendHours().appendSeparator(&quot;,&quot;, &quot;&amp;&quot;).appendMinutes()&lt;/code&gt;
     * will output '1,2&amp;3' if all three fields are output, '1&amp;2' if two fields are output
     * and '1' if just one field is output.
     * &lt;p&gt;
     * The text will be parsed case-insensitively.
     * &lt;p&gt;
     * Note: appending a separator discontinues any further work on the latest
     * appended field.
     *
     * @param text  the text to use as a separator
     * @param finalText  the text used used if this is the final separator to be printed
     * @param variants  set of text values which are also acceptable when parsed
     * @return this PeriodFormatterBuilder
     * @throws IllegalStateException if this separator follows a previous one
     */
    public PeriodFormatterBuilder appendSeparator(String text, String finalText,
                                                  String[] variants) {
<span class="fc" id="L724">        return appendSeparator(text, finalText, variants, true, true);</span>
    }

    private PeriodFormatterBuilder appendSeparator(String text, String finalText,
                                                   String[] variants,
                                                   boolean useBefore, boolean useAfter) {
<span class="pc bpc" id="L730" title="2 of 4 branches missed.">        if (text == null || finalText == null) {</span>
<span class="nc" id="L731">            throw new IllegalArgumentException();</span>
        }

<span class="fc" id="L734">        clearPrefix();</span>
        
        // optimise zero formatter case
<span class="fc" id="L737">        List&lt;Object&gt; pairs = iElementPairs;</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">        if (pairs.size() == 0) {</span>
<span class="nc bnc" id="L739" title="All 4 branches missed.">            if (useAfter &amp;&amp; useBefore == false) {</span>
<span class="nc" id="L740">                Separator separator = new Separator(</span>
                        text, finalText, variants,
                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);
<span class="nc" id="L743">                append0(separator, separator);</span>
            }
<span class="nc" id="L745">            return this;</span>
        }
        
        // find the last separator added
        int i;
<span class="fc" id="L750">        Separator lastSeparator = null;</span>
<span class="fc bfc" id="L751" title="All 2 branches covered.">        for (i=pairs.size(); --i&gt;=0; ) {</span>
<span class="fc bfc" id="L752" title="All 2 branches covered.">            if (pairs.get(i) instanceof Separator) {</span>
<span class="fc" id="L753">                lastSeparator = (Separator) pairs.get(i);</span>
<span class="fc" id="L754">                pairs = pairs.subList(i + 1, pairs.size());</span>
<span class="fc" id="L755">                break;</span>
            }
<span class="fc" id="L757">            i--;  // element pairs</span>
        }
        
        // merge formatters
<span class="pc bpc" id="L761" title="1 of 4 branches missed.">        if (lastSeparator != null &amp;&amp; pairs.size() == 0) {</span>
<span class="nc" id="L762">            throw new IllegalStateException(&quot;Cannot have two adjacent separators&quot;);</span>
        } else {
<span class="fc" id="L764">            Object[] comp = createComposite(pairs);</span>
<span class="fc" id="L765">            pairs.clear();</span>
<span class="fc" id="L766">            Separator separator = new Separator(</span>
                    text, finalText, variants,
                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],
                    useBefore, useAfter);
<span class="fc" id="L770">            pairs.add(separator);</span>
<span class="fc" id="L771">            pairs.add(separator);</span>
        }
        
<span class="fc" id="L774">        return this;</span>
    }

    //-----------------------------------------------------------------------
    private void clearPrefix() throws IllegalStateException {
<span class="pc bpc" id="L779" title="1 of 2 branches missed.">        if (iPrefix != null) {</span>
<span class="nc" id="L780">            throw new IllegalStateException(&quot;Prefix not followed by field&quot;);</span>
        }
<span class="fc" id="L782">        iPrefix = null;</span>
<span class="fc" id="L783">    }</span>

    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {
<span class="fc" id="L786">        iElementPairs.add(printer);</span>
<span class="fc" id="L787">        iElementPairs.add(parser);</span>
<span class="fc bfc" id="L788" title="All 2 branches covered.">        iNotPrinter |= (printer == null);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">        iNotParser |= (parser == null);</span>
<span class="fc" id="L790">        return this;</span>
    }

    //-----------------------------------------------------------------------
    private static PeriodFormatter toFormatter(List&lt;Object&gt; elementPairs, boolean notPrinter, boolean notParser) {
<span class="fc bfc" id="L795" title="All 4 branches covered.">        if (notPrinter &amp;&amp; notParser) {</span>
<span class="fc" id="L796">            throw new IllegalStateException(&quot;Builder has created neither a printer nor a parser&quot;);</span>
        }
<span class="fc" id="L798">        int size = elementPairs.size();</span>
<span class="fc bfc" id="L799" title="All 4 branches covered.">        if (size &gt;= 2 &amp;&amp; elementPairs.get(0) instanceof Separator) {</span>
<span class="fc" id="L800">            Separator sep = (Separator) elementPairs.get(0);</span>
<span class="pc bpc" id="L801" title="1 of 4 branches missed.">            if (sep.iAfterParser == null &amp;&amp; sep.iAfterPrinter == null) {</span>
<span class="fc" id="L802">                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);</span>
<span class="fc" id="L803">                sep = sep.finish(f.getPrinter(), f.getParser());</span>
<span class="fc" id="L804">                return new PeriodFormatter(sep, sep);</span>
            }
        }
<span class="fc" id="L807">        Object[] comp = createComposite(elementPairs);</span>
<span class="fc bfc" id="L808" title="All 2 branches covered.">        if (notPrinter) {</span>
<span class="fc" id="L809">            return new PeriodFormatter(null, (PeriodParser) comp[1]);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        } else if (notParser) {</span>
<span class="fc" id="L811">            return new PeriodFormatter((PeriodPrinter) comp[0], null);</span>
        } else {
<span class="fc" id="L813">            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);</span>
        }
    }

    private static Object[] createComposite(List&lt;Object&gt; elementPairs) {
<span class="pc bpc" id="L818" title="1 of 3 branches missed.">        switch (elementPairs.size()) {</span>
            case 0:
<span class="fc" id="L820">                return new Object[] {Literal.EMPTY, Literal.EMPTY};</span>
            case 1:
<span class="nc" id="L822">                return new Object[] {elementPairs.get(0), elementPairs.get(1)};</span>
            default:
<span class="fc" id="L824">                Composite comp = new Composite(elementPairs);</span>
<span class="fc" id="L825">                return new Object[] {comp, comp};</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Defines a formatted field's prefix or suffix text.
     * This can be used for fields such as 'n hours' or 'nH' or 'Hour:n'.
     */
    static interface PeriodFieldAffix {
        int calculatePrintedLength(int value);
        
        void printTo(StringBuffer buf, int value);
        
        void printTo(Writer out, int value) throws IOException;
        
        /**
         * @return new position after parsing affix, or ~position of failure
         */
        int parse(String periodStr, int position);

        /**
         * @return position where affix starts, or original ~position if not found
         */
        int scan(String periodStr, int position);
    }

    //-----------------------------------------------------------------------
    /**
     * Implements an affix where the text does not vary by the amount.
     */
    static class SimpleAffix implements PeriodFieldAffix {
        private final String iText;

<span class="fc" id="L859">        SimpleAffix(String text) {</span>
<span class="fc" id="L860">            iText = text;</span>
<span class="fc" id="L861">        }</span>

        public int calculatePrintedLength(int value) {
<span class="fc" id="L864">            return iText.length();</span>
        }

        public void printTo(StringBuffer buf, int value) {
<span class="fc" id="L868">            buf.append(iText);</span>
<span class="fc" id="L869">        }</span>

        public void printTo(Writer out, int value) throws IOException {
<span class="fc" id="L872">            out.write(iText);</span>
<span class="fc" id="L873">        }</span>

        public int parse(String periodStr, int position) {
<span class="fc" id="L876">            String text = iText;</span>
<span class="fc" id="L877">            int textLength = text.length();</span>
<span class="pc bpc" id="L878" title="1 of 2 branches missed.">            if (periodStr.regionMatches(true, position, text, 0, textLength)) {</span>
<span class="fc" id="L879">                return position + textLength;</span>
            }
<span class="nc" id="L881">            return ~position;</span>
        }

        public int scan(String periodStr, final int position) {
<span class="fc" id="L885">            String text = iText;</span>
<span class="fc" id="L886">            int textLength = text.length();</span>
<span class="fc" id="L887">            int sourceLength = periodStr.length();</span>
            search:
<span class="pc bpc" id="L889" title="1 of 2 branches missed.">            for (int pos = position; pos &lt; sourceLength; pos++) {</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {</span>
<span class="fc" id="L891">                    return pos;</span>
                }
                // Only allow number characters to be skipped in search of suffix.
<span class="fc bfc" id="L894" title="All 2 branches covered.">                switch (periodStr.charAt(pos)) {</span>
                case '0': case '1': case '2': case '3': case '4':
                case '5': case '6': case '7': case '8': case '9':
                case '.': case ',': case '+': case '-':
<span class="fc" id="L898">                    break;</span>
                default:
<span class="fc" id="L900">                    break search;</span>
                }
            }
<span class="fc" id="L903">            return ~position;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Implements an affix where the text varies by the amount of the field.
     * Only singular (1) and plural (not 1) are supported.
     */
    static class PluralAffix implements PeriodFieldAffix {
        private final String iSingularText;
        private final String iPluralText;

<span class="fc" id="L916">        PluralAffix(String singularText, String pluralText) {</span>
<span class="fc" id="L917">            iSingularText = singularText;</span>
<span class="fc" id="L918">            iPluralText = pluralText;</span>
<span class="fc" id="L919">        }</span>

        public int calculatePrintedLength(int value) {
<span class="fc bfc" id="L922" title="All 2 branches covered.">            return (value == 1 ? iSingularText : iPluralText).length();</span>
        }

        public void printTo(StringBuffer buf, int value) {
<span class="fc bfc" id="L926" title="All 2 branches covered.">            buf.append(value == 1 ? iSingularText : iPluralText);</span>
<span class="fc" id="L927">        }</span>

        public void printTo(Writer out, int value) throws IOException {
<span class="nc bnc" id="L930" title="All 2 branches missed.">            out.write(value == 1 ? iSingularText : iPluralText);</span>
<span class="nc" id="L931">        }</span>

        public int parse(String periodStr, int position) {
<span class="fc" id="L934">            String text1 = iPluralText;</span>
<span class="fc" id="L935">            String text2 = iSingularText; </span>

<span class="pc bpc" id="L937" title="1 of 2 branches missed.">            if (text1.length() &lt; text2.length()) {</span>
                // Swap in order to match longer one first.
<span class="nc" id="L939">                String temp = text1;</span>
<span class="nc" id="L940">                text1 = text2;</span>
<span class="nc" id="L941">                text2 = temp;</span>
            }

<span class="fc" id="L944">            if (periodStr.regionMatches</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">                (true, position, text1, 0, text1.length())) {</span>
<span class="fc" id="L946">                return position + text1.length();</span>
            }
<span class="nc" id="L948">            if (periodStr.regionMatches</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">                (true, position, text2, 0, text2.length())) {</span>
<span class="nc" id="L950">                return position + text2.length();</span>
            }

<span class="nc" id="L953">            return ~position;</span>
        }

        public int scan(String periodStr, final int position) {
<span class="fc" id="L957">            String text1 = iPluralText;</span>
<span class="fc" id="L958">            String text2 = iSingularText; </span>

<span class="pc bpc" id="L960" title="1 of 2 branches missed.">            if (text1.length() &lt; text2.length()) {</span>
                // Swap in order to match longer one first.
<span class="nc" id="L962">                String temp = text1;</span>
<span class="nc" id="L963">                text1 = text2;</span>
<span class="nc" id="L964">                text2 = temp;</span>
            }

<span class="fc" id="L967">            int textLength1 = text1.length();</span>
<span class="fc" id="L968">            int textLength2 = text2.length();</span>

<span class="fc" id="L970">            int sourceLength = periodStr.length();</span>
<span class="fc bfc" id="L971" title="All 2 branches covered.">            for (int pos = position; pos &lt; sourceLength; pos++) {</span>
<span class="fc bfc" id="L972" title="All 2 branches covered.">                if (periodStr.regionMatches(true, pos, text1, 0, textLength1)) {</span>
<span class="fc" id="L973">                    return pos;</span>
                }
<span class="pc bpc" id="L975" title="1 of 2 branches missed.">                if (periodStr.regionMatches(true, pos, text2, 0, textLength2)) {</span>
<span class="nc" id="L976">                    return pos;</span>
                }
            }
<span class="fc" id="L979">            return ~position;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Builds a composite affix by merging two other affix implementations.
     */
    static class CompositeAffix implements PeriodFieldAffix {
        private final PeriodFieldAffix iLeft;
        private final PeriodFieldAffix iRight;

<span class="nc" id="L991">        CompositeAffix(PeriodFieldAffix left, PeriodFieldAffix right) {</span>
<span class="nc" id="L992">            iLeft = left;</span>
<span class="nc" id="L993">            iRight = right;</span>
<span class="nc" id="L994">        }</span>

        public int calculatePrintedLength(int value) {
<span class="nc" id="L997">            return iLeft.calculatePrintedLength(value)</span>
<span class="nc" id="L998">                + iRight.calculatePrintedLength(value);</span>
        }

        public void printTo(StringBuffer buf, int value) {
<span class="nc" id="L1002">            iLeft.printTo(buf, value);</span>
<span class="nc" id="L1003">            iRight.printTo(buf, value);</span>
<span class="nc" id="L1004">        }</span>

        public void printTo(Writer out, int value) throws IOException {
<span class="nc" id="L1007">            iLeft.printTo(out, value);</span>
<span class="nc" id="L1008">            iRight.printTo(out, value);</span>
<span class="nc" id="L1009">        }</span>

        public int parse(String periodStr, int position) {
<span class="nc" id="L1012">            position = iLeft.parse(periodStr, position);</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if (position &gt;= 0) {</span>
<span class="nc" id="L1014">                position = iRight.parse(periodStr, position);</span>
            }
<span class="nc" id="L1016">            return position;</span>
        }

        public int scan(String periodStr, final int position) {
<span class="nc" id="L1020">            int pos = iLeft.scan(periodStr, position);</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">            if (pos &gt;= 0) {</span>
<span class="nc" id="L1022">                return iRight.scan(periodStr, pos);</span>
            }
<span class="nc" id="L1024">            return ~position;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Formats the numeric value of a field, potentially with prefix/suffix.
     */
    static class FieldFormatter
            implements PeriodPrinter, PeriodParser {
        private final int iMinPrintedDigits;
        private final int iPrintZeroSetting;
        private final int iMaxParsedDigits;
        private final boolean iRejectSignedValues;
        
        /** The index of the field type, 0=year, etc. */
        private final int iFieldType;
        /**
         * The array of the latest formatter added for each type.
         * This is shared between all the field formatters in a formatter.
         */
        private final FieldFormatter[] iFieldFormatters;
        
        private final PeriodFieldAffix iPrefix;
        private final PeriodFieldAffix iSuffix;

        FieldFormatter(int minPrintedDigits, int printZeroSetting,
                       int maxParsedDigits, boolean rejectSignedValues,
                       int fieldType, FieldFormatter[] fieldFormatters,
<span class="fc" id="L1053">                       PeriodFieldAffix prefix, PeriodFieldAffix suffix) {</span>
<span class="fc" id="L1054">            iMinPrintedDigits = minPrintedDigits;</span>
<span class="fc" id="L1055">            iPrintZeroSetting = printZeroSetting;</span>
<span class="fc" id="L1056">            iMaxParsedDigits = maxParsedDigits;</span>
<span class="fc" id="L1057">            iRejectSignedValues = rejectSignedValues;</span>
<span class="fc" id="L1058">            iFieldType = fieldType;</span>
<span class="fc" id="L1059">            iFieldFormatters = fieldFormatters;</span>
<span class="fc" id="L1060">            iPrefix = prefix;</span>
<span class="fc" id="L1061">            iSuffix = suffix;</span>
<span class="fc" id="L1062">        }</span>

<span class="fc" id="L1064">        FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {</span>
<span class="fc" id="L1065">            iMinPrintedDigits = field.iMinPrintedDigits;</span>
<span class="fc" id="L1066">            iPrintZeroSetting = field.iPrintZeroSetting;</span>
<span class="fc" id="L1067">            iMaxParsedDigits = field.iMaxParsedDigits;</span>
<span class="fc" id="L1068">            iRejectSignedValues = field.iRejectSignedValues;</span>
<span class="fc" id="L1069">            iFieldType = field.iFieldType;</span>
<span class="fc" id="L1070">            iFieldFormatters = field.iFieldFormatters;</span>
<span class="fc" id="L1071">            iPrefix = field.iPrefix;</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">            if (field.iSuffix != null) {</span>
<span class="nc" id="L1073">                suffix = new CompositeAffix(field.iSuffix, suffix);</span>
            }
<span class="fc" id="L1075">            iSuffix = suffix;</span>
<span class="fc" id="L1076">        }</span>

        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<span class="pc bpc" id="L1079" title="1 of 2 branches missed.">            if (stopAt &lt;= 0) {</span>
<span class="nc" id="L1080">                return 0;</span>
            }
<span class="fc bfc" id="L1082" title="All 4 branches covered.">            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {</span>
<span class="fc" id="L1083">                return 1;</span>
            }
<span class="fc" id="L1085">            return 0;</span>
        }

        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<span class="fc" id="L1089">            long valueLong = getFieldValue(period);</span>
<span class="fc bfc" id="L1090" title="All 2 branches covered.">            if (valueLong == Long.MAX_VALUE) {</span>
<span class="fc" id="L1091">                return 0;</span>
            }

<span class="fc" id="L1094">            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);</span>
<span class="fc bfc" id="L1095" title="All 2 branches covered.">            if (iFieldType &gt;= SECONDS_MILLIS) {</span>
                // valueLong contains the seconds and millis fields
                // the minimum output is 0.000, which is 4 digits
<span class="fc" id="L1098">                sum = Math.max(sum, 4);</span>
                // plus one for the decimal point
<span class="fc" id="L1100">                sum++;</span>
<span class="fc bfc" id="L1101" title="All 2 branches covered.">                if (iFieldType == SECONDS_OPTIONAL_MILLIS &amp;&amp;</span>
<span class="fc bfc" id="L1102" title="All 2 branches covered.">                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {</span>
<span class="fc" id="L1103">                    sum -= 4; // remove three digits and decimal point</span>
                }
                // reset valueLong to refer to the seconds part for the prefic/suffix calculation
<span class="fc" id="L1106">                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;</span>
            }
<span class="fc" id="L1108">            int value = (int) valueLong;</span>

<span class="fc bfc" id="L1110" title="All 2 branches covered.">            if (iPrefix != null) {</span>
<span class="fc" id="L1111">                sum += iPrefix.calculatePrintedLength(value);</span>
            }
<span class="fc bfc" id="L1113" title="All 2 branches covered.">            if (iSuffix != null) {</span>
<span class="fc" id="L1114">                sum += iSuffix.calculatePrintedLength(value);</span>
            }

<span class="fc" id="L1117">            return sum;</span>
        }
        
        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<span class="fc" id="L1121">            long valueLong = getFieldValue(period);</span>
<span class="fc bfc" id="L1122" title="All 2 branches covered.">            if (valueLong == Long.MAX_VALUE) {</span>
<span class="fc" id="L1123">                return;</span>
            }
<span class="fc" id="L1125">            int value = (int) valueLong;</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">            if (iFieldType &gt;= SECONDS_MILLIS) {</span>
<span class="fc" id="L1127">                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);</span>
            }

<span class="fc bfc" id="L1130" title="All 2 branches covered.">            if (iPrefix != null) {</span>
<span class="fc" id="L1131">                iPrefix.printTo(buf, value);</span>
            }
<span class="fc" id="L1133">            int minDigits = iMinPrintedDigits;</span>
<span class="fc bfc" id="L1134" title="All 2 branches covered.">            if (minDigits &lt;= 1) {</span>
<span class="fc" id="L1135">                FormatUtils.appendUnpaddedInteger(buf, value);</span>
            } else {
<span class="fc" id="L1137">                FormatUtils.appendPaddedInteger(buf, value, minDigits);</span>
            }
<span class="fc bfc" id="L1139" title="All 2 branches covered.">            if (iFieldType &gt;= SECONDS_MILLIS) {</span>
<span class="fc" id="L1140">                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);</span>
<span class="fc bfc" id="L1141" title="All 4 branches covered.">                if (iFieldType == SECONDS_MILLIS || dp &gt; 0) {</span>
<span class="fc" id="L1142">                    buf.append('.');</span>
<span class="fc" id="L1143">                    FormatUtils.appendPaddedInteger(buf, dp, 3);</span>
                }
            }
<span class="fc bfc" id="L1146" title="All 2 branches covered.">            if (iSuffix != null) {</span>
<span class="fc" id="L1147">                iSuffix.printTo(buf, value);</span>
            }
<span class="fc" id="L1149">        }</span>

        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<span class="fc" id="L1152">            long valueLong = getFieldValue(period);</span>
<span class="pc bpc" id="L1153" title="1 of 2 branches missed.">            if (valueLong == Long.MAX_VALUE) {</span>
<span class="nc" id="L1154">                return;</span>
            }
<span class="fc" id="L1156">            int value = (int) valueLong;</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">            if (iFieldType &gt;= SECONDS_MILLIS) {</span>
<span class="fc" id="L1158">                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);</span>
            }

<span class="pc bpc" id="L1161" title="1 of 2 branches missed.">            if (iPrefix != null) {</span>
<span class="nc" id="L1162">                iPrefix.printTo(out, value);</span>
            }
<span class="fc" id="L1164">            int minDigits = iMinPrintedDigits;</span>
<span class="pc bpc" id="L1165" title="1 of 2 branches missed.">            if (minDigits &lt;= 1) {</span>
<span class="fc" id="L1166">                FormatUtils.writeUnpaddedInteger(out, value);</span>
            } else {
<span class="nc" id="L1168">                FormatUtils.writePaddedInteger(out, value, minDigits);</span>
            }
<span class="fc bfc" id="L1170" title="All 2 branches covered.">            if (iFieldType &gt;= SECONDS_MILLIS) {</span>
<span class="fc" id="L1171">                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);</span>
<span class="pc bpc" id="L1172" title="2 of 4 branches missed.">                if (iFieldType == SECONDS_MILLIS || dp &gt; 0) {</span>
<span class="fc" id="L1173">                    out.write('.');</span>
<span class="fc" id="L1174">                    FormatUtils.writePaddedInteger(out, dp, 3);</span>
                }
            }
<span class="pc bpc" id="L1177" title="1 of 2 branches missed.">            if (iSuffix != null) {</span>
<span class="fc" id="L1178">                iSuffix.printTo(out, value);</span>
            }
<span class="fc" id="L1180">        }</span>

        public int parseInto(
                ReadWritablePeriod period, String text, 
                int position, Locale locale) {

<span class="fc bfc" id="L1186" title="All 2 branches covered.">            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);</span>

            // Shortcut test.
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            if (position &gt;= text.length()) {</span>
<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">                return mustParse ? ~position : position;</span>
            }

<span class="pc bpc" id="L1193" title="1 of 2 branches missed.">            if (iPrefix != null) {</span>
<span class="nc" id="L1194">                position = iPrefix.parse(text, position);</span>
<span class="nc bnc" id="L1195" title="All 2 branches missed.">                if (position &gt;= 0) {</span>
                    // If prefix is found, then the parse must finish.
<span class="nc" id="L1197">                    mustParse = true;</span>
                } else {
                    // Prefix not found, so bail.
<span class="nc bnc" id="L1200" title="All 2 branches missed.">                    if (!mustParse) {</span>
                        // It's okay because parsing of this field is not
                        // required. Don't return an error. Fields down the
                        // chain can continue on, trying to parse.
<span class="nc" id="L1204">                        return ~position;</span>
                    }
<span class="nc" id="L1206">                    return position;</span>
                }
            }

<span class="fc" id="L1210">            int suffixPos = -1;</span>
<span class="fc bfc" id="L1211" title="All 4 branches covered.">            if (iSuffix != null &amp;&amp; !mustParse) {</span>
                // Pre-scan the suffix, to help determine if this field must be
                // parsed.
<span class="fc" id="L1214">                suffixPos = iSuffix.scan(text, position);</span>
<span class="fc bfc" id="L1215" title="All 2 branches covered.">                if (suffixPos &gt;= 0) {</span>
                    // If suffix is found, then parse must finish.
<span class="fc" id="L1217">                    mustParse = true;</span>
                } else {
                    // Suffix not found, so bail.
<span class="pc bpc" id="L1220" title="1 of 2 branches missed.">                    if (!mustParse) {</span>
                        // It's okay because parsing of this field is not
                        // required. Don't return an error. Fields down the
                        // chain can continue on, trying to parse.
<span class="fc" id="L1224">                        return ~suffixPos;</span>
                    }
<span class="nc" id="L1226">                    return suffixPos;</span>
                }
            }

<span class="pc bpc" id="L1230" title="1 of 4 branches missed.">            if (!mustParse &amp;&amp; !isSupported(period.getPeriodType(), iFieldType)) {</span>
                // If parsing is not required and the field is not supported,
                // exit gracefully so that another parser can continue on.
<span class="nc" id="L1233">                return position;</span>
            }

            int limit;
<span class="fc bfc" id="L1237" title="All 2 branches covered.">            if (suffixPos &gt; 0) {</span>
<span class="fc" id="L1238">                limit = Math.min(iMaxParsedDigits, suffixPos - position);</span>
            } else {
<span class="fc" id="L1240">                limit = Math.min(iMaxParsedDigits, text.length() - position);</span>
            }

            // validate input number
<span class="fc" id="L1244">            int length = 0;</span>
<span class="fc" id="L1245">            int fractPos = -1;</span>
<span class="fc" id="L1246">            boolean hasDigits = false;</span>
<span class="fc bfc" id="L1247" title="All 2 branches covered.">            while (length &lt; limit) {</span>
<span class="fc" id="L1248">                char c = text.charAt(position + length);</span>
                // leading sign
<span class="pc bpc" id="L1250" title="2 of 8 branches missed.">                if (length == 0 &amp;&amp; (c == '-' || c == '+') &amp;&amp; !iRejectSignedValues) {</span>
<span class="pc bpc" id="L1251" title="1 of 2 branches missed.">                    boolean negative = c == '-';</span>

                    // Next character must be a digit.
<span class="pc bpc" id="L1254" title="1 of 2 branches missed.">                    if (length + 1 &gt;= limit || </span>
<span class="pc bpc" id="L1255" title="2 of 4 branches missed.">                        (c = text.charAt(position + length + 1)) &lt; '0' || c &gt; '9')</span>
                    {
<span class="nc" id="L1257">                        break;</span>
                    }

<span class="pc bpc" id="L1260" title="1 of 2 branches missed.">                    if (negative) {</span>
<span class="fc" id="L1261">                        length++;</span>
                    } else {
                        // Skip the '+' for parseInt to succeed.
<span class="nc" id="L1264">                        position++;</span>
                    }
                    // Expand the limit to disregard the sign character.
<span class="fc" id="L1267">                    limit = Math.min(limit + 1, text.length() - position);</span>
<span class="fc" id="L1268">                    continue;</span>
                }
                // main number
<span class="fc bfc" id="L1271" title="All 4 branches covered.">                if (c &gt;= '0' &amp;&amp; c &lt;= '9') {</span>
<span class="fc" id="L1272">                    hasDigits = true;</span>
                } else {
<span class="pc bpc" id="L1274" title="3 of 8 branches missed.">                    if ((c == '.' || c == ',')</span>
                         &amp;&amp; (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {
<span class="pc bpc" id="L1276" title="1 of 2 branches missed.">                        if (fractPos &gt;= 0) {</span>
                            // can't have two decimals
<span class="nc" id="L1278">                            break;</span>
                        }
<span class="fc" id="L1280">                        fractPos = position + length + 1;</span>
                        // Expand the limit to disregard the decimal point.
<span class="fc" id="L1282">                        limit = Math.min(limit + 1, text.length() - position);</span>
                    } else {
                        break;
                    }
                }
<span class="fc" id="L1287">                length++;</span>
<span class="fc" id="L1288">            }</span>

<span class="fc bfc" id="L1290" title="All 2 branches covered.">            if (!hasDigits) {</span>
<span class="fc" id="L1291">                return ~position;</span>
            }

<span class="pc bpc" id="L1294" title="1 of 4 branches missed.">            if (suffixPos &gt;= 0 &amp;&amp; position + length != suffixPos) {</span>
                // If there are additional non-digit characters before the
                // suffix is reached, then assume that the suffix found belongs
                // to a field not yet reached. Return original position so that
                // another parser can continue on.
<span class="nc" id="L1299">                return position;</span>
            }

<span class="pc bpc" id="L1302" title="1 of 4 branches missed.">            if (iFieldType != SECONDS_MILLIS &amp;&amp; iFieldType != SECONDS_OPTIONAL_MILLIS) {</span>
                // Handle common case.
<span class="fc" id="L1304">                setFieldValue(period, iFieldType, parseInt(text, position, length));</span>
<span class="fc bfc" id="L1305" title="All 2 branches covered.">            } else if (fractPos &lt; 0) {</span>
<span class="fc" id="L1306">                setFieldValue(period, SECONDS, parseInt(text, position, length));</span>
<span class="fc" id="L1307">                setFieldValue(period, MILLIS, 0);</span>
            } else {
<span class="fc" id="L1309">                int wholeValue = parseInt(text, position, fractPos - position - 1);</span>
<span class="fc" id="L1310">                setFieldValue(period, SECONDS, wholeValue);</span>

<span class="fc" id="L1312">                int fractLen = position + length - fractPos;</span>
                int fractValue;
<span class="fc bfc" id="L1314" title="All 2 branches covered.">                if (fractLen &lt;= 0) {</span>
<span class="fc" id="L1315">                    fractValue = 0;</span>
                } else {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">                    if (fractLen &gt;= 3) {</span>
<span class="fc" id="L1318">                        fractValue = parseInt(text, fractPos, 3);</span>
                    } else {
<span class="nc" id="L1320">                        fractValue = parseInt(text, fractPos, fractLen);</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">                        if (fractLen == 1) {</span>
<span class="nc" id="L1322">                            fractValue *= 100;</span>
                        } else {
<span class="nc" id="L1324">                            fractValue *= 10;</span>
                        }
                    }
<span class="pc bpc" id="L1327" title="1 of 2 branches missed.">                    if (wholeValue &lt; 0) {</span>
<span class="nc" id="L1328">                        fractValue = -fractValue;</span>
                    }
                }

<span class="fc" id="L1332">                setFieldValue(period, MILLIS, fractValue);</span>
            }
                
<span class="fc" id="L1335">            position += length;</span>

<span class="pc bpc" id="L1337" title="1 of 4 branches missed.">            if (position &gt;= 0 &amp;&amp; iSuffix != null) {</span>
<span class="fc" id="L1338">                position = iSuffix.parse(text, position);</span>
            }
                
<span class="fc" id="L1341">            return position;</span>
        }

        /**
         * @param text text to parse
         * @param position position in text
         * @param length exact count of characters to parse
         * @return parsed int value
         */
        private int parseInt(String text, int position, int length) {
<span class="fc bfc" id="L1351" title="All 2 branches covered.">            if (length &gt;= 10) {</span>
                // Since value may exceed max, use stock parser which checks for this.
<span class="fc" id="L1353">                return Integer.parseInt(text.substring(position, position + length));</span>
            }
<span class="fc bfc" id="L1355" title="All 2 branches covered.">            if (length &lt;= 0) {</span>
<span class="fc" id="L1356">                return 0;</span>
            }
<span class="fc" id="L1358">            int value = text.charAt(position++);</span>
<span class="fc" id="L1359">            length--;</span>
            boolean negative;
<span class="fc bfc" id="L1361" title="All 2 branches covered.">            if (value == '-') {</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">                if (--length &lt; 0) {</span>
<span class="nc" id="L1363">                    return 0;</span>
                }
<span class="fc" id="L1365">                negative = true;</span>
<span class="fc" id="L1366">                value = text.charAt(position++);</span>
            } else {
<span class="fc" id="L1368">                negative = false;</span>
            }
<span class="fc" id="L1370">            value -= '0';</span>
<span class="fc bfc" id="L1371" title="All 2 branches covered.">            while (length-- &gt; 0) {</span>
<span class="fc" id="L1372">                value = ((value &lt;&lt; 3) + (value &lt;&lt; 1)) + text.charAt(position++) - '0';</span>
            }
<span class="fc bfc" id="L1374" title="All 2 branches covered.">            return negative ? -value : value;</span>
        }

        /**
         * @return Long.MAX_VALUE if nothing to print, otherwise value
         */
        long getFieldValue(ReadablePeriod period) {
            PeriodType type;
<span class="fc bfc" id="L1382" title="All 2 branches covered.">            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {</span>
<span class="fc" id="L1383">                type = null; // Don't need to check if supported.</span>
            } else {
<span class="fc" id="L1385">                type = period.getPeriodType();</span>
            }
<span class="fc bfc" id="L1387" title="All 4 branches covered.">            if (type != null &amp;&amp; isSupported(type, iFieldType) == false) {</span>
<span class="fc" id="L1388">                return Long.MAX_VALUE;</span>
            }

            long value;

<span class="pc bpc" id="L1393" title="1 of 10 branches missed.">            switch (iFieldType) {</span>
            default:
<span class="nc" id="L1395">                return Long.MAX_VALUE;</span>
            case YEARS:
<span class="fc" id="L1397">                value = period.get(DurationFieldType.years());</span>
<span class="fc" id="L1398">                break;</span>
            case MONTHS:
<span class="fc" id="L1400">                value = period.get(DurationFieldType.months());</span>
<span class="fc" id="L1401">                break;</span>
            case WEEKS:
<span class="fc" id="L1403">                value = period.get(DurationFieldType.weeks());</span>
<span class="fc" id="L1404">                break;</span>
            case DAYS:
<span class="fc" id="L1406">                value = period.get(DurationFieldType.days());</span>
<span class="fc" id="L1407">                break;</span>
            case HOURS:
<span class="fc" id="L1409">                value = period.get(DurationFieldType.hours());</span>
<span class="fc" id="L1410">                break;</span>
            case MINUTES:
<span class="fc" id="L1412">                value = period.get(DurationFieldType.minutes());</span>
<span class="fc" id="L1413">                break;</span>
            case SECONDS:
<span class="fc" id="L1415">                value = period.get(DurationFieldType.seconds());</span>
<span class="fc" id="L1416">                break;</span>
            case MILLIS:
<span class="fc" id="L1418">                value = period.get(DurationFieldType.millis());</span>
<span class="fc" id="L1419">                break;</span>
            case SECONDS_MILLIS: // drop through
            case SECONDS_OPTIONAL_MILLIS:
<span class="fc" id="L1422">                int seconds = period.get(DurationFieldType.seconds());</span>
<span class="fc" id="L1423">                int millis = period.get(DurationFieldType.millis());</span>
<span class="fc" id="L1424">                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;</span>
                break;
            }

            // determine if period is zero and this is the last field
<span class="fc bfc" id="L1429" title="All 2 branches covered.">            if (value == 0) {</span>
<span class="fc bfc" id="L1430" title="All 4 branches covered.">                switch (iPrintZeroSetting) {</span>
                case PRINT_ZERO_NEVER:
<span class="fc" id="L1432">                    return Long.MAX_VALUE;</span>
                case PRINT_ZERO_RARELY_LAST:
<span class="fc bfc" id="L1434" title="All 4 branches covered.">                    if (isZero(period) &amp;&amp; iFieldFormatters[iFieldType] == this) {</span>
<span class="fc bfc" id="L1435" title="All 2 branches covered.">                        for (int i = iFieldType + 1; i &lt;= MAX_FIELD; i++) {</span>
<span class="fc bfc" id="L1436" title="All 4 branches covered.">                            if (isSupported(type, i) &amp;&amp; iFieldFormatters[i] != null) {</span>
<span class="fc" id="L1437">                                return Long.MAX_VALUE;</span>
                            }
                        }
                    } else {
<span class="fc" id="L1441">                        return Long.MAX_VALUE;</span>
                    }
                    break;
                case PRINT_ZERO_RARELY_FIRST:
<span class="pc bpc" id="L1445" title="2 of 4 branches missed.">                    if (isZero(period) &amp;&amp; iFieldFormatters[iFieldType] == this) {</span>
<span class="fc" id="L1446">                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK</span>
<span class="fc" id="L1447">                        i--;                              // see bug 1660490</span>
<span class="pc bpc" id="L1448" title="1 of 4 branches missed.">                        for (; i &gt;= 0 &amp;&amp; i &lt;= MAX_FIELD; i--) {</span>
<span class="fc bfc" id="L1449" title="All 4 branches covered.">                            if (isSupported(type, i) &amp;&amp; iFieldFormatters[i] != null) {</span>
<span class="fc" id="L1450">                                return Long.MAX_VALUE;</span>
                            }
                        }
<span class="fc" id="L1453">                    } else {</span>
<span class="nc" id="L1454">                        return Long.MAX_VALUE;</span>
                    }
                    break;
                }
            }

<span class="fc" id="L1460">            return value;</span>
        }

        boolean isZero(ReadablePeriod period) {
<span class="fc bfc" id="L1464" title="All 2 branches covered.">            for (int i = 0, isize = period.size(); i &lt; isize; i++) {</span>
<span class="fc bfc" id="L1465" title="All 2 branches covered.">                if (period.getValue(i) != 0) {</span>
<span class="fc" id="L1466">                    return false;</span>
                }
            }
<span class="fc" id="L1469">            return true;</span>
        }

        boolean isSupported(PeriodType type, int field) {
<span class="pc bpc" id="L1473" title="1 of 10 branches missed.">            switch (field) {</span>
            default:
<span class="nc" id="L1475">                return false;</span>
            case YEARS:
<span class="fc" id="L1477">                return type.isSupported(DurationFieldType.years());</span>
            case MONTHS:
<span class="fc" id="L1479">                return type.isSupported(DurationFieldType.months());</span>
            case WEEKS:
<span class="fc" id="L1481">                return type.isSupported(DurationFieldType.weeks());</span>
            case DAYS:
<span class="fc" id="L1483">                return type.isSupported(DurationFieldType.days());</span>
            case HOURS:
<span class="fc" id="L1485">                return type.isSupported(DurationFieldType.hours());</span>
            case MINUTES:
<span class="fc" id="L1487">                return type.isSupported(DurationFieldType.minutes());</span>
            case SECONDS:
<span class="fc" id="L1489">                return type.isSupported(DurationFieldType.seconds());</span>
            case MILLIS:
<span class="fc" id="L1491">                return type.isSupported(DurationFieldType.millis());</span>
            case SECONDS_MILLIS: // drop through
            case SECONDS_OPTIONAL_MILLIS:
<span class="fc bfc" id="L1494" title="All 2 branches covered.">                return type.isSupported(DurationFieldType.seconds()) ||</span>
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">                       type.isSupported(DurationFieldType.millis());</span>
            }
        }

        void setFieldValue(ReadWritablePeriod period, int field, int value) {
<span class="pc bpc" id="L1500" title="1 of 9 branches missed.">            switch (field) {</span>
            default:
<span class="nc" id="L1502">                break;</span>
            case YEARS:
<span class="fc" id="L1504">                period.setYears(value);</span>
<span class="fc" id="L1505">                break;</span>
            case MONTHS:
<span class="fc" id="L1507">                period.setMonths(value);</span>
<span class="fc" id="L1508">                break;</span>
            case WEEKS:
<span class="fc" id="L1510">                period.setWeeks(value);</span>
<span class="fc" id="L1511">                break;</span>
            case DAYS:
<span class="fc" id="L1513">                period.setDays(value);</span>
<span class="fc" id="L1514">                break;</span>
            case HOURS:
<span class="fc" id="L1516">                period.setHours(value);</span>
<span class="fc" id="L1517">                break;</span>
            case MINUTES:
<span class="fc" id="L1519">                period.setMinutes(value);</span>
<span class="fc" id="L1520">                break;</span>
            case SECONDS:
<span class="fc" id="L1522">                period.setSeconds(value);</span>
<span class="fc" id="L1523">                break;</span>
            case MILLIS:
<span class="fc" id="L1525">                period.setMillis(value);</span>
                break;
            }
<span class="fc" id="L1528">        }</span>

        int getFieldType() {
<span class="fc" id="L1531">            return iFieldType;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Handles a simple literal piece of text.
     */
    static class Literal
            implements PeriodPrinter, PeriodParser {
<span class="fc" id="L1541">        static final Literal EMPTY = new Literal(&quot;&quot;);</span>
        private final String iText;

<span class="fc" id="L1544">        Literal(String text) {</span>
<span class="fc" id="L1545">            iText = text;</span>
<span class="fc" id="L1546">        }</span>

        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<span class="fc" id="L1549">            return 0;</span>
        }

        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<span class="fc" id="L1553">            return iText.length();</span>
        }

        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<span class="fc" id="L1557">            buf.append(iText);</span>
<span class="fc" id="L1558">        }</span>

        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<span class="fc" id="L1561">            out.write(iText);</span>
<span class="fc" id="L1562">        }</span>

        public int parseInto(
                ReadWritablePeriod period, String periodStr,
                int position, Locale locale) {
<span class="fc bfc" id="L1567" title="All 2 branches covered.">            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {</span>
<span class="fc" id="L1568">                return position + iText.length();</span>
            }
<span class="fc" id="L1570">            return ~position;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Handles a separator, that splits the fields into multiple parts.
     * For example, the 'T' in the ISO8601 standard.
     */
    static class Separator
            implements PeriodPrinter, PeriodParser {
        private final String iText;
        private final String iFinalText;
        private final String[] iParsedForms;

        private final boolean iUseBefore;
        private final boolean iUseAfter;

        private final PeriodPrinter iBeforePrinter;
        private volatile PeriodPrinter iAfterPrinter;
        private final PeriodParser iBeforeParser;
        private volatile PeriodParser iAfterParser;

        Separator(String text, String finalText, String[] variants,
                PeriodPrinter beforePrinter, PeriodParser beforeParser,
<span class="fc" id="L1595">                boolean useBefore, boolean useAfter) {</span>
<span class="fc" id="L1596">            iText = text;</span>
<span class="fc" id="L1597">            iFinalText = finalText;</span>

<span class="pc bpc" id="L1599" title="4 of 8 branches missed.">            if ((finalText == null || text.equals(finalText)) &amp;&amp;</span>
                (variants == null || variants.length == 0)) {

<span class="fc" id="L1602">                iParsedForms = new String[] {text};</span>
            } else {
                // Filter and reverse sort the parsed forms.
<span class="fc" id="L1605">                TreeSet&lt;String&gt; parsedSet = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</span>
<span class="fc" id="L1606">                parsedSet.add(text);</span>
<span class="fc" id="L1607">                parsedSet.add(finalText);</span>
<span class="fc bfc" id="L1608" title="All 2 branches covered.">                if (variants != null) {</span>
<span class="fc bfc" id="L1609" title="All 2 branches covered.">                    for (int i=variants.length; --i&gt;=0; ) {</span>
<span class="fc" id="L1610">                        parsedSet.add(variants[i]);</span>
                    }
                }
<span class="fc" id="L1613">                ArrayList&lt;String&gt; parsedList = new ArrayList&lt;String&gt;(parsedSet);</span>
<span class="fc" id="L1614">                Collections.reverse(parsedList);</span>
<span class="fc" id="L1615">                iParsedForms = parsedList.toArray(new String[parsedList.size()]);</span>
            }

<span class="fc" id="L1618">            iBeforePrinter = beforePrinter;</span>
<span class="fc" id="L1619">            iBeforeParser = beforeParser;</span>
<span class="fc" id="L1620">            iUseBefore = useBefore;</span>
<span class="fc" id="L1621">            iUseAfter = useAfter;</span>
<span class="fc" id="L1622">        }</span>

        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<span class="fc" id="L1625">            int sum = iBeforePrinter.countFieldsToPrint(period, stopAt, locale);</span>
<span class="fc bfc" id="L1626" title="All 2 branches covered.">            if (sum &lt; stopAt) {</span>
<span class="fc" id="L1627">                sum += iAfterPrinter.countFieldsToPrint(period, stopAt, locale);</span>
            }
<span class="fc" id="L1629">            return sum;</span>
        }

        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<span class="fc" id="L1633">            PeriodPrinter before = iBeforePrinter;</span>
<span class="fc" id="L1634">            PeriodPrinter after = iAfterPrinter;</span>
            
<span class="fc" id="L1636">            int sum = before.calculatePrintedLength(period, locale)</span>
<span class="fc" id="L1637">                    + after.calculatePrintedLength(period, locale);</span>
            
<span class="fc bfc" id="L1639" title="All 2 branches covered.">            if (iUseBefore) {</span>
<span class="fc bfc" id="L1640" title="All 2 branches covered.">                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="fc bfc" id="L1641" title="All 2 branches covered.">                    if (iUseAfter) {</span>
<span class="fc" id="L1642">                        int afterCount = after.countFieldsToPrint(period, 2, locale);</span>
<span class="fc bfc" id="L1643" title="All 2 branches covered.">                        if (afterCount &gt; 0) {</span>
<span class="fc bfc" id="L1644" title="All 2 branches covered.">                            sum += (afterCount &gt; 1 ? iText : iFinalText).length();</span>
                        }
<span class="fc" id="L1646">                    } else {</span>
<span class="fc" id="L1647">                        sum += iText.length();</span>
                    }
                }
<span class="pc bpc" id="L1650" title="1 of 4 branches missed.">            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="fc" id="L1651">                sum += iText.length();</span>
            }
            
<span class="fc" id="L1654">            return sum;</span>
        }

        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<span class="fc" id="L1658">            PeriodPrinter before = iBeforePrinter;</span>
<span class="fc" id="L1659">            PeriodPrinter after = iAfterPrinter;</span>
            
<span class="fc" id="L1661">            before.printTo(buf, period, locale);</span>
<span class="fc bfc" id="L1662" title="All 2 branches covered.">            if (iUseBefore) {</span>
<span class="fc bfc" id="L1663" title="All 2 branches covered.">                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="fc bfc" id="L1664" title="All 2 branches covered.">                    if (iUseAfter) {</span>
<span class="fc" id="L1665">                        int afterCount = after.countFieldsToPrint(period, 2, locale);</span>
<span class="fc bfc" id="L1666" title="All 2 branches covered.">                        if (afterCount &gt; 0) {</span>
<span class="fc bfc" id="L1667" title="All 2 branches covered.">                            buf.append(afterCount &gt; 1 ? iText : iFinalText);</span>
                        }
<span class="fc" id="L1669">                    } else {</span>
<span class="fc" id="L1670">                        buf.append(iText);</span>
                    }
                }
<span class="pc bpc" id="L1673" title="1 of 4 branches missed.">            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="fc" id="L1674">                buf.append(iText);</span>
            }
<span class="fc" id="L1676">            after.printTo(buf, period, locale);</span>
<span class="fc" id="L1677">        }</span>

        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<span class="fc" id="L1680">            PeriodPrinter before = iBeforePrinter;</span>
<span class="fc" id="L1681">            PeriodPrinter after = iAfterPrinter;</span>
            
<span class="fc" id="L1683">            before.printTo(out, period, locale);</span>
<span class="pc bpc" id="L1684" title="1 of 2 branches missed.">            if (iUseBefore) {</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">                if (before.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">                    if (iUseAfter) {</span>
<span class="nc" id="L1687">                        int afterCount = after.countFieldsToPrint(period, 2, locale);</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">                        if (afterCount &gt; 0) {</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">                            out.write(afterCount &gt; 1 ? iText : iFinalText);</span>
                        }
<span class="nc" id="L1691">                    } else {</span>
<span class="nc" id="L1692">                        out.write(iText);</span>
                    }
                }
<span class="pc bpc" id="L1695" title="2 of 4 branches missed.">            } else if (iUseAfter &amp;&amp; after.countFieldsToPrint(period, 1, locale) &gt; 0) {</span>
<span class="fc" id="L1696">                out.write(iText);</span>
            }
<span class="fc" id="L1698">            after.printTo(out, period, locale);</span>
<span class="fc" id="L1699">        }</span>

        public int parseInto(
                ReadWritablePeriod period, String periodStr,
                int position, Locale locale) {
<span class="fc" id="L1704">            int oldPos = position;</span>
<span class="fc" id="L1705">            position = iBeforeParser.parseInto(period, periodStr, position, locale);</span>

<span class="fc bfc" id="L1707" title="All 2 branches covered.">            if (position &lt; 0) {</span>
<span class="fc" id="L1708">                return position;</span>
            }

<span class="fc" id="L1711">            boolean found = false;</span>
<span class="fc bfc" id="L1712" title="All 2 branches covered.">            if (position &gt; oldPos) {</span>
                // Consume this separator.
<span class="fc" id="L1714">                String[] parsedForms = iParsedForms;</span>
<span class="fc" id="L1715">                int length = parsedForms.length;</span>
<span class="fc bfc" id="L1716" title="All 2 branches covered.">                for (int i=0; i &lt; length; i++) {</span>
<span class="fc" id="L1717">                    String parsedForm = parsedForms[i];</span>
<span class="pc bpc" id="L1718" title="2 of 4 branches missed.">                    if ((parsedForm == null || parsedForm.length() == 0) ||</span>
                        periodStr.regionMatches
<span class="fc bfc" id="L1720" title="All 2 branches covered.">                        (true, position, parsedForm, 0, parsedForm.length())) {</span>
                        
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">                        position += (parsedForm == null ? 0 : parsedForm.length());</span>
<span class="fc" id="L1723">                        found = true;</span>
<span class="fc" id="L1724">                        break;</span>
                    }
                }
            }

<span class="fc" id="L1729">            oldPos = position;</span>
<span class="fc" id="L1730">            position = iAfterParser.parseInto(period, periodStr, position, locale);</span>

<span class="fc bfc" id="L1732" title="All 2 branches covered.">            if (position &lt; 0) {</span>
<span class="fc" id="L1733">                return position;</span>
            }

<span class="pc bpc" id="L1736" title="1 of 4 branches missed.">            if (found &amp;&amp; position == oldPos) {</span>
                // Separator should not have been supplied.
<span class="nc" id="L1738">                return ~oldPos;</span>
            }

<span class="fc bfc" id="L1741" title="All 6 branches covered.">            if (position &gt; oldPos &amp;&amp; !found &amp;&amp; !iUseBefore) {</span>
                // Separator was required.
<span class="fc" id="L1743">                return ~oldPos;</span>
            }

<span class="fc" id="L1746">            return position;</span>
        }

        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {
<span class="fc" id="L1750">            iAfterPrinter = afterPrinter;</span>
<span class="fc" id="L1751">            iAfterParser = afterParser;</span>
<span class="fc" id="L1752">            return this;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * Composite implementation that merges other fields to create a full pattern.
     */
    static class Composite
            implements PeriodPrinter, PeriodParser {
        
        private final PeriodPrinter[] iPrinters;
        private final PeriodParser[] iParsers;

<span class="fc" id="L1766">        Composite(List&lt;Object&gt; elementPairs) {</span>
<span class="fc" id="L1767">            List&lt;Object&gt; printerList = new ArrayList&lt;Object&gt;();</span>
<span class="fc" id="L1768">            List&lt;Object&gt; parserList = new ArrayList&lt;Object&gt;();</span>

<span class="fc" id="L1770">            decompose(elementPairs, printerList, parserList);</span>

<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">            if (printerList.size() &lt;= 0) {</span>
<span class="nc" id="L1773">                iPrinters = null;</span>
            } else {
<span class="fc" id="L1775">                iPrinters = printerList.toArray(</span>
<span class="fc" id="L1776">                        new PeriodPrinter[printerList.size()]);</span>
            }

<span class="pc bpc" id="L1779" title="1 of 2 branches missed.">            if (parserList.size() &lt;= 0) {</span>
<span class="nc" id="L1780">                iParsers = null;</span>
            } else {
<span class="fc" id="L1782">                iParsers = parserList.toArray(</span>
<span class="fc" id="L1783">                        new PeriodParser[parserList.size()]);</span>
            }
<span class="fc" id="L1785">        }</span>

        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {
<span class="fc" id="L1788">            int sum = 0;</span>
<span class="fc" id="L1789">            PeriodPrinter[] printers = iPrinters;</span>
<span class="fc bfc" id="L1790" title="All 4 branches covered.">            for (int i=printers.length; sum &lt; stopAt &amp;&amp; --i&gt;=0; ) {</span>
<span class="fc" id="L1791">                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);</span>
            }
<span class="fc" id="L1793">            return sum;</span>
        }

        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {
<span class="fc" id="L1797">            int sum = 0;</span>
<span class="fc" id="L1798">            PeriodPrinter[] printers = iPrinters;</span>
<span class="fc bfc" id="L1799" title="All 2 branches covered.">            for (int i=printers.length; --i&gt;=0; ) {</span>
<span class="fc" id="L1800">                sum += printers[i].calculatePrintedLength(period, locale);</span>
            }
<span class="fc" id="L1802">            return sum;</span>
        }

        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {
<span class="fc" id="L1806">            PeriodPrinter[] printers = iPrinters;</span>
<span class="fc" id="L1807">            int len = printers.length;</span>
<span class="fc bfc" id="L1808" title="All 2 branches covered.">            for (int i=0; i&lt;len; i++) {</span>
<span class="fc" id="L1809">                printers[i].printTo(buf, period, locale);</span>
            }
<span class="fc" id="L1811">        }</span>

        public void printTo(Writer out, ReadablePeriod period, Locale locale) throws IOException {
<span class="fc" id="L1814">            PeriodPrinter[] printers = iPrinters;</span>
<span class="fc" id="L1815">            int len = printers.length;</span>
<span class="fc bfc" id="L1816" title="All 2 branches covered.">            for (int i=0; i&lt;len; i++) {</span>
<span class="fc" id="L1817">                printers[i].printTo(out, period, locale);</span>
            }
<span class="fc" id="L1819">        }</span>

        public int parseInto(
                ReadWritablePeriod period, String periodStr,
                int position, Locale locale) {
<span class="fc" id="L1824">            PeriodParser[] parsers = iParsers;</span>
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">            if (parsers == null) {</span>
<span class="nc" id="L1826">                throw new UnsupportedOperationException();</span>
            }

<span class="fc" id="L1829">            int len = parsers.length;</span>
<span class="fc bfc" id="L1830" title="All 4 branches covered.">            for (int i=0; i&lt;len &amp;&amp; position &gt;= 0; i++) {</span>
<span class="fc" id="L1831">                position = parsers[i].parseInto(period, periodStr, position, locale);</span>
            }
<span class="fc" id="L1833">            return position;</span>
        }

        private void decompose(List&lt;Object&gt; elementPairs, List&lt;Object&gt; printerList, List&lt;Object&gt; parserList) {
<span class="fc" id="L1837">            int size = elementPairs.size();</span>
<span class="fc bfc" id="L1838" title="All 2 branches covered.">            for (int i=0; i&lt;size; i+=2) {</span>
<span class="fc" id="L1839">                Object element = elementPairs.get(i);</span>
<span class="fc bfc" id="L1840" title="All 2 branches covered.">                if (element instanceof PeriodPrinter) {</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">                    if (element instanceof Composite) {</span>
<span class="fc" id="L1842">                        addArrayToList(printerList, ((Composite) element).iPrinters);</span>
                    } else {
<span class="fc" id="L1844">                        printerList.add(element);</span>
                    }
                }

<span class="fc" id="L1848">                element = elementPairs.get(i + 1);</span>
<span class="fc bfc" id="L1849" title="All 2 branches covered.">                if (element instanceof PeriodParser) {</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">                    if (element instanceof Composite) {</span>
<span class="fc" id="L1851">                        addArrayToList(parserList, ((Composite) element).iParsers);</span>
                    } else {
<span class="fc" id="L1853">                        parserList.add(element);</span>
                    }
                }
            }
<span class="fc" id="L1857">        }</span>

        private void addArrayToList(List&lt;Object&gt; list, Object[] array) {
<span class="pc bpc" id="L1860" title="1 of 2 branches missed.">            if (array != null) {</span>
<span class="fc bfc" id="L1861" title="All 2 branches covered.">                for (int i=0; i&lt;array.length; i++) {</span>
<span class="fc" id="L1862">                    list.add(array[i]);</span>
                }
            }
<span class="fc" id="L1865">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>