<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StrSubstitutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang.text</a> &gt; <span class="el_source">StrSubstitutor.java</span></div><h1>StrSubstitutor.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang.text;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Substitutes variables within a string by values.
 * &lt;p&gt;
 * This class takes a piece of text and substitutes all the variables within it.
 * The default definition of a variable is &lt;code&gt;${variableName}&lt;/code&gt;.
 * The prefix and suffix can be changed via constructors and set methods.
 * &lt;p&gt;
 * Variable values are typically resolved from a map, but could also be resolved
 * from system properties, or by supplying a custom variable resolver.
 * &lt;p&gt;
 * The simplest example is to use this class to replace Java System properties. For example:
 * &lt;pre&gt;
 * StrSubstitutor.replaceSystemProperties(
 *      &quot;You are running with java.version = ${java.version} and os.name = ${os.name}.&quot;);
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Typical usage of this class follows the following pattern: First an instance is created
 * and initialized with the map that contains the values for the available variables.
 * If a prefix and/or suffix for variables should be used other than the default ones,
 * the appropriate settings can be performed. After that the &lt;code&gt;replace()&lt;/code&gt;
 * method can be called passing in the source text for interpolation. In the returned
 * text all variable references (as long as their values are known) will be resolved.
 * The following example demonstrates this:
 * &lt;pre&gt;
 * Map valuesMap = HashMap();
 * valuesMap.put(&amp;quot;animal&amp;quot;, &amp;quot;quick brown fox&amp;quot;);
 * valuesMap.put(&amp;quot;target&amp;quot;, &amp;quot;lazy dog&amp;quot;);
 * String templateString = &amp;quot;The ${animal} jumped over the ${target}.&amp;quot;;
 * StrSubstitutor sub = new StrSubstitutor(valuesMap);
 * String resolvedString = sub.replace(templateString);
 * &lt;/pre&gt;
 * yielding:
 * &lt;pre&gt;
 *      The quick brown fox jumped over the lazy dog.
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In addition to this usage pattern there are some static convenience methods that
 * cover the most common use cases. These methods can be used without the need of
 * manually creating an instance. However if multiple replace operations are to be
 * performed, creating and reusing an instance of this class will be more efficient.
 * &lt;p&gt;
 * Variable replacement works in a recursive way. Thus, if a variable value contains
 * a variable then that variable will also be replaced. Cyclic replacements are
 * detected and will cause an exception to be thrown.
 * &lt;p&gt;
 * Sometimes the interpolation's result must contain a variable prefix. As an example
 * take the following source text:
 * &lt;pre&gt;
 *   The variable ${${name}} must be used.
 * &lt;/pre&gt;
 * Here only the variable's name refered to in the text should be replaced resulting
 * in the text (assuming that the value of the &lt;code&gt;name&lt;/code&gt; variable is &lt;code&gt;x&lt;/code&gt;):
 * &lt;pre&gt;
 *   The variable ${x} must be used.
 * &lt;/pre&gt;
 * To achieve this effect there are two possibilities: Either set a different prefix
 * and suffix for variables which do not conflict with the result text you want to
 * produce. The other possibility is to use the escape character, by default '$'.
 * If this character is placed before a variable reference, this reference is ignored
 * and won't be replaced. For example:
 * &lt;pre&gt;
 *   The variable $${${name}} must be used.
 * &lt;/pre&gt;
 *
 * @author Oliver Heger
 * @author Stephen Colebourne
 * @version $Id$
 * @since 2.2
 */
public class StrSubstitutor {

    /**
     * Constant for the default escape character.
     */
    public static final char DEFAULT_ESCAPE = '$';
    /**
     * Constant for the default variable prefix.
     */
<span class="fc" id="L101">    public static final StrMatcher DEFAULT_PREFIX = StrMatcher.stringMatcher(&quot;${&quot;);</span>
    /**
     * Constant for the default variable suffix.
     */
<span class="fc" id="L105">    public static final StrMatcher DEFAULT_SUFFIX = StrMatcher.stringMatcher(&quot;}&quot;);</span>

    /**
     * Stores the escape character.
     */
    private char escapeChar;
    /**
     * Stores the variable prefix.
     */
    private StrMatcher prefixMatcher;
    /**
     * Stores the variable suffix.
     */
    private StrMatcher suffixMatcher;
    /**
     * Variable resolution is delegated to an implementor of VariableResolver.
     */
    private StrLookup variableResolver;

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables in the given source object with
     * their matching values from the map.
     *
     * @param source  the source text containing the variables to substitute, null returns null
     * @param valueMap  the map with the values, may be null
     * @return the result of the replace operation
     */
    public static &lt;V&gt; String replace(Object source, Map&lt;String, V&gt; valueMap) {
<span class="fc" id="L134">        return new StrSubstitutor(valueMap).replace(source);</span>
    }

    /**
     * Replaces all the occurrences of variables in the given source object with
     * their matching values from the map. This method allows to specifiy a
     * custom variable prefix and suffix
     *
     * @param source  the source text containing the variables to substitute, null returns null
     * @param valueMap  the map with the values, may be null
     * @param prefix  the prefix of variables, not null
     * @param suffix  the suffix of variables, not null
     * @return the result of the replace operation
     * @throws IllegalArgumentException if the prefix or suffix is null
     */
    public static &lt;V&gt; String replace(Object source, Map&lt;String, V&gt; valueMap, String prefix, String suffix) {
<span class="fc" id="L150">        return new StrSubstitutor(valueMap, prefix, suffix).replace(source);</span>
    }

    /**
     * Replaces all the occurrences of variables in the given source object with
     * their matching values from the system properties.
     *
     * @param source  the source text containing the variables to substitute, null returns null
     * @return the result of the replace operation
     */
    public static String replaceSystemProperties(Object source) {
<span class="fc" id="L161">        return new StrSubstitutor(StrLookup.systemPropertiesLookup()).replace(source);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a new instance with defaults for variable prefix and suffix
     * and the escaping character.
     */
    public StrSubstitutor() {
<span class="fc" id="L170">        this((StrLookup) null, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L171">    }</span>

    /**
     * Creates a new instance and initializes it. Uses defaults for variable
     * prefix and suffix and the escaping character.
     *
     * @param valueMap  the map with the variables' values, may be null
     */
    public &lt;V&gt; StrSubstitutor(Map&lt;String, V&gt; valueMap) {
<span class="fc" id="L180">        this(StrLookup.mapLookup(valueMap), DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L181">    }</span>

    /**
     * Creates a new instance and initializes it. Uses a default escaping character.
     *
     * @param valueMap  the map with the variables' values, may be null
     * @param prefix  the prefix for variables, not null
     * @param suffix  the suffix for variables, not null
     * @throws IllegalArgumentException if the prefix or suffix is null
     */
    public &lt;V&gt; StrSubstitutor(Map&lt;String, V&gt; valueMap, String prefix, String suffix) {
<span class="fc" id="L192">        this(StrLookup.mapLookup(valueMap), prefix, suffix, DEFAULT_ESCAPE);</span>
<span class="fc" id="L193">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param valueMap  the map with the variables' values, may be null
     * @param prefix  the prefix for variables, not null
     * @param suffix  the suffix for variables, not null
     * @param escape  the escape character
     * @throws IllegalArgumentException if the prefix or suffix is null
     */
    public &lt;V&gt; StrSubstitutor(Map&lt;String, V&gt; valueMap, String prefix, String suffix, char escape) {
<span class="fc" id="L205">        this(StrLookup.mapLookup(valueMap), prefix, suffix, escape);</span>
<span class="fc" id="L206">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver  the variable resolver, may be null
     */
    public StrSubstitutor(StrLookup variableResolver) {
<span class="fc" id="L214">        this(variableResolver, DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ESCAPE);</span>
<span class="fc" id="L215">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver  the variable resolver, may be null
     * @param prefix  the prefix for variables, not null
     * @param suffix  the suffix for variables, not null
     * @param escape  the escape character
     * @throws IllegalArgumentException if the prefix or suffix is null
     */
<span class="fc" id="L226">    public StrSubstitutor(StrLookup variableResolver, String prefix, String suffix, char escape) {</span>
<span class="fc" id="L227">        this.setVariableResolver(variableResolver);</span>
<span class="fc" id="L228">        this.setVariablePrefix(prefix);</span>
<span class="fc" id="L229">        this.setVariableSuffix(suffix);</span>
<span class="fc" id="L230">        this.setEscapeChar(escape);</span>
<span class="fc" id="L231">    }</span>

    /**
     * Creates a new instance and initializes it.
     *
     * @param variableResolver  the variable resolver, may be null
     * @param prefixMatcher  the prefix for variables, not null
     * @param suffixMatcher  the suffix for variables, not null
     * @param escape  the escape character
     * @throws IllegalArgumentException if the prefix or suffix is null
     */
    public StrSubstitutor(
<span class="fc" id="L243">            StrLookup variableResolver, StrMatcher prefixMatcher, StrMatcher suffixMatcher, char escape) {</span>
<span class="fc" id="L244">        this.setVariableResolver(variableResolver);</span>
<span class="fc" id="L245">        this.setVariablePrefixMatcher(prefixMatcher);</span>
<span class="fc" id="L246">        this.setVariableSuffixMatcher(suffixMatcher);</span>
<span class="fc" id="L247">        this.setEscapeChar(escape);</span>
<span class="fc" id="L248">    }</span>

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source string as a template.
     *
     * @param source  the string to replace in, null returns null
     * @return the result of the replace operation
     */
    public String replace(String source) {
<span class="fc bfc" id="L259" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L260">            return null;</span>
        }
<span class="fc" id="L262">        StrBuilder buf = new StrBuilder(source);</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">        if (substitute(buf, 0, source.length()) == false) {</span>
<span class="fc" id="L264">            return source;</span>
        }
<span class="fc" id="L266">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source string as a template.
     * &lt;p&gt;
     * Only the specified portion of the string will be processed.
     * The rest of the string is not processed, and is not returned.
     *
     * @param source  the string to replace in, null returns null
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the array to be processed, must be valid
     * @return the result of the replace operation
     */
    public String replace(String source, int offset, int length) {
<span class="fc bfc" id="L282" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L283">            return null;</span>
        }
<span class="fc" id="L285">        StrBuilder buf = new StrBuilder(length).append(source, offset, length);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (substitute(buf, 0, length) == false) {</span>
<span class="fc" id="L287">            return source.substring(offset, offset + length);</span>
        }
<span class="fc" id="L289">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source array as a template.
     * The array is not altered by this method.
     *
     * @param source  the character array to replace in, not altered, null returns null
     * @return the result of the replace operation
     */
    public String replace(char[] source) {
<span class="fc bfc" id="L302" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L303">            return null;</span>
        }
<span class="fc" id="L305">        StrBuilder buf = new StrBuilder(source.length).append(source);</span>
<span class="fc" id="L306">        substitute(buf, 0, source.length);</span>
<span class="fc" id="L307">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source array as a template.
     * The array is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the array will be processed.
     * The rest of the array is not processed, and is not returned.
     *
     * @param source  the character array to replace in, not altered, null returns null
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the array to be processed, must be valid
     * @return the result of the replace operation
     */
    public String replace(char[] source, int offset, int length) {
<span class="fc bfc" id="L324" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L325">            return null;</span>
        }
<span class="fc" id="L327">        StrBuilder buf = new StrBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L328">        substitute(buf, 0, length);</span>
<span class="fc" id="L329">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source buffer as a template.
     * The buffer is not altered by this method.
     *
     * @param source  the buffer to use as a template, not changed, null returns null
     * @return the result of the replace operation
     */
    public String replace(StringBuffer source) {
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L343">            return null;</span>
        }
<span class="fc" id="L345">        StrBuilder buf = new StrBuilder(source.length()).append(source);</span>
<span class="fc" id="L346">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L347">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source buffer as a template.
     * The buffer is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed.
     * The rest of the buffer is not processed, and is not returned.
     *
     * @param source  the buffer to use as a template, not changed, null returns null
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the array to be processed, must be valid
     * @return the result of the replace operation
     */
    public String replace(StringBuffer source, int offset, int length) {
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L365">            return null;</span>
        }
<span class="fc" id="L367">        StrBuilder buf = new StrBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L368">        substitute(buf, 0, length);</span>
<span class="fc" id="L369">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source builder as a template.
     * The builder is not altered by this method.
     *
     * @param source  the builder to use as a template, not changed, null returns null
     * @return the result of the replace operation
     */
    public String replace(StrBuilder source) {
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L383">            return null;</span>
        }
<span class="fc" id="L385">        StrBuilder buf = new StrBuilder(source.length()).append(source);</span>
<span class="fc" id="L386">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L387">        return buf.toString();</span>
    }

    /**
     * Replaces all the occurrences of variables with their matching values
     * from the resolver using the given source builder as a template.
     * The builder is not altered by this method.
     * &lt;p&gt;
     * Only the specified portion of the builder will be processed.
     * The rest of the builder is not processed, and is not returned.
     *
     * @param source  the builder to use as a template, not changed, null returns null
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the array to be processed, must be valid
     * @return the result of the replace operation
     */
    public String replace(StrBuilder source, int offset, int length) {
<span class="fc bfc" id="L404" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L405">            return null;</span>
        }
<span class="fc" id="L407">        StrBuilder buf = new StrBuilder(length).append(source, offset, length);</span>
<span class="fc" id="L408">        substitute(buf, 0, length);</span>
<span class="fc" id="L409">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables in the given source object with
     * their matching values from the resolver. The input source object is
     * converted to a string using &lt;code&gt;toString&lt;/code&gt; and is not altered.
     *
     * @param source  the source to replace in, null returns null
     * @return the result of the replace operation
     */
    public String replace(Object source) {
<span class="fc bfc" id="L422" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L423">            return null;</span>
        }
<span class="fc" id="L425">        StrBuilder buf = new StrBuilder().append(source);</span>
<span class="fc" id="L426">        substitute(buf, 0, buf.length());</span>
<span class="fc" id="L427">        return buf.toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables within the given source buffer
     * with their matching values from the resolver.
     * The buffer is updated with the result.
     *
     * @param source  the buffer to replace in, updated, null returns zero
     * @return true if altered
     */
    public boolean replaceIn(StringBuffer source) {
<span class="fc bfc" id="L440" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L441">            return false;</span>
        }
<span class="fc" id="L443">        return replaceIn(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables within the given source buffer
     * with their matching values from the resolver.
     * The buffer is updated with the result.
     * &lt;p&gt;
     * Only the specified portion of the buffer will be processed.
     * The rest of the buffer is not processed, but it is not deleted.
     *
     * @param source  the buffer to replace in, updated, null returns zero
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the buffer to be processed, must be valid
     * @return true if altered
     */
    public boolean replaceIn(StringBuffer source, int offset, int length) {
<span class="fc bfc" id="L460" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L461">            return false;</span>
        }
<span class="fc" id="L463">        StrBuilder buf = new StrBuilder(length).append(source, offset, length);</span>
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">        if (substitute(buf, 0, length) == false) {</span>
<span class="nc" id="L465">            return false;</span>
        }
<span class="fc" id="L467">        source.replace(offset, offset + length, buf.toString());</span>
<span class="fc" id="L468">        return true;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Replaces all the occurrences of variables within the given source
     * builder with their matching values from the resolver.
     *
     * @param source  the builder to replace in, updated, null returns zero
     * @return true if altered
     */
    public boolean replaceIn(StrBuilder source) {
<span class="fc bfc" id="L480" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L481">            return false;</span>
        }
<span class="fc" id="L483">        return substitute(source, 0, source.length());</span>
    }

    /**
     * Replaces all the occurrences of variables within the given source
     * builder with their matching values from the resolver.
     * &lt;p&gt;
     * Only the specified portion of the builder will be processed.
     * The rest of the builder is not processed, but it is not deleted.
     *
     * @param source  the builder to replace in, null returns zero
     * @param offset  the start offset within the array, must be valid
     * @param length  the length within the builder to be processed, must be valid
     * @return true if altered
     */
    public boolean replaceIn(StrBuilder source, int offset, int length) {
<span class="fc bfc" id="L499" title="All 2 branches covered.">        if (source == null) {</span>
<span class="fc" id="L500">            return false;</span>
        }
<span class="fc" id="L502">        return substitute(source, offset, length);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Internal method that substitutes the variables.
     * &lt;p&gt;
     * Most users of this class do not need to call this method. This method will
     * be called automatically by another (public) method.
     * &lt;p&gt;
     * Writers of subclasses can override this method if they need access to
     * the substitution process at the start or end.
     *
     * @param buf  the string builder to substitute into, not null
     * @param offset  the start offset within the builder, must be valid
     * @param length  the length within the builder to be processed, must be valid
     * @return true if altered
     */
    protected boolean substitute(StrBuilder buf, int offset, int length) {
<span class="fc bfc" id="L521" title="All 2 branches covered.">        return substitute(buf, offset, length, null) &gt; 0;</span>
    }

    /**
     * Recursive handler for multiple levels of interpolation. This is the main
     * interpolation method, which resolves the values of all variable references
     * contained in the passed in text.
     *
     * @param buf  the string builder to substitute into, not null
     * @param offset  the start offset within the builder, must be valid
     * @param length  the length within the builder to be processed, must be valid
     * @param priorVariables  the stack keeping track of the replaced variables, may be null
     * @return the length change that occurs, unless priorVariables is null when the int
     *  represents a boolean flag as to whether any change occurred.
     */
    private int substitute(StrBuilder buf, int offset, int length, List&lt;String&gt; priorVariables) {
<span class="fc" id="L537">        StrMatcher prefixMatcher = getVariablePrefixMatcher();</span>
<span class="fc" id="L538">        StrMatcher suffixMatcher = getVariableSuffixMatcher();</span>
<span class="fc" id="L539">        char escape = getEscapeChar();</span>
        
<span class="fc bfc" id="L541" title="All 2 branches covered.">        boolean top = (priorVariables == null);</span>
<span class="fc" id="L542">        boolean altered = false;</span>
<span class="fc" id="L543">        int lengthChange = 0;</span>
<span class="fc" id="L544">        char[] chars = buf.buffer;</span>
<span class="fc" id="L545">        int bufEnd = offset + length;</span>
<span class="fc" id="L546">        int pos = offset;</span>
<span class="fc bfc" id="L547" title="All 2 branches covered.">        while (pos &lt; bufEnd) {</span>
<span class="fc" id="L548">            int startMatchLen = prefixMatcher.isMatch(chars, pos, offset, bufEnd);</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (startMatchLen == 0) {</span>
<span class="fc" id="L550">                pos++;</span>
            } else {
                // found variable start marker
<span class="fc bfc" id="L553" title="All 4 branches covered.">                if (pos &gt; offset &amp;&amp; chars[pos - 1] == escape) {</span>
                    // escaped
<span class="fc" id="L555">                    buf.deleteCharAt(pos - 1);</span>
<span class="fc" id="L556">                    chars = buf.buffer;  // in case buffer was altered</span>
<span class="fc" id="L557">                    lengthChange--;</span>
<span class="fc" id="L558">                    altered = true;</span>
<span class="fc" id="L559">                    bufEnd--;</span>
                } else {
                    // find suffix
<span class="fc" id="L562">                    int startPos = pos;</span>
<span class="fc" id="L563">                    pos += startMatchLen;</span>
<span class="fc" id="L564">                    int endMatchLen = 0;</span>
<span class="fc bfc" id="L565" title="All 2 branches covered.">                    while (pos &lt; bufEnd) {</span>
<span class="fc" id="L566">                        endMatchLen = suffixMatcher.isMatch(chars, pos, offset, bufEnd);</span>
<span class="fc bfc" id="L567" title="All 2 branches covered.">                        if (endMatchLen == 0) {</span>
<span class="fc" id="L568">                            pos++;</span>
                        } else {
                            // found variable end marker
<span class="fc" id="L571">                            String varName = new String(chars, startPos + startMatchLen, </span>
                                                        pos - startPos - startMatchLen);
<span class="fc" id="L573">                            pos += endMatchLen;</span>
<span class="fc" id="L574">                            int endPos = pos;</span>
                            
                            // on the first call initialize priorVariables
<span class="fc bfc" id="L577" title="All 2 branches covered.">                            if (priorVariables == null) {</span>
<span class="fc" id="L578">                                priorVariables = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L579">                                priorVariables.add(new String(chars, offset, length));</span>
                            }
                            
                            // handle cyclic substitution
<span class="fc" id="L583">                            checkCyclicSubstitution(varName, priorVariables);</span>
<span class="fc" id="L584">                            priorVariables.add(varName);</span>
                            
                            // resolve the variable
<span class="fc" id="L587">                            String varValue = resolveVariable(varName, buf, startPos, endPos);</span>
<span class="fc bfc" id="L588" title="All 2 branches covered.">                            if (varValue != null) {</span>
                                // recursive replace
<span class="fc" id="L590">                                int varLen = varValue.length();</span>
<span class="fc" id="L591">                                buf.replace(startPos, endPos, varValue);</span>
<span class="fc" id="L592">                                altered = true;</span>
<span class="fc" id="L593">                                int change = substitute(buf, startPos, varLen, priorVariables);</span>
<span class="fc" id="L594">                                change = change + (varLen - (endPos - startPos));</span>
<span class="fc" id="L595">                                pos += change;</span>
<span class="fc" id="L596">                                bufEnd += change;</span>
<span class="fc" id="L597">                                lengthChange += change;</span>
<span class="fc" id="L598">                                chars = buf.buffer;  // in case buffer was altered</span>
                            }
                            
                            // remove variable from the cyclic stack
<span class="fc" id="L602">                            priorVariables.remove(priorVariables.size() - 1);</span>
<span class="fc" id="L603">                            break;</span>
                        }
                    }
                }
            }
<span class="fc" id="L608">        }</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">        if (top) {</span>
<span class="fc bfc" id="L610" title="All 2 branches covered.">            return (altered ? 1 : 0);</span>
        }
<span class="fc" id="L612">        return lengthChange;</span>
    }

    /**
     * Checks if the specified variable is already in the stack (list) of variables.
     *
     * @param varName  the variable name to check
     * @param priorVariables  the list of prior variables
     */
    private void checkCyclicSubstitution(String varName, List&lt;String&gt; priorVariables) {
<span class="fc bfc" id="L622" title="All 2 branches covered.">        if (priorVariables.contains(varName) == false) {</span>
<span class="fc" id="L623">            return;</span>
        }
<span class="fc" id="L625">        StrBuilder buf = new StrBuilder(256);</span>
<span class="fc" id="L626">        buf.append(&quot;Infinite loop in property interpolation of &quot;);</span>
<span class="fc" id="L627">        buf.append(priorVariables.remove(0));</span>
<span class="fc" id="L628">        buf.append(&quot;: &quot;);</span>
<span class="fc" id="L629">        buf.appendWithSeparators(priorVariables, &quot;-&gt;&quot;);</span>
<span class="fc" id="L630">        throw new IllegalStateException(buf.toString());</span>
    }

    /**
     * Internal method that resolves the value of a variable.
     * &lt;p&gt;
     * Most users of this class do not need to call this method. This method is
     * called automatically by the substitution process.
     * &lt;p&gt;
     * Writers of subclasses can override this method if they need to alter
     * how each substitution occurs. The method is passed the variable's name
     * and must return the corresponding value. This implementation uses the
     * {@link #getVariableResolver()} with the variable's name as the key.
     *
     * @param variableName  the name of the variable, not null
     * @param buf  the buffer where the substitution is occurring, not null
     * @param startPos  the start position of the variable including the prefix, valid
     * @param endPos  the end position of the variable including the suffix, valid
     * @return the variable's value or &lt;b&gt;null&lt;/b&gt; if the variable is unknown
     */
    protected String resolveVariable(String variableName, StrBuilder buf, int startPos, int endPos) {
<span class="fc" id="L651">        StrLookup resolver = getVariableResolver();</span>
<span class="fc bfc" id="L652" title="All 2 branches covered.">        if (resolver == null) {</span>
<span class="fc" id="L653">            return null;</span>
        }
<span class="fc" id="L655">        return resolver.lookup(variableName);</span>
    }

    // Escape
    //-----------------------------------------------------------------------
    /**
     * Returns the escape character.
     *
     * @return the character used for escaping variable references
     */
    public char getEscapeChar() {
<span class="fc" id="L666">        return this.escapeChar;</span>
    }

    /**
     * Sets the escape character.
     * If this character is placed before a variable reference in the source
     * text, this variable will be ignored.
     *
     * @param escapeCharacter  the escape character (0 for disabling escaping)
     */
    public void setEscapeChar(char escapeCharacter) {
<span class="fc" id="L677">        this.escapeChar = escapeCharacter;</span>
<span class="fc" id="L678">    }</span>

    // Prefix
    //-----------------------------------------------------------------------
    /**
     * Gets the variable prefix matcher currently in use.
     * &lt;p&gt;
     * The variable prefix is the characer or characters that identify the
     * start of a variable. This prefix is expressed in terms of a matcher
     * allowing advanced prefix matches.
     *
     * @return the prefix matcher in use
     */
    public StrMatcher getVariablePrefixMatcher() {
<span class="fc" id="L692">        return prefixMatcher;</span>
    }

    /**
     * Sets the variable prefix matcher currently in use.
     * &lt;p&gt;
     * The variable prefix is the characer or characters that identify the
     * start of a variable. This prefix is expressed in terms of a matcher
     * allowing advanced prefix matches.
     *
     * @param prefixMatcher  the prefix matcher to use, null ignored
     * @return this, to enable chaining
     * @throws IllegalArgumentException if the prefix matcher is null
     */
    public StrSubstitutor setVariablePrefixMatcher(StrMatcher prefixMatcher) {
<span class="fc bfc" id="L707" title="All 2 branches covered.">        if (prefixMatcher == null) {</span>
<span class="fc" id="L708">            throw new IllegalArgumentException(&quot;Variable prefix matcher must not be null!&quot;);</span>
        }
<span class="fc" id="L710">        this.prefixMatcher = prefixMatcher;</span>
<span class="fc" id="L711">        return this;</span>
    }

    /**
     * Sets the variable prefix to use.
     * &lt;p&gt;
     * The variable prefix is the characer or characters that identify the
     * start of a variable. This method allows a single character prefix to
     * be easily set.
     *
     * @param prefix  the prefix character to use
     * @return this, to enable chaining
     */
    public StrSubstitutor setVariablePrefix(char prefix) {
<span class="fc" id="L725">        return setVariablePrefixMatcher(StrMatcher.charMatcher(prefix));</span>
    }

    /**
     * Sets the variable prefix to use.
     * &lt;p&gt;
     * The variable prefix is the characer or characters that identify the
     * start of a variable. This method allows a string prefix to be easily set.
     *
     * @param prefix  the prefix for variables, not null
     * @return this, to enable chaining
     * @throws IllegalArgumentException if the prefix is null
     */
    public StrSubstitutor setVariablePrefix(String prefix) {
<span class="fc bfc" id="L739" title="All 2 branches covered.">       if (prefix == null) {</span>
<span class="fc" id="L740">            throw new IllegalArgumentException(&quot;Variable prefix must not be null!&quot;);</span>
        }
<span class="fc" id="L742">        return setVariablePrefixMatcher(StrMatcher.stringMatcher(prefix));</span>
    }

    // Suffix
    //-----------------------------------------------------------------------
    /**
     * Gets the variable suffix matcher currently in use.
     * &lt;p&gt;
     * The variable suffix is the characer or characters that identify the
     * end of a variable. This suffix is expressed in terms of a matcher
     * allowing advanced suffix matches.
     *
     * @return the suffix matcher in use
     */
    public StrMatcher getVariableSuffixMatcher() {
<span class="fc" id="L757">        return suffixMatcher;</span>
    }

    /**
     * Sets the variable suffix matcher currently in use.
     * &lt;p&gt;
     * The variable suffix is the characer or characters that identify the
     * end of a variable. This suffix is expressed in terms of a matcher
     * allowing advanced suffix matches.
     *
     * @param suffixMatcher  the suffix matcher to use, null ignored
     * @return this, to enable chaining
     * @throws IllegalArgumentException if the suffix matcher is null
     */
    public StrSubstitutor setVariableSuffixMatcher(StrMatcher suffixMatcher) {
<span class="fc bfc" id="L772" title="All 2 branches covered.">        if (suffixMatcher == null) {</span>
<span class="fc" id="L773">            throw new IllegalArgumentException(&quot;Variable suffix matcher must not be null!&quot;);</span>
        }
<span class="fc" id="L775">        this.suffixMatcher = suffixMatcher;</span>
<span class="fc" id="L776">        return this;</span>
    }

    /**
     * Sets the variable suffix to use.
     * &lt;p&gt;
     * The variable suffix is the characer or characters that identify the
     * end of a variable. This method allows a single character suffix to
     * be easily set.
     *
     * @param suffix  the suffix character to use
     * @return this, to enable chaining
     */
    public StrSubstitutor setVariableSuffix(char suffix) {
<span class="fc" id="L790">        return setVariableSuffixMatcher(StrMatcher.charMatcher(suffix));</span>
    }

    /**
     * Sets the variable suffix to use.
     * &lt;p&gt;
     * The variable suffix is the characer or characters that identify the
     * end of a variable. This method allows a string suffix to be easily set.
     *
     * @param suffix  the suffix for variables, not null
     * @return this, to enable chaining
     * @throws IllegalArgumentException if the suffix is null
     */
    public StrSubstitutor setVariableSuffix(String suffix) {
<span class="fc bfc" id="L804" title="All 2 branches covered.">       if (suffix == null) {</span>
<span class="fc" id="L805">            throw new IllegalArgumentException(&quot;Variable suffix must not be null!&quot;);</span>
        }
<span class="fc" id="L807">        return setVariableSuffixMatcher(StrMatcher.stringMatcher(suffix));</span>
    }

    // Resolver
    //-----------------------------------------------------------------------
    /**
     * Gets the VariableResolver that is used to lookup variables.
     *
     * @return the VariableResolver
     */
    public StrLookup getVariableResolver() {
<span class="fc" id="L818">        return this.variableResolver;</span>
    }

    /**
     * Sets the VariableResolver that is used to lookup variables.
     *
     * @param variableResolver  the VariableResolver
     */
    public void setVariableResolver(StrLookup variableResolver) {
<span class="fc" id="L827">        this.variableResolver = variableResolver;</span>
<span class="fc" id="L828">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>