<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StringUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang</a> &gt; <span class="el_source">StringUtils.java</span></div><h1>StringUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;

/**
 * &lt;p&gt;Operations on {@link java.lang.String} that are
 * &lt;code&gt;null&lt;/code&gt; safe.&lt;/p&gt;
 *
 * &lt;ul&gt;
 *  &lt;li&gt;&lt;b&gt;IsEmpty/IsBlank&lt;/b&gt;
 *      - checks if a String contains text&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Trim/Strip&lt;/b&gt;
 *      - removes leading and trailing whitespace&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Equals&lt;/b&gt;
 *      - compares two strings null-safe&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;startsWith&lt;/b&gt;
 *      - check if a String starts with a prefix null-safe&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;endsWith&lt;/b&gt;
 *      - check if a String ends with a suffix null-safe&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;IndexOf/LastIndexOf/Contains&lt;/b&gt;
 *      - null-safe index-of checks
 *  &lt;li&gt;&lt;b&gt;IndexOfAny/LastIndexOfAny/IndexOfAnyBut/LastIndexOfAnyBut&lt;/b&gt;
 *      - index-of any of a set of Strings&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;ContainsOnly/ContainsNone/ContainsAny&lt;/b&gt;
 *      - does String contains only/none/any of these characters&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Substring/Left/Right/Mid&lt;/b&gt;
 *      - null-safe substring extractions&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;SubstringBefore/SubstringAfter/SubstringBetween&lt;/b&gt;
 *      - substring extraction relative to other strings&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Split/Join&lt;/b&gt;
 *      - splits a String into an array of substrings and vice versa&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Remove/Delete&lt;/b&gt;
 *      - removes part of a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Replace/Overlay&lt;/b&gt;
 *      - Searches a String and replaces one String with another&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Chomp/Chop&lt;/b&gt;
 *      - removes the last part of a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;LeftPad/RightPad/Center/Repeat&lt;/b&gt;
 *      - pads a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;UpperCase/LowerCase/SwapCase/Capitalize/Uncapitalize&lt;/b&gt;
 *      - changes the case of a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;CountMatches&lt;/b&gt;
 *      - counts the number of occurrences of one String in another&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;IsAlpha/IsNumeric/IsWhitespace/IsAsciiPrintable&lt;/b&gt;
 *      - checks the characters in a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;DefaultString&lt;/b&gt;
 *      - protects against a null input String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Reverse/ReverseDelimited&lt;/b&gt;
 *      - reverses a String&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Abbreviate&lt;/b&gt;
 *      - abbreviates a string using ellipsis&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;Difference&lt;/b&gt;
 *      - compares Strings and reports on their differences&lt;/li&gt;
 *  &lt;li&gt;&lt;b&gt;LevensteinDistance&lt;/b&gt;
 *      - the number of changes needed to change one String into another&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;The &lt;code&gt;StringUtils&lt;/code&gt; class defines certain words related to
 * String handling.&lt;/p&gt;
 *
 * &lt;ul&gt;
 *  &lt;li&gt;null - &lt;code&gt;null&lt;/code&gt;&lt;/li&gt;
 *  &lt;li&gt;empty - a zero-length string (&lt;code&gt;&quot;&quot;&lt;/code&gt;)&lt;/li&gt;
 *  &lt;li&gt;space - the space character (&lt;code&gt;' '&lt;/code&gt;, char 32)&lt;/li&gt;
 *  &lt;li&gt;whitespace - the characters defined by {@link Character#isWhitespace(char)}&lt;/li&gt;
 *  &lt;li&gt;trim - the characters &amp;lt;= 32 as in {@link String#trim()}&lt;/li&gt;
 * &lt;/ul&gt;
 *
 * &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; handles &lt;code&gt;null&lt;/code&gt; input Strings quietly.
 * That is to say that a &lt;code&gt;null&lt;/code&gt; input will return &lt;code&gt;null&lt;/code&gt;.
 * Where a &lt;code&gt;boolean&lt;/code&gt; or &lt;code&gt;int&lt;/code&gt; is being returned
 * details vary by method.&lt;/p&gt;
 *
 * &lt;p&gt;A side effect of the &lt;code&gt;null&lt;/code&gt; handling is that a
 * &lt;code&gt;NullPointerException&lt;/code&gt; should be considered a bug in
 * &lt;code&gt;StringUtils&lt;/code&gt;.&lt;/p&gt;
 *
 * &lt;p&gt;Methods in this class give sample code to explain their operation.
 * The symbol &lt;code&gt;*&lt;/code&gt; is used to indicate any input including &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
 *
 * @see java.lang.String
 * @author &lt;a href=&quot;http://jakarta.apache.org/turbine/&quot;&gt;Apache Jakarta Turbine&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:jon@latchkey.com&quot;&gt;Jon S. Stevens&lt;/a&gt;
 * @author Daniel L. Rall
 * @author &lt;a href=&quot;mailto:gcoladonato@yahoo.com&quot;&gt;Greg Coladonato&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:ed@apache.org&quot;&gt;Ed Korthof&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:rand_mcneely@yahoo.com&quot;&gt;Rand McNeely&lt;/a&gt;
 * @author Stephen Colebourne
 * @author &lt;a href=&quot;mailto:fredrik@westermarck.com&quot;&gt;Fredrik Westermarck&lt;/a&gt;
 * @author Holger Krauth
 * @author &lt;a href=&quot;mailto:alex@purpletech.com&quot;&gt;Alexander Day Chaffee&lt;/a&gt;
 * @author &lt;a href=&quot;mailto:hps@intermeta.de&quot;&gt;Henning P. Schmiedehausen&lt;/a&gt;
 * @author Arun Mammen Thomas
 * @author Gary Gregory
 * @author Phil Steitz
 * @author Al Chou
 * @author Michael Davey
 * @author Reuben Sivan
 * @author Chris Hyzer
 * @author Scott Johnson
 * @since 1.0
 * @version $Id$
 */
//@Immutable
public class StringUtils {
    // Performance testing notes (JDK 1.4, Jul03, scolebourne)
    // Whitespace:
    // Character.isWhitespace() is faster than WHITESPACE.indexOf()
    // where WHITESPACE is a string of all whitespace characters
    //
    // Character access:
    // String.charAt(n) versus toCharArray(), then array[n]
    // String.charAt(n) is about 15% worse for a 10K string
    // They are about equal for a length 50 string
    // String.charAt(n) is about 4 times better for a length 3 string
    // String.charAt(n) is best bet overall
    //
    // Append:
    // String.concat about twice as fast as StringBuffer.append
    // (not sure who tested this)

    /**
     * The empty String &lt;code&gt;&quot;&quot;&lt;/code&gt;.
     * @since 2.0
     */
    public static final String EMPTY = &quot;&quot;;

    /**
     * Represents a failed index search.
     * @since 2.1
     */
    public static final int INDEX_NOT_FOUND = -1;

    /**
     * &lt;p&gt;The maximum size to which the padding constant(s) can expand.&lt;/p&gt;
     */
    private static final int PAD_LIMIT = 8192;

    /**
     * &lt;p&gt;&lt;code&gt;StringUtils&lt;/code&gt; instances should NOT be constructed in
     * standard programming. Instead, the class should be used as
     * &lt;code&gt;StringUtils.trim(&quot; foo &quot;);&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;This constructor is public to permit tools that require a JavaBean
     * instance to operate.&lt;/p&gt;
     */
    public StringUtils() {
<span class="fc" id="L168">        super();</span>
<span class="fc" id="L169">    }</span>

    // Empty checks
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if a String is empty (&quot;&quot;) or null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isEmpty(null)      = true
     * StringUtils.isEmpty(&quot;&quot;)        = true
     * StringUtils.isEmpty(&quot; &quot;)       = false
     * StringUtils.isEmpty(&quot;bob&quot;)     = false
     * StringUtils.isEmpty(&quot;  bob  &quot;) = false
     * &lt;/pre&gt;
     *
     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
     * It no longer trims the String.
     * That functionality is available in isBlank().&lt;/p&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String is empty or null
     */
    public static boolean isEmpty(CharSequence str) {
<span class="fc bfc" id="L192" title="All 4 branches covered.">        return str == null || str.length() == 0;</span>
    }

    /**
     * &lt;p&gt;Checks if a String is not empty (&quot;&quot;) and not null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotEmpty(null)      = false
     * StringUtils.isNotEmpty(&quot;&quot;)        = false
     * StringUtils.isNotEmpty(&quot; &quot;)       = true
     * StringUtils.isNotEmpty(&quot;bob&quot;)     = true
     * StringUtils.isNotEmpty(&quot;  bob  &quot;) = true
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String is not empty and not null
     */
    public static boolean isNotEmpty(CharSequence str) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        return !StringUtils.isEmpty(str);</span>
    }

    /**
     * &lt;p&gt;Checks if a String is whitespace, empty (&quot;&quot;) or null.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isBlank(null)      = true
     * StringUtils.isBlank(&quot;&quot;)        = true
     * StringUtils.isBlank(&quot; &quot;)       = true
     * StringUtils.isBlank(&quot;bob&quot;)     = false
     * StringUtils.isBlank(&quot;  bob  &quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String is null, empty or whitespace
     * @since 2.0
     */
    public static boolean isBlank(CharSequence str) {
        int strLen;
<span class="fc bfc" id="L230" title="All 4 branches covered.">        if (str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L231">            return true;</span>
        }
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (int i = 0; i &lt; strLen; i++) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if ((Character.isWhitespace(str.charAt(i)) == false)) {</span>
<span class="fc" id="L235">                return false;</span>
            }
        }
<span class="fc" id="L238">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if a String is not empty (&quot;&quot;), not null and not whitespace only.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNotBlank(null)      = false
     * StringUtils.isNotBlank(&quot;&quot;)        = false
     * StringUtils.isNotBlank(&quot; &quot;)       = false
     * StringUtils.isNotBlank(&quot;bob&quot;)     = true
     * StringUtils.isNotBlank(&quot;  bob  &quot;) = true
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String is
     *  not empty and not null and not whitespace
     * @since 2.0
     */
    public static boolean isNotBlank(CharSequence str) {
<span class="fc bfc" id="L258" title="All 2 branches covered.">        return !StringUtils.isBlank(str);</span>
    }

    // Trim
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String, handling &lt;code&gt;null&lt;/code&gt; by returning
     * &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #strip(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;To trim your choice of characters, use the
     * {@link #strip(String, String)} methods.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trim(null)          = null
     * StringUtils.trim(&quot;&quot;)            = &quot;&quot;
     * StringUtils.trim(&quot;     &quot;)       = &quot;&quot;
     * StringUtils.trim(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trim(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed string, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String trim(String str) {
<span class="fc bfc" id="L287" title="All 2 branches covered.">        return str == null ? null : str.trim();</span>
    }

    /**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String returning &lt;code&gt;null&lt;/code&gt; if the String is
     * empty (&quot;&quot;) after the trim or if it is &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #stripToNull(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToNull(null)          = null
     * StringUtils.trimToNull(&quot;&quot;)            = null
     * StringUtils.trimToNull(&quot;     &quot;)       = null
     * StringUtils.trimToNull(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trimToNull(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed String,
     *  &lt;code&gt;null&lt;/code&gt; if only chars &amp;lt;= 32, empty or null String input
     * @since 2.0
     */
    public static String trimToNull(String str) {
<span class="fc" id="L313">        String ts = trim(str);</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">        return isEmpty(ts) ? null : ts;</span>
    }

    /**
     * &lt;p&gt;Removes control characters (char &amp;lt;= 32) from both
     * ends of this String returning an empty String (&quot;&quot;) if the String
     * is empty (&quot;&quot;) after the trim or if it is &lt;code&gt;null&lt;/code&gt;.
     *
     * &lt;p&gt;The String is trimmed using {@link String#trim()}.
     * Trim removes start and end characters &amp;lt;= 32.
     * To strip whitespace use {@link #stripToEmpty(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.trimToEmpty(null)          = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;&quot;)            = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;     &quot;)       = &quot;&quot;
     * StringUtils.trimToEmpty(&quot;abc&quot;)         = &quot;abc&quot;
     * StringUtils.trimToEmpty(&quot;    abc    &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to be trimmed, may be null
     * @return the trimmed String, or an empty String if &lt;code&gt;null&lt;/code&gt; input
     * @since 2.0
     */
    public static String trimToEmpty(String str) {
<span class="fc bfc" id="L339" title="All 2 branches covered.">        return str == null ? EMPTY : str.trim();</span>
    }

    // Stripping
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Strips whitespace from the start and end of a String.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trim(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.strip(null)     = null
     * StringUtils.strip(&quot;&quot;)       = &quot;&quot;
     * StringUtils.strip(&quot;   &quot;)    = &quot;&quot;
     * StringUtils.strip(&quot;abc&quot;)    = &quot;abc&quot;
     * StringUtils.strip(&quot;  abc&quot;)  = &quot;abc&quot;
     * StringUtils.strip(&quot;abc  &quot;)  = &quot;abc&quot;
     * StringUtils.strip(&quot; abc &quot;)  = &quot;abc&quot;
     * StringUtils.strip(&quot; ab c &quot;) = &quot;ab c&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to remove whitespace from, may be null
     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String strip(String str) {
<span class="fc" id="L367">        return strip(str, null);</span>
    }

    /**
     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
     * &lt;code&gt;null&lt;/code&gt; if the String is empty (&quot;&quot;) after the strip.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trimToNull(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripToNull(null)     = null
     * StringUtils.stripToNull(&quot;&quot;)       = null
     * StringUtils.stripToNull(&quot;   &quot;)    = null
     * StringUtils.stripToNull(&quot;abc&quot;)    = &quot;abc&quot;
     * StringUtils.stripToNull(&quot;  abc&quot;)  = &quot;abc&quot;
     * StringUtils.stripToNull(&quot;abc  &quot;)  = &quot;abc&quot;
     * StringUtils.stripToNull(&quot; abc &quot;)  = &quot;abc&quot;
     * StringUtils.stripToNull(&quot; ab c &quot;) = &quot;ab c&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to be stripped, may be null
     * @return the stripped String,
     *  &lt;code&gt;null&lt;/code&gt; if whitespace, empty or null String input
     * @since 2.0
     */
    public static String stripToNull(String str) {
<span class="fc bfc" id="L394" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L395">            return null;</span>
        }
<span class="fc" id="L397">        str = strip(str, null);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        return str.length() == 0 ? null : str;</span>
    }

    /**
     * &lt;p&gt;Strips whitespace from the start and end of a String  returning
     * an empty String if &lt;code&gt;null&lt;/code&gt; input.&lt;/p&gt;
     *
     * &lt;p&gt;This is similar to {@link #trimToEmpty(String)} but removes whitespace.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripToEmpty(null)     = &quot;&quot;
     * StringUtils.stripToEmpty(&quot;&quot;)       = &quot;&quot;
     * StringUtils.stripToEmpty(&quot;   &quot;)    = &quot;&quot;
     * StringUtils.stripToEmpty(&quot;abc&quot;)    = &quot;abc&quot;
     * StringUtils.stripToEmpty(&quot;  abc&quot;)  = &quot;abc&quot;
     * StringUtils.stripToEmpty(&quot;abc  &quot;)  = &quot;abc&quot;
     * StringUtils.stripToEmpty(&quot; abc &quot;)  = &quot;abc&quot;
     * StringUtils.stripToEmpty(&quot; ab c &quot;) = &quot;ab c&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to be stripped, may be null
     * @return the trimmed String, or an empty String if &lt;code&gt;null&lt;/code&gt; input
     * @since 2.0
     */
    public static String stripToEmpty(String str) {
<span class="fc bfc" id="L424" title="All 2 branches covered.">        return str == null ? EMPTY : strip(str, null);</span>
    }

    /**
     * &lt;p&gt;Strips any of a set of characters from the start and end of a String.
     * This is similar to {@link String#trim()} but allows the characters
     * to be stripped to be controlled.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.
     * Alternatively use {@link #strip(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.strip(null, *)          = null
     * StringUtils.strip(&quot;&quot;, *)            = &quot;&quot;
     * StringUtils.strip(&quot;abc&quot;, null)      = &quot;abc&quot;
     * StringUtils.strip(&quot;  abc&quot;, null)    = &quot;abc&quot;
     * StringUtils.strip(&quot;abc  &quot;, null)    = &quot;abc&quot;
     * StringUtils.strip(&quot; abc &quot;, null)    = &quot;abc&quot;
     * StringUtils.strip(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String strip(String str, String stripChars) {
<span class="fc bfc" id="L454" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L455">            return str;</span>
        }
<span class="fc" id="L457">        str = stripStart(str, stripChars);</span>
<span class="fc" id="L458">        return stripEnd(str, stripChars);</span>
    }

    /**
     * &lt;p&gt;Strips any of a set of characters from the start of a String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripStart(null, *)          = null
     * StringUtils.stripStart(&quot;&quot;, *)            = &quot;&quot;
     * StringUtils.stripStart(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
     * StringUtils.stripStart(&quot;abc&quot;, null)      = &quot;abc&quot;
     * StringUtils.stripStart(&quot;  abc&quot;, null)    = &quot;abc&quot;
     * StringUtils.stripStart(&quot;abc  &quot;, null)    = &quot;abc  &quot;
     * StringUtils.stripStart(&quot; abc &quot;, null)    = &quot;abc &quot;
     * StringUtils.stripStart(&quot;yxabc  &quot;, &quot;xyz&quot;) = &quot;abc  &quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String stripStart(String str, String stripChars) {
        int strLen;
<span class="fc bfc" id="L487" title="All 4 branches covered.">        if (str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L488">            return str;</span>
        }
<span class="fc" id="L490">        int start = 0;</span>
<span class="fc bfc" id="L491" title="All 2 branches covered.">        if (stripChars == null) {</span>
<span class="fc bfc" id="L492" title="All 4 branches covered.">            while ((start != strLen) &amp;&amp; Character.isWhitespace(str.charAt(start))) {</span>
<span class="fc" id="L493">                start++;</span>
            }
<span class="fc bfc" id="L495" title="All 2 branches covered.">        } else if (stripChars.length() == 0) {</span>
<span class="fc" id="L496">            return str;</span>
        } else {
<span class="fc bfc" id="L498" title="All 4 branches covered.">            while ((start != strLen) &amp;&amp; (stripChars.indexOf(str.charAt(start)) != -1)) {</span>
<span class="fc" id="L499">                start++;</span>
            }
        }
<span class="fc" id="L502">        return str.substring(start);</span>
    }

    /**
     * &lt;p&gt;Strips any of a set of characters from the end of a String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * An empty string (&quot;&quot;) input returns the empty string.&lt;/p&gt;
     *
     * &lt;p&gt;If the stripChars String is &lt;code&gt;null&lt;/code&gt;, whitespace is
     * stripped as defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripEnd(null, *)          = null
     * StringUtils.stripEnd(&quot;&quot;, *)            = &quot;&quot;
     * StringUtils.stripEnd(&quot;abc&quot;, &quot;&quot;)        = &quot;abc&quot;
     * StringUtils.stripEnd(&quot;abc&quot;, null)      = &quot;abc&quot;
     * StringUtils.stripEnd(&quot;  abc&quot;, null)    = &quot;  abc&quot;
     * StringUtils.stripEnd(&quot;abc  &quot;, null)    = &quot;abc&quot;
     * StringUtils.stripEnd(&quot; abc &quot;, null)    = &quot; abc&quot;
     * StringUtils.stripEnd(&quot;  abcyx&quot;, &quot;xyz&quot;) = &quot;  abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String stripEnd(String str, String stripChars) {
        int end;
<span class="fc bfc" id="L531" title="All 4 branches covered.">        if (str == null || (end = str.length()) == 0) {</span>
<span class="fc" id="L532">            return str;</span>
        }

<span class="fc bfc" id="L535" title="All 2 branches covered.">        if (stripChars == null) {</span>
<span class="fc bfc" id="L536" title="All 4 branches covered.">            while ((end != 0) &amp;&amp; Character.isWhitespace(str.charAt(end - 1))) {</span>
<span class="fc" id="L537">                end--;</span>
            }
<span class="fc bfc" id="L539" title="All 2 branches covered.">        } else if (stripChars.length() == 0) {</span>
<span class="fc" id="L540">            return str;</span>
        } else {
<span class="fc bfc" id="L542" title="All 4 branches covered.">            while ((end != 0) &amp;&amp; (stripChars.indexOf(str.charAt(end - 1)) != -1)) {</span>
<span class="fc" id="L543">                end--;</span>
            }
        }
<span class="fc" id="L546">        return str.substring(0, end);</span>
    }

    // StripAll
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Strips whitespace from the start and end of every String in an array.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A new array is returned each time, except for length zero.
     * A &lt;code&gt;null&lt;/code&gt; array will return &lt;code&gt;null&lt;/code&gt;.
     * An empty array will return itself.
     * A &lt;code&gt;null&lt;/code&gt; array entry will be ignored.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripAll(null)             = null
     * StringUtils.stripAll([])               = []
     * StringUtils.stripAll([&quot;abc&quot;, &quot;  abc&quot;]) = [&quot;abc&quot;, &quot;abc&quot;]
     * StringUtils.stripAll([&quot;abc  &quot;, null])  = [&quot;abc&quot;, null]
     * &lt;/pre&gt;
     *
     * @param strs  the array to remove whitespace from, may be null
     * @return the stripped Strings, &lt;code&gt;null&lt;/code&gt; if null array input
     */
    public static String[] stripAll(String[] strs) {
<span class="fc" id="L571">        return stripAll(strs, null);</span>
    }

    /**
     * &lt;p&gt;Strips any of a set of characters from the start and end of every
     * String in an array.&lt;/p&gt;
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A new array is returned each time, except for length zero.
     * A &lt;code&gt;null&lt;/code&gt; array will return &lt;code&gt;null&lt;/code&gt;.
     * An empty array will return itself.
     * A &lt;code&gt;null&lt;/code&gt; array entry will be ignored.
     * A &lt;code&gt;null&lt;/code&gt; stripChars will strip whitespace as defined by
     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.stripAll(null, *)                = null
     * StringUtils.stripAll([], *)                  = []
     * StringUtils.stripAll([&quot;abc&quot;, &quot;  abc&quot;], null) = [&quot;abc&quot;, &quot;abc&quot;]
     * StringUtils.stripAll([&quot;abc  &quot;, null], null)  = [&quot;abc&quot;, null]
     * StringUtils.stripAll([&quot;abc  &quot;, null], &quot;yz&quot;)  = [&quot;abc  &quot;, null]
     * StringUtils.stripAll([&quot;yabcz&quot;, null], &quot;yz&quot;)  = [&quot;abc&quot;, null]
     * &lt;/pre&gt;
     *
     * @param strs  the array to remove characters from, may be null
     * @param stripChars  the characters to remove, null treated as whitespace
     * @return the stripped Strings, &lt;code&gt;null&lt;/code&gt; if null array input
     */
    public static String[] stripAll(String[] strs, String stripChars) {
        int strsLen;
<span class="fc bfc" id="L601" title="All 4 branches covered.">        if (strs == null || (strsLen = strs.length) == 0) {</span>
<span class="fc" id="L602">            return strs;</span>
        }
<span class="fc" id="L604">        String[] newArr = new String[strsLen];</span>
<span class="fc bfc" id="L605" title="All 2 branches covered.">        for (int i = 0; i &lt; strsLen; i++) {</span>
<span class="fc" id="L606">            newArr[i] = strip(strs[i], stripChars);</span>
        }
<span class="fc" id="L608">        return newArr;</span>
    }

    // Equals
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Compares two Strings, returning &lt;code&gt;true&lt;/code&gt; if they are equal.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equals(null, null)   = true
     * StringUtils.equals(null, &quot;abc&quot;)  = false
     * StringUtils.equals(&quot;abc&quot;, null)  = false
     * StringUtils.equals(&quot;abc&quot;, &quot;abc&quot;) = true
     * StringUtils.equals(&quot;abc&quot;, &quot;ABC&quot;) = false
     * &lt;/pre&gt;
     *
     * @see java.lang.String#equals(Object)
     * @param str1  the first String, may be null
     * @param str2  the second String, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the Strings are equal, case sensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     */
    public static boolean equals(String str1, String str2) {
<span class="fc bfc" id="L634" title="All 4 branches covered.">        return str1 == null ? str2 == null : str1.equals(str2);</span>
    }

    /**
     * &lt;p&gt;Compares two Strings, returning &lt;code&gt;true&lt;/code&gt; if they are equal ignoring
     * the case.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered equal. Comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.equalsIgnoreCase(null, null)   = true
     * StringUtils.equalsIgnoreCase(null, &quot;abc&quot;)  = false
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, null)  = false
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;abc&quot;) = true
     * StringUtils.equalsIgnoreCase(&quot;abc&quot;, &quot;ABC&quot;) = true
     * &lt;/pre&gt;
     *
     * @see java.lang.String#equalsIgnoreCase(String)
     * @param str1  the first String, may be null
     * @param str2  the second String, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the Strings are equal, case insensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     */
    public static boolean equalsIgnoreCase(String str1, String str2) {
<span class="fc bfc" id="L659" title="All 4 branches covered.">        return str1 == null ? str2 == null : str1.equalsIgnoreCase(str2);</span>
    }

    // IndexOf
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *)         = -1
     * StringUtils.indexOf(&quot;&quot;, *)           = -1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'a') = 0
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'b') = 2
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChar  the character to find
     * @return the first index of the search character,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int indexOf(String str, char searchChar) {
<span class="fc bfc" id="L684" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L685">            return -1;</span>
        }
<span class="fc" id="L687">        return str.indexOf(searchChar);</span>
    }

    /**
     * &lt;p&gt;Finds the first index within a String from a start position,
     * handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(int, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.
     * A negative start position is treated as zero.
     * A start position greater than the string length returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *, *)          = -1
     * StringUtils.indexOf(&quot;&quot;, *, *)            = -1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'b', 0)  = 2
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'b', 3)  = 5
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'b', 9)  = -1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, 'b', -1) = 2
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChar  the character to find
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search character,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int indexOf(String str, char searchChar, int startPos) {
<span class="fc bfc" id="L716" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L717">            return -1;</span>
        }
<span class="fc" id="L719">        return str.indexOf(searchChar, startPos);</span>
    }

    /**
     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *)          = -1
     * StringUtils.indexOf(*, null)          = -1
     * StringUtils.indexOf(&quot;&quot;, &quot;&quot;)           = 0
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;)  = 0
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;)  = 2
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;) = 1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;)   = 0
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @return the first index of the search String,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int indexOf(String str, String searchStr) {
<span class="fc bfc" id="L745" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L746">            return -1;</span>
        }
<span class="fc" id="L748">        return str.indexOf(searchStr);</span>
    }

    /**
     * &lt;p&gt;Finds the n-th index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.ordinalIndexOf(null, *, *)          = -1
     * StringUtils.ordinalIndexOf(*, null, *)          = -1
     * StringUtils.ordinalIndexOf(&quot;&quot;, &quot;&quot;, *)           = 0
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 1)  = 0
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 2)  = 1
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 1)  = 2
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 2)  = 5
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 1) = 1
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 2) = 4
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 1)   = 0
     * StringUtils.ordinalIndexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 0
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @param ordinal  the n-th &lt;code&gt;searchStr&lt;/code&gt; to find
     * @return the n-th index of the search String,
     *  &lt;code&gt;-1&lt;/code&gt; (&lt;code&gt;INDEX_NOT_FOUND&lt;/code&gt;) if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.1
     */
    public static int ordinalIndexOf(String str, String searchStr, int ordinal) {
<span class="fc bfc" id="L779" title="All 6 branches covered.">        if (str == null || searchStr == null || ordinal &lt;= 0) {</span>
<span class="fc" id="L780">            return INDEX_NOT_FOUND;</span>
        }
<span class="fc bfc" id="L782" title="All 2 branches covered.">        if (searchStr.length() == 0) {</span>
<span class="fc" id="L783">            return 0;</span>
        }
<span class="fc" id="L785">        int found = 0;</span>
<span class="fc" id="L786">        int index = INDEX_NOT_FOUND;</span>
        do {
<span class="fc" id="L788">            index = str.indexOf(searchStr, index + 1);</span>
<span class="fc bfc" id="L789" title="All 2 branches covered.">            if (index &lt; 0) {</span>
<span class="fc" id="L790">                return index;</span>
            }
<span class="fc" id="L792">            found++;</span>
<span class="fc bfc" id="L793" title="All 2 branches covered.">        } while (found &lt; ordinal);</span>
<span class="fc" id="L794">        return index;</span>
    }

    /**
     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(String, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A negative start position is treated as zero.
     * An empty (&quot;&quot;) search String always matches.
     * A start position greater than the string length only matches
     * an empty search String.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOf(null, *, *)          = -1
     * StringUtils.indexOf(*, null, *)          = -1
     * StringUtils.indexOf(&quot;&quot;, &quot;&quot;, 0)           = 0
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 0)  = 0
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 0)  = 2
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 0) = 1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 3)  = 5
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 9)  = -1
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;b&quot;, -1) = 2
     * StringUtils.indexOf(&quot;aabaabaa&quot;, &quot;&quot;, 2)   = 2
     * StringUtils.indexOf(&quot;abc&quot;, &quot;&quot;, 9)        = 3
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search String,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int indexOf(String str, String searchStr, int startPos) {
<span class="fc bfc" id="L829" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L830">            return -1;</span>
        }
        // JDK1.2/JDK1.3 have a bug, when startPos &gt; str.length for &quot;&quot;, hence
<span class="fc bfc" id="L833" title="All 4 branches covered.">        if (searchStr.length() == 0 &amp;&amp; startPos &gt;= str.length()) {</span>
<span class="fc" id="L834">            return str.length();</span>
        }
<span class="fc" id="L836">        return str.indexOf(searchStr, startPos);</span>
    }

    // LastIndexOf
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Finds the last index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#lastIndexOf(int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *)         = -1
     * StringUtils.lastIndexOf(&quot;&quot;, *)           = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'a') = 7
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b') = 5
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChar  the character to find
     * @return the last index of the search character,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int lastIndexOf(String str, char searchChar) {
<span class="fc bfc" id="L861" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L862">            return -1;</span>
        }
<span class="fc" id="L864">        return str.lastIndexOf(searchChar);</span>
    }

    /**
     * &lt;p&gt;Finds the last index within a String from a start position,
     * handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#lastIndexOf(int, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;-1&lt;/code&gt;.
     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
     * A start position greater than the string length searches the whole string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *, *)          = -1
     * StringUtils.lastIndexOf(&quot;&quot;, *,  *)           = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b', 8)  = 5
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b', 4)  = 2
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b', 0)  = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b', 9)  = 5
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'b', -1) = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, 'a', 0)  = 0
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChar  the character to find
     * @param startPos  the start position
     * @return the last index of the search character,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int lastIndexOf(String str, char searchChar, int startPos) {
<span class="fc bfc" id="L895" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L896">            return -1;</span>
        }
<span class="fc" id="L898">        return str.lastIndexOf(searchChar, startPos);</span>
    }

    /**
     * &lt;p&gt;Finds the last index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#lastIndexOf(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *)          = -1
     * StringUtils.lastIndexOf(*, null)          = -1
     * StringUtils.lastIndexOf(&quot;&quot;, &quot;&quot;)           = 0
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;)  = 0
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;)  = 2
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;) = 1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;&quot;)   = 8
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @return the last index of the search String,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int lastIndexOf(String str, String searchStr) {
<span class="fc bfc" id="L924" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L925">            return -1;</span>
        }
<span class="fc" id="L927">        return str.lastIndexOf(searchStr);</span>
    }

    /**
     * &lt;p&gt;Finds the first index within a String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#lastIndexOf(String, int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A negative start position returns &lt;code&gt;-1&lt;/code&gt;.
     * An empty (&quot;&quot;) search String always matches unless the start position is negative.
     * A start position greater than the string length searches the whole string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOf(null, *, *)          = -1
     * StringUtils.lastIndexOf(*, null, *)          = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 8)  = 7
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 8)  = 5
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;ab&quot;, 8) = 4
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 9)  = 5
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, -1) = -1
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;a&quot;, 0)  = 0
     * StringUtils.lastIndexOf(&quot;aabaabaa&quot;, &quot;b&quot;, 0)  = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @param startPos  the start position, negative treated as zero
     * @return the first index of the search String,
     *  -1 if no match or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static int lastIndexOf(String str, String searchStr, int startPos) {
<span class="fc bfc" id="L959" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L960">            return -1;</span>
        }
<span class="fc" id="L962">        return str.lastIndexOf(searchStr, startPos);</span>
    }

    // Contains
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if String contains a search character, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(int)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *)    = false
     * StringUtils.contains(&quot;&quot;, *)      = false
     * StringUtils.contains(&quot;abc&quot;, 'a') = true
     * StringUtils.contains(&quot;abc&quot;, 'z') = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChar  the character to find
     * @return true if the String contains the search character,
     *  false if not or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static boolean contains(String str, char searchChar) {
<span class="fc bfc" id="L987" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L988">            return false;</span>
        }
<span class="fc bfc" id="L990" title="All 2 branches covered.">        return str.indexOf(searchChar) &gt;= 0;</span>
    }

    /**
     * &lt;p&gt;Checks if String contains a search String, handling &lt;code&gt;null&lt;/code&gt;.
     * This method uses {@link String#indexOf(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *)     = false
     * StringUtils.contains(*, null)     = false
     * StringUtils.contains(&quot;&quot;, &quot;&quot;)      = true
     * StringUtils.contains(&quot;abc&quot;, &quot;&quot;)   = true
     * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;)  = true
     * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;)  = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @return true if the String contains the search String,
     *  false if not or &lt;code&gt;null&lt;/code&gt; string input
     * @since 2.0
     */
    public static boolean contains(String str, String searchStr) {
<span class="fc bfc" id="L1015" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L1016">            return false;</span>
        }
<span class="fc bfc" id="L1018" title="All 2 branches covered.">        return str.indexOf(searchStr) &gt;= 0;</span>
    }

    /**
     * &lt;p&gt;Checks if String contains a search String irrespective of case,
     * handling &lt;code&gt;null&lt;/code&gt;. Case-insensitivity is defined as by
     * {@link String#equalsIgnoreCase(String)}.
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.contains(null, *) = false
     * StringUtils.contains(*, null) = false
     * StringUtils.contains(&quot;&quot;, &quot;&quot;) = true
     * StringUtils.contains(&quot;abc&quot;, &quot;&quot;) = true
     * StringUtils.contains(&quot;abc&quot;, &quot;a&quot;) = true
     * StringUtils.contains(&quot;abc&quot;, &quot;z&quot;) = false
     * StringUtils.contains(&quot;abc&quot;, &quot;A&quot;) = true
     * StringUtils.contains(&quot;abc&quot;, &quot;Z&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStr  the String to find, may be null
     * @return true if the String contains the search String irrespective of
     * case or false if not or &lt;code&gt;null&lt;/code&gt; string input
     */
    public static boolean containsIgnoreCase(String str, String searchStr) {
<span class="fc bfc" id="L1045" title="All 4 branches covered.">        if (str == null || searchStr == null) {</span>
<span class="fc" id="L1046">            return false;</span>
        }
<span class="fc" id="L1048">        int len = searchStr.length();</span>
<span class="fc" id="L1049">        int max = str.length() - len;</span>
<span class="fc bfc" id="L1050" title="All 2 branches covered.">        for (int i = 0; i &lt;= max; i++) {</span>
<span class="fc bfc" id="L1051" title="All 2 branches covered.">            if (str.regionMatches(true, i, searchStr, 0, len)) {</span>
<span class="fc" id="L1052">                return true;</span>
            }
        }
<span class="fc" id="L1055">        return false;</span>
    }

    // IndexOfAny chars
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Search a String to find the first index of any
     * character in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)                = -1
     * StringUtils.indexOfAny(&quot;&quot;, *)                  = -1
     * StringUtils.indexOfAny(*, null)                = -1
     * StringUtils.indexOfAny(*, [])                  = -1
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;,['z','a']) = 0
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;,['b','y']) = 3
     * StringUtils.indexOfAny(&quot;aba&quot;, ['z'])           = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     */
    public static int indexOfAny(String str, char[] searchChars) {
<span class="fc bfc" id="L1083" title="All 4 branches covered.">        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {</span>
<span class="fc" id="L1084">            return -1;</span>
        }
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc" id="L1087">            char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1088" title="All 2 branches covered.">            for (int j = 0; j &lt; searchChars.length; j++) {</span>
<span class="fc bfc" id="L1089" title="All 2 branches covered.">                if (searchChars[j] == ch) {</span>
<span class="fc" id="L1090">                    return i;</span>
                }
            }
        }
<span class="fc" id="L1094">        return -1;</span>
    }

    /**
     * &lt;p&gt;Search a String to find the first index of any
     * character in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; search string will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)            = -1
     * StringUtils.indexOfAny(&quot;&quot;, *)              = -1
     * StringUtils.indexOfAny(*, null)            = -1
     * StringUtils.indexOfAny(*, &quot;&quot;)              = -1
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, &quot;za&quot;) = 0
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, &quot;by&quot;) = 3
     * StringUtils.indexOfAny(&quot;aba&quot;,&quot;z&quot;)          = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     */
    public static int indexOfAny(String str, String searchChars) {
<span class="fc bfc" id="L1120" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(searchChars)) {</span>
<span class="fc" id="L1121">            return -1;</span>
        }
<span class="fc" id="L1123">        return indexOfAny(str, searchChars.toCharArray());</span>
    }

    // ContainsAny
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if the String contains any character in the given
     * set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsAny(null, *)                = false
     * StringUtils.containsAny(&quot;&quot;, *)                  = false
     * StringUtils.containsAny(*, null)                = false
     * StringUtils.containsAny(*, [])                  = false
     * StringUtils.containsAny(&quot;zzabyycdxx&quot;,['z','a']) = true
     * StringUtils.containsAny(&quot;zzabyycdxx&quot;,['b','y']) = true
     * StringUtils.containsAny(&quot;aba&quot;, ['z'])           = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the &lt;code&gt;true&lt;/code&gt; if any of the chars are found,
     * &lt;code&gt;false&lt;/code&gt; if no match or null input
     * @since 2.4
     */
    public static boolean containsAny(String str, char[] searchChars) {
<span class="fc bfc" id="L1152" title="All 8 branches covered.">        if (str == null || str.length() == 0 || searchChars == null || searchChars.length == 0) {</span>
<span class="fc" id="L1153">            return false;</span>
        }
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc" id="L1156">            char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1157" title="All 2 branches covered.">            for (int j = 0; j &lt; searchChars.length; j++) {</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">                if (searchChars[j] == ch) {</span>
<span class="fc" id="L1159">                    return true;</span>
                }
            }
        }
<span class="fc" id="L1163">        return false;</span>
    }

    /**
     * &lt;p&gt;
     * Checks if the String contains any character in the given set of characters.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;. A &lt;code&gt;null&lt;/code&gt; search string will return
     * &lt;code&gt;false&lt;/code&gt;.
     * &lt;/p&gt;
     * 
     * &lt;pre&gt;
     * StringUtils.containsAny(null, *)            = false
     * StringUtils.containsAny(&quot;&quot;, *)              = false
     * StringUtils.containsAny(*, null)            = false
     * StringUtils.containsAny(*, &quot;&quot;)              = false
     * StringUtils.containsAny(&quot;zzabyycdxx&quot;, &quot;za&quot;) = true
     * StringUtils.containsAny(&quot;zzabyycdxx&quot;, &quot;by&quot;) = true
     * StringUtils.containsAny(&quot;aba&quot;,&quot;z&quot;)          = false
     * &lt;/pre&gt;
     * 
     * @param str
     *            the String to check, may be null
     * @param searchChars
     *            the chars to search for, may be null
     * @return the &lt;code&gt;true&lt;/code&gt; if any of the chars are found, &lt;code&gt;false&lt;/code&gt; if no match or null input
     * @since 2.4
     */
    public static boolean containsAny(String str, String searchChars) {
<span class="fc bfc" id="L1194" title="All 2 branches covered.">        if (searchChars == null) {</span>
<span class="fc" id="L1195">            return false;</span>
        }
<span class="fc" id="L1197">        return containsAny(str, searchChars.toCharArray());</span>
    }

    // IndexOfAnyBut chars
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Search a String to find the first index of any
     * character not in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAnyBut(null, *)           = -1
     * StringUtils.indexOfAnyBut(&quot;&quot;, *)             = -1
     * StringUtils.indexOfAnyBut(*, null)           = -1
     * StringUtils.indexOfAnyBut(*, [])             = -1
     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;,'za') = 3
     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, '')  = 0
     * StringUtils.indexOfAnyBut(&quot;aba&quot;, 'ab')       = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     */
    public static int indexOfAnyBut(String str, char[] searchChars) {
<span class="fc bfc" id="L1225" title="All 4 branches covered.">        if (isEmpty(str) || ArrayUtils.isEmpty(searchChars)) {</span>
<span class="fc" id="L1226">            return -1;</span>
        }
<span class="fc bfc" id="L1228" title="All 2 branches covered.">        outer : for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc" id="L1229">            char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1230" title="All 2 branches covered.">            for (int j = 0; j &lt; searchChars.length; j++) {</span>
<span class="fc bfc" id="L1231" title="All 2 branches covered.">                if (searchChars[j] == ch) {</span>
<span class="fc" id="L1232">                    continue outer;</span>
                }
            }
<span class="fc" id="L1235">            return i;</span>
        }
<span class="fc" id="L1237">        return -1;</span>
    }

    /**
     * &lt;p&gt;Search a String to find the first index of any
     * character not in the given set of characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; search string will return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAnyBut(null, *)            = -1
     * StringUtils.indexOfAnyBut(&quot;&quot;, *)              = -1
     * StringUtils.indexOfAnyBut(*, null)            = -1
     * StringUtils.indexOfAnyBut(*, &quot;&quot;)              = -1
     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, &quot;za&quot;) = 3
     * StringUtils.indexOfAnyBut(&quot;zzabyycdxx&quot;, &quot;&quot;)   = 0
     * StringUtils.indexOfAnyBut(&quot;aba&quot;,&quot;ab&quot;)         = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchChars  the chars to search for, may be null
     * @return the index of any of the chars, -1 if no match or null input
     * @since 2.0
     */
    public static int indexOfAnyBut(String str, String searchChars) {
<span class="fc bfc" id="L1263" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(searchChars)) {</span>
<span class="fc" id="L1264">            return -1;</span>
        }
<span class="pc bpc" id="L1266" title="1 of 2 branches missed.">        for (int i = 0; i &lt; str.length(); i++) {</span>
<span class="fc bfc" id="L1267" title="All 2 branches covered.">            if (searchChars.indexOf(str.charAt(i)) &lt; 0) {</span>
<span class="fc" id="L1268">                return i;</span>
            }
        }
<span class="nc" id="L1271">        return -1;</span>
    }

    // ContainsOnly
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if the String contains only certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; valid character array will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) always returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsOnly(null, *)       = false
     * StringUtils.containsOnly(*, null)       = false
     * StringUtils.containsOnly(&quot;&quot;, *)         = true
     * StringUtils.containsOnly(&quot;ab&quot;, '')      = false
     * StringUtils.containsOnly(&quot;abab&quot;, 'abc') = true
     * StringUtils.containsOnly(&quot;ab1&quot;, 'abc')  = false
     * StringUtils.containsOnly(&quot;abz&quot;, 'abc')  = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param valid  an array of valid chars, may be null
     * @return true if it only contains valid chars and is non-null
     */
    public static boolean containsOnly(String str, char[] valid) {
        // All these pre-checks are to maintain API with an older version
<span class="fc bfc" id="L1299" title="All 4 branches covered.">        if ((valid == null) || (str == null)) {</span>
<span class="fc" id="L1300">            return false;</span>
        }
<span class="fc bfc" id="L1302" title="All 2 branches covered.">        if (str.length() == 0) {</span>
<span class="fc" id="L1303">            return true;</span>
        }
<span class="fc bfc" id="L1305" title="All 2 branches covered.">        if (valid.length == 0) {</span>
<span class="fc" id="L1306">            return false;</span>
        }
<span class="fc bfc" id="L1308" title="All 2 branches covered.">        return indexOfAnyBut(str, valid) == -1;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;false&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; valid character String will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) always returns &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsOnly(null, *)       = false
     * StringUtils.containsOnly(*, null)       = false
     * StringUtils.containsOnly(&quot;&quot;, *)         = true
     * StringUtils.containsOnly(&quot;ab&quot;, &quot;&quot;)      = false
     * StringUtils.containsOnly(&quot;abab&quot;, &quot;abc&quot;) = true
     * StringUtils.containsOnly(&quot;ab1&quot;, &quot;abc&quot;)  = false
     * StringUtils.containsOnly(&quot;abz&quot;, &quot;abc&quot;)  = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param validChars  a String of valid chars, may be null
     * @return true if it only contains valid chars and is non-null
     * @since 2.0
     */
    public static boolean containsOnly(String str, String validChars) {
<span class="fc bfc" id="L1334" title="All 4 branches covered.">        if (str == null || validChars == null) {</span>
<span class="fc" id="L1335">            return false;</span>
        }
<span class="fc" id="L1337">        return containsOnly(str, validChars.toCharArray());</span>
    }

    // ContainsNone
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks that the String does not contain certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;true&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; invalid character array will return &lt;code&gt;true&lt;/code&gt;.
     * An empty String (&quot;&quot;) always returns true.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsNone(null, *)       = true
     * StringUtils.containsNone(*, null)       = true
     * StringUtils.containsNone(&quot;&quot;, *)         = true
     * StringUtils.containsNone(&quot;ab&quot;, '')      = true
     * StringUtils.containsNone(&quot;abab&quot;, 'xyz') = true
     * StringUtils.containsNone(&quot;ab1&quot;, 'xyz')  = true
     * StringUtils.containsNone(&quot;abz&quot;, 'xyz')  = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param invalidChars  an array of invalid chars, may be null
     * @return true if it contains none of the invalid chars, or is null
     * @since 2.0
     */
    public static boolean containsNone(String str, char[] invalidChars) {
<span class="fc bfc" id="L1365" title="All 4 branches covered.">        if (str == null || invalidChars == null) {</span>
<span class="fc" id="L1366">            return true;</span>
        }
<span class="fc" id="L1368">        int strSize = str.length();</span>
<span class="fc" id="L1369">        int validSize = invalidChars.length;</span>
<span class="fc bfc" id="L1370" title="All 2 branches covered.">        for (int i = 0; i &lt; strSize; i++) {</span>
<span class="fc" id="L1371">            char ch = str.charAt(i);</span>
<span class="fc bfc" id="L1372" title="All 2 branches covered.">            for (int j = 0; j &lt; validSize; j++) {</span>
<span class="fc bfc" id="L1373" title="All 2 branches covered.">                if (invalidChars[j] == ch) {</span>
<span class="fc" id="L1374">                    return false;</span>
                }
            }
        }
<span class="fc" id="L1378">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks that the String does not contain certain characters.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;true&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; invalid character array will return &lt;code&gt;true&lt;/code&gt;.
     * An empty String (&quot;&quot;) always returns true.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.containsNone(null, *)       = true
     * StringUtils.containsNone(*, null)       = true
     * StringUtils.containsNone(&quot;&quot;, *)         = true
     * StringUtils.containsNone(&quot;ab&quot;, &quot;&quot;)      = true
     * StringUtils.containsNone(&quot;abab&quot;, &quot;xyz&quot;) = true
     * StringUtils.containsNone(&quot;ab1&quot;, &quot;xyz&quot;)  = true
     * StringUtils.containsNone(&quot;abz&quot;, &quot;xyz&quot;)  = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param invalidChars  a String of invalid chars, may be null
     * @return true if it contains none of the invalid chars, or is null
     * @since 2.0
     */
    public static boolean containsNone(String str, String invalidChars) {
<span class="fc bfc" id="L1404" title="All 4 branches covered.">        if (str == null || invalidChars == null) {</span>
<span class="fc" id="L1405">            return true;</span>
        }
<span class="fc" id="L1407">        return containsNone(str, invalidChars.toCharArray());</span>
    }

    // IndexOfAny strings
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Find the first index of any of a set of potential substrings.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; or zero length search array will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; search array entry will be ignored, but a search
     * array containing &quot;&quot; will return &lt;code&gt;0&lt;/code&gt; if &lt;code&gt;str&lt;/code&gt; is not
     * null. This method uses {@link String#indexOf(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfAny(null, *)                     = -1
     * StringUtils.indexOfAny(*, null)                     = -1
     * StringUtils.indexOfAny(*, [])                       = -1
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;ab&quot;,&quot;cd&quot;])   = 2
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;cd&quot;,&quot;ab&quot;])   = 2
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;])   = -1
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;zab&quot;,&quot;aby&quot;]) = 1
     * StringUtils.indexOfAny(&quot;zzabyycdxx&quot;, [&quot;&quot;])          = 0
     * StringUtils.indexOfAny(&quot;&quot;, [&quot;&quot;])                    = 0
     * StringUtils.indexOfAny(&quot;&quot;, [&quot;a&quot;])                   = -1
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStrs  the Strings to search for, may be null
     * @return the first index of any of the searchStrs in str, -1 if no match
     */
    public static int indexOfAny(String str, String[] searchStrs) {
<span class="fc bfc" id="L1439" title="All 4 branches covered.">        if ((str == null) || (searchStrs == null)) {</span>
<span class="fc" id="L1440">            return -1;</span>
        }
<span class="fc" id="L1442">        int sz = searchStrs.length;</span>

        // String's can't have a MAX_VALUEth index.
<span class="fc" id="L1445">        int ret = Integer.MAX_VALUE;</span>

<span class="fc" id="L1447">        int tmp = 0;</span>
<span class="fc bfc" id="L1448" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L1449">            String search = searchStrs[i];</span>
<span class="fc bfc" id="L1450" title="All 2 branches covered.">            if (search == null) {</span>
<span class="fc" id="L1451">                continue;</span>
            }
<span class="fc" id="L1453">            tmp = str.indexOf(search);</span>
<span class="fc bfc" id="L1454" title="All 2 branches covered.">            if (tmp == -1) {</span>
<span class="fc" id="L1455">                continue;</span>
            }

<span class="fc bfc" id="L1458" title="All 2 branches covered.">            if (tmp &lt; ret) {</span>
<span class="fc" id="L1459">                ret = tmp;</span>
            }
        }

<span class="fc bfc" id="L1463" title="All 2 branches covered.">        return (ret == Integer.MAX_VALUE) ? -1 : ret;</span>
    }

    /**
     * &lt;p&gt;Find the latest index of any of a set of potential substrings.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; search array will return &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; or zero length search array entry will be ignored,
     * but a search array containing &quot;&quot; will return the length of &lt;code&gt;str&lt;/code&gt;
     * if &lt;code&gt;str&lt;/code&gt; is not null. This method uses {@link String#indexOf(String)}&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lastIndexOfAny(null, *)                   = -1
     * StringUtils.lastIndexOfAny(*, null)                   = -1
     * StringUtils.lastIndexOfAny(*, [])                     = -1
     * StringUtils.lastIndexOfAny(*, [null])                 = -1
     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;ab&quot;,&quot;cd&quot;]) = 6
     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;cd&quot;,&quot;ab&quot;]) = 6
     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;]) = -1
     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;op&quot;]) = -1
     * StringUtils.lastIndexOfAny(&quot;zzabyycdxx&quot;, [&quot;mn&quot;,&quot;&quot;])   = 10
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param searchStrs  the Strings to search for, may be null
     * @return the last index of any of the Strings, -1 if no match
     */
    public static int lastIndexOfAny(String str, String[] searchStrs) {
<span class="fc bfc" id="L1492" title="All 4 branches covered.">        if ((str == null) || (searchStrs == null)) {</span>
<span class="fc" id="L1493">            return -1;</span>
        }
<span class="fc" id="L1495">        int sz = searchStrs.length;</span>
<span class="fc" id="L1496">        int ret = -1;</span>
<span class="fc" id="L1497">        int tmp = 0;</span>
<span class="fc bfc" id="L1498" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc" id="L1499">            String search = searchStrs[i];</span>
<span class="fc bfc" id="L1500" title="All 2 branches covered.">            if (search == null) {</span>
<span class="fc" id="L1501">                continue;</span>
            }
<span class="fc" id="L1503">            tmp = str.lastIndexOf(search);</span>
<span class="fc bfc" id="L1504" title="All 2 branches covered.">            if (tmp &gt; ret) {</span>
<span class="fc" id="L1505">                ret = tmp;</span>
            }
        }
<span class="fc" id="L1508">        return ret;</span>
    }

    // Substring
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
     *
     * &lt;p&gt;A negative start position can be used to start &lt;code&gt;n&lt;/code&gt;
     * characters from the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) String will return &quot;&quot;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *)   = null
     * StringUtils.substring(&quot;&quot;, *)     = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 0)  = &quot;abc&quot;
     * StringUtils.substring(&quot;abc&quot;, 2)  = &quot;c&quot;
     * StringUtils.substring(&quot;abc&quot;, 4)  = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, -2) = &quot;bc&quot;
     * StringUtils.substring(&quot;abc&quot;, -4) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get the substring from, may be null
     * @param start  the position to start from, negative means
     *  count back from the end of the String by this many characters
     * @return substring from start position, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String substring(String str, int start) {
<span class="fc bfc" id="L1538" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L1539">            return null;</span>
        }

        // handle negatives, which means last n characters
<span class="fc bfc" id="L1543" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L1544">            start = str.length() + start; // remember start is negative</span>
        }

<span class="fc bfc" id="L1547" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L1548">            start = 0;</span>
        }
<span class="fc bfc" id="L1550" title="All 2 branches covered.">        if (start &gt; str.length()) {</span>
<span class="fc" id="L1551">            return EMPTY;</span>
        }

<span class="fc" id="L1554">        return str.substring(start);</span>
    }

    /**
     * &lt;p&gt;Gets a substring from the specified String avoiding exceptions.&lt;/p&gt;
     *
     * &lt;p&gt;A negative start position can be used to start/end &lt;code&gt;n&lt;/code&gt;
     * characters from the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;The returned substring starts with the character in the &lt;code&gt;start&lt;/code&gt;
     * position and ends before the &lt;code&gt;end&lt;/code&gt; position. All position counting is
     * zero-based -- i.e., to start at the beginning of the string use
     * &lt;code&gt;start = 0&lt;/code&gt;. Negative start and end positions can be used to
     * specify offsets relative to the end of the String.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;start&lt;/code&gt; is not strictly to the left of &lt;code&gt;end&lt;/code&gt;, &quot;&quot;
     * is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substring(null, *, *)    = null
     * StringUtils.substring(&quot;&quot;, * ,  *)    = &quot;&quot;;
     * StringUtils.substring(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 0)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
     * StringUtils.substring(&quot;abc&quot;, 4, 6)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, 2, 2)   = &quot;&quot;
     * StringUtils.substring(&quot;abc&quot;, -2, -1) = &quot;b&quot;
     * StringUtils.substring(&quot;abc&quot;, -4, 2)  = &quot;ab&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get the substring from, may be null
     * @param start  the position to start from, negative means
     *  count back from the end of the String by this many characters
     * @param end  the position to end at (exclusive), negative means
     *  count back from the end of the String by this many characters
     * @return substring from start position to end positon,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String substring(String str, int start, int end) {
<span class="fc bfc" id="L1593" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L1594">            return null;</span>
        }

        // handle negatives
<span class="fc bfc" id="L1598" title="All 2 branches covered.">        if (end &lt; 0) {</span>
<span class="fc" id="L1599">            end = str.length() + end; // remember end is negative</span>
        }
<span class="fc bfc" id="L1601" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L1602">            start = str.length() + start; // remember start is negative</span>
        }

        // check length next
<span class="fc bfc" id="L1606" title="All 2 branches covered.">        if (end &gt; str.length()) {</span>
<span class="fc" id="L1607">            end = str.length();</span>
        }

        // if start is greater than end, return &quot;&quot;
<span class="fc bfc" id="L1611" title="All 2 branches covered.">        if (start &gt; end) {</span>
<span class="fc" id="L1612">            return EMPTY;</span>
        }

<span class="fc bfc" id="L1615" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L1616">            start = 0;</span>
        }
<span class="fc bfc" id="L1618" title="All 2 branches covered.">        if (end &lt; 0) {</span>
<span class="fc" id="L1619">            end = 0;</span>
        }

<span class="fc" id="L1622">        return str.substring(start, end);</span>
    }

    // Left/Right/Mid
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Gets the leftmost &lt;code&gt;len&lt;/code&gt; characters of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, or the
     * String is &lt;code&gt;null&lt;/code&gt;, the String will be returned without
     * an exception. An exception is thrown if len is negative.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.left(null, *)    = null
     * StringUtils.left(*, -ve)     = &quot;&quot;
     * StringUtils.left(&quot;&quot;, *)      = &quot;&quot;
     * StringUtils.left(&quot;abc&quot;, 0)   = &quot;&quot;
     * StringUtils.left(&quot;abc&quot;, 2)   = &quot;ab&quot;
     * StringUtils.left(&quot;abc&quot;, 4)   = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get the leftmost characters from, may be null
     * @param len  the length of the required String, must be zero or positive
     * @return the leftmost characters, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String left(String str, int len) {
<span class="fc bfc" id="L1648" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L1649">            return null;</span>
        }
<span class="fc bfc" id="L1651" title="All 2 branches covered.">        if (len &lt; 0) {</span>
<span class="fc" id="L1652">            return EMPTY;</span>
        }
<span class="fc bfc" id="L1654" title="All 2 branches covered.">        if (str.length() &lt;= len) {</span>
<span class="fc" id="L1655">            return str;</span>
        }
<span class="fc" id="L1657">        return str.substring(0, len);</span>
    }

    /**
     * &lt;p&gt;Gets the rightmost &lt;code&gt;len&lt;/code&gt; characters of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, or the String
     * is &lt;code&gt;null&lt;/code&gt;, the String will be returned without an
     * an exception. An exception is thrown if len is negative.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.right(null, *)    = null
     * StringUtils.right(*, -ve)     = &quot;&quot;
     * StringUtils.right(&quot;&quot;, *)      = &quot;&quot;
     * StringUtils.right(&quot;abc&quot;, 0)   = &quot;&quot;
     * StringUtils.right(&quot;abc&quot;, 2)   = &quot;bc&quot;
     * StringUtils.right(&quot;abc&quot;, 4)   = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get the rightmost characters from, may be null
     * @param len  the length of the required String, must be zero or positive
     * @return the rightmost characters, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String right(String str, int len) {
<span class="fc bfc" id="L1681" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L1682">            return null;</span>
        }
<span class="fc bfc" id="L1684" title="All 2 branches covered.">        if (len &lt; 0) {</span>
<span class="fc" id="L1685">            return EMPTY;</span>
        }
<span class="fc bfc" id="L1687" title="All 2 branches covered.">        if (str.length() &lt;= len) {</span>
<span class="fc" id="L1688">            return str;</span>
        }
<span class="fc" id="L1690">        return str.substring(str.length() - len);</span>
    }

    /**
     * &lt;p&gt;Gets &lt;code&gt;len&lt;/code&gt; characters from the middle of a String.&lt;/p&gt;
     *
     * &lt;p&gt;If &lt;code&gt;len&lt;/code&gt; characters are not available, the remainder
     * of the String will be returned without an exception. If the
     * String is &lt;code&gt;null&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt; will be returned.
     * An exception is thrown if len is negative.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.mid(null, *, *)    = null
     * StringUtils.mid(*, *, -ve)     = &quot;&quot;
     * StringUtils.mid(&quot;&quot;, 0, *)      = &quot;&quot;
     * StringUtils.mid(&quot;abc&quot;, 0, 2)   = &quot;ab&quot;
     * StringUtils.mid(&quot;abc&quot;, 0, 4)   = &quot;abc&quot;
     * StringUtils.mid(&quot;abc&quot;, 2, 4)   = &quot;c&quot;
     * StringUtils.mid(&quot;abc&quot;, 4, 2)   = &quot;&quot;
     * StringUtils.mid(&quot;abc&quot;, -2, 2)  = &quot;ab&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get the characters from, may be null
     * @param pos  the position to start from, negative treated as zero
     * @param len  the length of the required String, must be zero or positive
     * @return the middle characters, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String mid(String str, int pos, int len) {
<span class="fc bfc" id="L1718" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L1719">            return null;</span>
        }
<span class="fc bfc" id="L1721" title="All 4 branches covered.">        if (len &lt; 0 || pos &gt; str.length()) {</span>
<span class="fc" id="L1722">            return EMPTY;</span>
        }
<span class="fc bfc" id="L1724" title="All 2 branches covered.">        if (pos &lt; 0) {</span>
<span class="fc" id="L1725">            pos = 0;</span>
        }
<span class="fc bfc" id="L1727" title="All 2 branches covered.">        if (str.length() &lt;= (pos + len)) {</span>
<span class="fc" id="L1728">            return str.substring(pos);</span>
        }
<span class="fc" id="L1730">        return str.substring(pos, pos + len);</span>
    }

    // SubStringAfter/SubStringBefore
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Gets the substring before the first occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBefore(null, *)      = null
     * StringUtils.substringBefore(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;a&quot;)   = &quot;&quot;
     * StringUtils.substringBefore(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;d&quot;)   = &quot;abc&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, &quot;&quot;)    = &quot;&quot;
     * StringUtils.substringBefore(&quot;abc&quot;, null)  = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring before the first occurrence of the separator,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String substringBefore(String str, String separator) {
<span class="fc bfc" id="L1763" title="All 4 branches covered.">        if (isEmpty(str) || separator == null) {</span>
<span class="fc" id="L1764">            return str;</span>
        }
<span class="fc bfc" id="L1766" title="All 2 branches covered.">        if (separator.length() == 0) {</span>
<span class="fc" id="L1767">            return EMPTY;</span>
        }
<span class="fc" id="L1769">        int pos = str.indexOf(separator);</span>
<span class="fc bfc" id="L1770" title="All 2 branches covered.">        if (pos == -1) {</span>
<span class="fc" id="L1771">            return str;</span>
        }
<span class="fc" id="L1773">        return str.substring(0, pos);</span>
    }

    /**
     * &lt;p&gt;Gets the substring after the first occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; separator will return the empty string if the
     * input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfter(null, *)      = null
     * StringUtils.substringAfter(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringAfter(*, null)      = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
     * StringUtils.substringAfter(&quot;abcba&quot;, &quot;b&quot;) = &quot;cba&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;d&quot;)   = &quot;&quot;
     * StringUtils.substringAfter(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring after the first occurrence of the separator,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String substringAfter(String str, String separator) {
<span class="fc bfc" id="L1805" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L1806">            return str;</span>
        }
<span class="fc bfc" id="L1808" title="All 2 branches covered.">        if (separator == null) {</span>
<span class="fc" id="L1809">            return EMPTY;</span>
        }
<span class="fc" id="L1811">        int pos = str.indexOf(separator);</span>
<span class="fc bfc" id="L1812" title="All 2 branches covered.">        if (pos == -1) {</span>
<span class="fc" id="L1813">            return EMPTY;</span>
        }
<span class="fc" id="L1815">        return str.substring(pos + separator.length());</span>
    }

    /**
     * &lt;p&gt;Gets the substring before the last occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input will return the empty string.
     * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the input string.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the string input is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBeforeLast(null, *)      = null
     * StringUtils.substringBeforeLast(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringBeforeLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;abc&quot;
     * StringUtils.substringBeforeLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;ab&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;z&quot;)     = &quot;a&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, null)    = &quot;a&quot;
     * StringUtils.substringBeforeLast(&quot;a&quot;, &quot;&quot;)      = &quot;a&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring before the last occurrence of the separator,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String substringBeforeLast(String str, String separator) {
<span class="fc bfc" id="L1846" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(separator)) {</span>
<span class="fc" id="L1847">            return str;</span>
        }
<span class="fc" id="L1849">        int pos = str.lastIndexOf(separator);</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">        if (pos == -1) {</span>
<span class="fc" id="L1851">            return str;</span>
        }
<span class="fc" id="L1853">        return str.substring(0, pos);</span>
    }

    /**
     * &lt;p&gt;Gets the substring after the last occurrence of a separator.
     * The separator is not returned.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input will return the empty string.
     * An empty or &lt;code&gt;null&lt;/code&gt; separator will return the empty string if
     * the input string is not &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;If nothing is found, the empty string is returned.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringAfterLast(null, *)      = null
     * StringUtils.substringAfterLast(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.substringAfterLast(*, &quot;&quot;)        = &quot;&quot;
     * StringUtils.substringAfterLast(*, null)      = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;a&quot;)   = &quot;bc&quot;
     * StringUtils.substringAfterLast(&quot;abcba&quot;, &quot;b&quot;) = &quot;a&quot;
     * StringUtils.substringAfterLast(&quot;abc&quot;, &quot;c&quot;)   = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;a&quot;)     = &quot;&quot;
     * StringUtils.substringAfterLast(&quot;a&quot;, &quot;z&quot;)     = &quot;&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to get a substring from, may be null
     * @param separator  the String to search for, may be null
     * @return the substring after the last occurrence of the separator,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String substringAfterLast(String str, String separator) {
<span class="fc bfc" id="L1886" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L1887">            return str;</span>
        }
<span class="fc bfc" id="L1889" title="All 2 branches covered.">        if (isEmpty(separator)) {</span>
<span class="fc" id="L1890">            return EMPTY;</span>
        }
<span class="fc" id="L1892">        int pos = str.lastIndexOf(separator);</span>
<span class="fc bfc" id="L1893" title="All 4 branches covered.">        if (pos == -1 || pos == (str.length() - separator.length())) {</span>
<span class="fc" id="L1894">            return EMPTY;</span>
        }
<span class="fc" id="L1896">        return str.substring(pos + separator.length());</span>
    }

    // Substring between
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Gets the String that is nested in between two instances of the
     * same String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; tag returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween(null, *)            = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;)             = &quot;&quot;
     * StringUtils.substringBetween(&quot;&quot;, &quot;tag&quot;)          = null
     * StringUtils.substringBetween(&quot;tagabctag&quot;, null)  = null
     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;&quot;)    = &quot;&quot;
     * StringUtils.substringBetween(&quot;tagabctag&quot;, &quot;tag&quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substring, may be null
     * @param tag  the String before and after the substring, may be null
     * @return the substring, &lt;code&gt;null&lt;/code&gt; if no match
     * @since 2.0
     */
    public static String substringBetween(String str, String tag) {
<span class="fc" id="L1923">        return substringBetween(str, tag, tag);</span>
    }

    /**
     * &lt;p&gt;Gets the String that is nested in between two Strings.
     * Only the first match is returned.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; open/close returns &lt;code&gt;null&lt;/code&gt; (no match).
     * An empty (&quot;&quot;) open and close returns an empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringBetween(&quot;wx[b]yz&quot;, &quot;[&quot;, &quot;]&quot;) = &quot;b&quot;
     * StringUtils.substringBetween(null, *, *)          = null
     * StringUtils.substringBetween(*, null, *)          = null
     * StringUtils.substringBetween(*, *, null)          = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;&quot;)          = &quot;&quot;
     * StringUtils.substringBetween(&quot;&quot;, &quot;&quot;, &quot;]&quot;)         = null
     * StringUtils.substringBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)        = null
     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;&quot;, &quot;&quot;)     = &quot;&quot;
     * StringUtils.substringBetween(&quot;yabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
     * StringUtils.substringBetween(&quot;yabczyabcz&quot;, &quot;y&quot;, &quot;z&quot;)   = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substring, may be null
     * @param open  the String before the substring, may be null
     * @param close  the String after the substring, may be null
     * @return the substring, &lt;code&gt;null&lt;/code&gt; if no match
     * @since 2.0
     */
    public static String substringBetween(String str, String open, String close) {
<span class="fc bfc" id="L1954" title="All 6 branches covered.">        if (str == null || open == null || close == null) {</span>
<span class="fc" id="L1955">            return null;</span>
        }
<span class="fc" id="L1957">        int start = str.indexOf(open);</span>
<span class="fc bfc" id="L1958" title="All 2 branches covered.">        if (start != -1) {</span>
<span class="fc" id="L1959">            int end = str.indexOf(close, start + open.length());</span>
<span class="fc bfc" id="L1960" title="All 2 branches covered.">            if (end != -1) {</span>
<span class="fc" id="L1961">                return str.substring(start + open.length(), end);</span>
            }
        }
<span class="fc" id="L1964">        return null;</span>
    }

    /**
     * &lt;p&gt;Searches a String for substrings delimited by a start and end tag,
     * returning all matching substrings in an array.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; open/close returns &lt;code&gt;null&lt;/code&gt; (no match).
     * An empty (&quot;&quot;) open/close returns &lt;code&gt;null&lt;/code&gt; (no match).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.substringsBetween(&quot;[a][b][c]&quot;, &quot;[&quot;, &quot;]&quot;) = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]
     * StringUtils.substringsBetween(null, *, *)            = null
     * StringUtils.substringsBetween(*, null, *)            = null
     * StringUtils.substringsBetween(*, *, null)            = null
     * StringUtils.substringsBetween(&quot;&quot;, &quot;[&quot;, &quot;]&quot;)          = []
     * &lt;/pre&gt;
     *
     * @param str  the String containing the substrings, null returns null, empty returns empty
     * @param open  the String identifying the start of the substring, empty returns null
     * @param close  the String identifying the end of the substring, empty returns null
     * @return a String Array of substrings, or &lt;code&gt;null&lt;/code&gt; if no match
     * @since 2.3
     */
    public static String[] substringsBetween(String str, String open, String close) {
<span class="fc bfc" id="L1990" title="All 6 branches covered.">        if (str == null || isEmpty(open) || isEmpty(close)) {</span>
<span class="fc" id="L1991">            return null;</span>
        }
<span class="fc" id="L1993">        int strLen = str.length();</span>
<span class="fc bfc" id="L1994" title="All 2 branches covered.">        if (strLen == 0) {</span>
<span class="fc" id="L1995">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L1997">        int closeLen = close.length();</span>
<span class="fc" id="L1998">        int openLen = open.length();</span>
<span class="fc" id="L1999">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2000">        int pos = 0;</span>
<span class="fc bfc" id="L2001" title="All 2 branches covered.">        while (pos &lt; (strLen - closeLen)) {</span>
<span class="fc" id="L2002">            int start = str.indexOf(open, pos);</span>
<span class="fc bfc" id="L2003" title="All 2 branches covered.">            if (start &lt; 0) {</span>
<span class="fc" id="L2004">                break;</span>
            }
<span class="fc" id="L2006">            start += openLen;</span>
<span class="fc" id="L2007">            int end = str.indexOf(close, start);</span>
<span class="fc bfc" id="L2008" title="All 2 branches covered.">            if (end &lt; 0) {</span>
<span class="fc" id="L2009">                break;</span>
            }
<span class="fc" id="L2011">            list.add(str.substring(start, end));</span>
<span class="fc" id="L2012">            pos = end + closeLen;</span>
<span class="fc" id="L2013">        }</span>
<span class="fc bfc" id="L2014" title="All 2 branches covered.">        if (list.isEmpty()) {</span>
<span class="fc" id="L2015">            return null;</span>
        } 
<span class="fc" id="L2017">        return list.toArray(new String [list.size()]);</span>
    }

    // Nested extraction
    //-----------------------------------------------------------------------

    // Splitting
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
     * separator.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null)       = null
     * StringUtils.split(&quot;&quot;)         = []
     * StringUtils.split(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.split(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.split(&quot; abc &quot;)    = [&quot;abc&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String[] split(String str) {
<span class="fc" id="L2048">        return split(str, null, -1);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator specified.
     * This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *)         = null
     * StringUtils.split(&quot;&quot;, *)           = []
     * StringUtils.split(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.split(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.split(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
     * StringUtils.split(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChar  the character used as the delimiter
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String[] split(String str, char separatorChar) {
<span class="fc" id="L2076">        return splitWorker(str, separatorChar, false);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separators specified.
     * This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *)         = null
     * StringUtils.split(&quot;&quot;, *)           = []
     * StringUtils.split(&quot;abc def&quot;, null) = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.split(&quot;abc def&quot;, &quot; &quot;)  = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.split(&quot;abc  def&quot;, &quot; &quot;) = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String[] split(String str, String separatorChars) {
<span class="fc" id="L2105">        return splitWorker(str, separatorChars, -1, false);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array with a maximum length,
     * separators specified.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
     * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
     * returned strings (including separator characters).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.split(null, *, *)            = null
     * StringUtils.split(&quot;&quot;, *, *)              = []
     * StringUtils.split(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.split(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.split(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separatorChars  the characters used as the delimiters,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String[] split(String str, String separatorChars, int max) {
<span class="fc" id="L2139">        return splitWorker(str, separatorChars, max, false);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.&lt;/p&gt;
     *
     * &lt;p&gt;The separator(s) will not be included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparator(null, *)               = null
     * StringUtils.splitByWholeSeparator(&quot;&quot;, *)                 = []
     * StringUtils.splitByWholeSeparator(&quot;ab de fg&quot;, null)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab   de fg&quot;, null)    = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab:cd:ef&quot;, &quot;:&quot;)       = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
     */
    public static String[] splitByWholeSeparator(String str, String separator) {
<span class="fc" id="L2166">        return splitByWholeSeparatorWorker( str, separator, -1, false ) ;</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.
     * Returns a maximum of &lt;code&gt;max&lt;/code&gt; substrings.&lt;/p&gt;
     *
     * &lt;p&gt;The separator(s) will not be included in the returned String array.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparator(null, *, *)               = null
     * StringUtils.splitByWholeSeparator(&quot;&quot;, *, *)                 = []
     * StringUtils.splitByWholeSeparator(&quot;ab de fg&quot;, null, 0)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab   de fg&quot;, null, 0)    = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)       = [&quot;ab&quot;, &quot;cd:ef&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 5) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitByWholeSeparator(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 2) = [&quot;ab&quot;, &quot;cd-!-ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
     */
    public static String[] splitByWholeSeparator( String str, String separator, int max ) {
<span class="fc" id="L2197">        return splitByWholeSeparatorWorker(str, separator, max, false);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator string specified. &lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *)               = null
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;&quot;, *)                 = []
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab de fg&quot;, null)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab   de fg&quot;, null)    = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)       = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
     * @since 2.4
     */
    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator) {
<span class="nc" id="L2226">        return splitByWholeSeparatorWorker(str, separator, -1, true);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator string specified.
     * Returns a maximum of &lt;code&gt;max&lt;/code&gt; substrings.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separator splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(null, *, *)               = null
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;&quot;, *, *)                 = []
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab de fg&quot;, null, 0)      = [&quot;ab&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab   de fg&quot;, null, 0)    = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de&quot;, &quot;fg&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)       = [&quot;ab&quot;, &quot;cd:ef&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 5) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitByWholeSeparatorPreserveAllTokens(&quot;ab-!-cd-!-ef&quot;, &quot;-!-&quot;, 2) = [&quot;ab&quot;, &quot;cd-!-ef&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be null
     * @param separator  String containing the String to be used as a delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String was input
     * @since 2.4
     */
    public static String[] splitByWholeSeparatorPreserveAllTokens(String str, String separator, int max) {
<span class="fc" id="L2259">        return splitByWholeSeparatorWorker(str, separator, max, true);</span>
    }

    /**
     * Performs the logic for the &lt;code&gt;splitByWholeSeparatorPreserveAllTokens&lt;/code&gt; methods.
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separator  String containing the String to be used as a delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @param max  the maximum number of elements to include in the returned
     *  array. A zero or negative value implies no limit.
     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    private static String[] splitByWholeSeparatorWorker(String str, String separator, int max, 
                                                        boolean preserveAllTokens) 
    {
<span class="fc bfc" id="L2279" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L2280">            return null;</span>
        }

<span class="fc" id="L2283">        int len = str.length();</span>

<span class="fc bfc" id="L2285" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L2286">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }

<span class="pc bpc" id="L2289" title="1 of 4 branches missed.">        if ((separator == null) || (EMPTY.equals(separator))) {</span>
            // Split on whitespace.
<span class="fc" id="L2291">            return splitWorker(str, null, max, preserveAllTokens);</span>
        }

<span class="fc" id="L2294">        int separatorLength = separator.length();</span>

<span class="fc" id="L2296">        ArrayList&lt;String&gt; substrings = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2297">        int numberOfSubstrings = 0;</span>
<span class="fc" id="L2298">        int beg = 0;</span>
<span class="fc" id="L2299">        int end = 0;</span>
<span class="fc bfc" id="L2300" title="All 2 branches covered.">        while (end &lt; len) {</span>
<span class="fc" id="L2301">            end = str.indexOf(separator, beg);</span>

<span class="fc bfc" id="L2303" title="All 2 branches covered.">            if (end &gt; -1) {</span>
<span class="fc bfc" id="L2304" title="All 2 branches covered.">                if (end &gt; beg) {</span>
<span class="fc" id="L2305">                    numberOfSubstrings += 1;</span>

<span class="fc bfc" id="L2307" title="All 2 branches covered.">                    if (numberOfSubstrings == max) {</span>
<span class="fc" id="L2308">                        end = len;</span>
<span class="fc" id="L2309">                        substrings.add(str.substring(beg));</span>
                    } else {
                        // The following is OK, because String.substring( beg, end ) excludes
                        // the character at the position 'end'.
<span class="fc" id="L2313">                        substrings.add(str.substring(beg, end));</span>

                        // Set the starting point for the next search.
                        // The following is equivalent to beg = end + (separatorLength - 1) + 1,
                        // which is the right calculation:
<span class="fc" id="L2318">                        beg = end + separatorLength;</span>
                    }
                } else {
                    // We found a consecutive occurrence of the separator, so skip it.
<span class="fc bfc" id="L2322" title="All 2 branches covered.">                    if (preserveAllTokens) {</span>
<span class="fc" id="L2323">                        numberOfSubstrings += 1;</span>
<span class="fc bfc" id="L2324" title="All 2 branches covered.">                        if (numberOfSubstrings == max) {</span>
<span class="fc" id="L2325">                            end = len;</span>
<span class="fc" id="L2326">                            substrings.add(str.substring(beg));</span>
                        } else {
<span class="fc" id="L2328">                            substrings.add(EMPTY);</span>
                        }
                    }
<span class="fc" id="L2331">                    beg = end + separatorLength;</span>
                }
            } else {
                // String.substring( beg ) goes from 'beg' to the end of the String.
<span class="fc" id="L2335">                substrings.add(str.substring(beg));</span>
<span class="fc" id="L2336">                end = len;</span>
            }
        }

<span class="fc" id="L2340">        return substrings.toArray(new String[substrings.size()]);</span>
    }

    // -----------------------------------------------------------------------
    /**
     * &lt;p&gt;Splits the provided text into an array, using whitespace as the
     * separator, preserving all tokens, including empty tokens created by 
     * adjacent separators. This is an alternative to using StringTokenizer.
     * Whitespace is defined by {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null)       = null
     * StringUtils.splitPreserveAllTokens(&quot;&quot;)         = []
     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;)  = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;) = [&quot;abc&quot;, &quot;&quot;, &quot;def&quot;]
     * StringUtils.splitPreserveAllTokens(&quot; abc &quot;)    = [&quot;&quot;, &quot;abc&quot;, &quot;&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(String str) {
<span class="fc" id="L2369">        return splitWorker(str, null, -1, true);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separator specified,
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *)         = null
     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)           = []
     * StringUtils.splitPreserveAllTokens(&quot;a.b.c&quot;, '.')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a..b.c&quot;, '.')   = [&quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a:b:c&quot;, '.')    = [&quot;a:b:c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a\tb\nc&quot;, null) = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a b c&quot;, ' ')    = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a b c &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;a b c  &quot;, ' ')   = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]
     * StringUtils.splitPreserveAllTokens(&quot; a b c&quot;, ' ')   = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;  a b c&quot;, ' ')  = [&quot;&quot;, &quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;]
     * StringUtils.splitPreserveAllTokens(&quot; a b c &quot;, ' ')  = [&quot;&quot;, a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separatorChar  the character used as the delimiter,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(String str, char separatorChar) {
<span class="fc" id="L2405">        return splitWorker(str, separatorChar, true);</span>
    }

    /**
     * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
     * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that do not return a
     * maximum array length.
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separatorChar the separate character
     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    private static String[] splitWorker(String str, char separatorChar, boolean preserveAllTokens) {
        // Performance tuned for 2.0 (JDK1.4)

<span class="fc bfc" id="L2423" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L2424">            return null;</span>
        }
<span class="fc" id="L2426">        int len = str.length();</span>
<span class="fc bfc" id="L2427" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L2428">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L2430">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2431">        int i = 0, start = 0;</span>
<span class="fc" id="L2432">        boolean match = false;</span>
<span class="fc" id="L2433">        boolean lastMatch = false;</span>
<span class="fc bfc" id="L2434" title="All 2 branches covered.">        while (i &lt; len) {</span>
<span class="fc bfc" id="L2435" title="All 2 branches covered.">            if (str.charAt(i) == separatorChar) {</span>
<span class="fc bfc" id="L2436" title="All 4 branches covered.">                if (match || preserveAllTokens) {</span>
<span class="fc" id="L2437">                    list.add(str.substring(start, i));</span>
<span class="fc" id="L2438">                    match = false;</span>
<span class="fc" id="L2439">                    lastMatch = true;</span>
                }
<span class="fc" id="L2441">                start = ++i;</span>
<span class="fc" id="L2442">                continue;</span>
            }
<span class="fc" id="L2444">            lastMatch = false;</span>
<span class="fc" id="L2445">            match = true;</span>
<span class="fc" id="L2446">            i++;</span>
        }
<span class="pc bpc" id="L2448" title="1 of 6 branches missed.">        if (match || (preserveAllTokens &amp;&amp; lastMatch)) {</span>
<span class="fc" id="L2449">            list.add(str.substring(start, i));</span>
        }
<span class="fc" id="L2451">        return list.toArray(new String[list.size()]);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array, separators specified, 
     * preserving all tokens, including empty tokens created by adjacent
     * separators. This is an alternative to using StringTokenizer.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * For more control over the split use the StrTokenizer class.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *)           = null
     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *)             = []
     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, null)   = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;abc def&quot;, &quot; &quot;)    = [&quot;abc&quot;, &quot;def&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;abc  def&quot;, &quot; &quot;)   = [&quot;abc&quot;, &quot;&quot;, def&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef:&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef::&quot;, &quot;:&quot;) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;, &quot;&quot;, &quot;&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab::cd:ef&quot;, &quot;:&quot;)  = [&quot;ab&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;:cd:ef&quot;, &quot;:&quot;)     = [&quot;&quot;, cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;::cd:ef&quot;, &quot;:&quot;)    = [&quot;&quot;, &quot;&quot;, cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;:cd:ef:&quot;, &quot;:&quot;)    = [&quot;&quot;, cd&quot;, &quot;ef&quot;, &quot;&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separatorChars  the characters used as the delimiters,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(String str, String separatorChars) {
<span class="fc" id="L2488">        return splitWorker(str, separatorChars, -1, true);</span>
    }

    /**
     * &lt;p&gt;Splits the provided text into an array with a maximum length,
     * separators specified, preserving all tokens, including empty tokens 
     * created by adjacent separators.&lt;/p&gt;
     *
     * &lt;p&gt;The separator is not included in the returned String array.
     * Adjacent separators are treated as separators for empty tokens.
     * Adjacent separators are treated as one separator.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; separatorChars splits on whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;If more than &lt;code&gt;max&lt;/code&gt; delimited substrings are found, the last
     * returned string includes all characters after the first &lt;code&gt;max - 1&lt;/code&gt;
     * returned strings (including separator characters).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.splitPreserveAllTokens(null, *, *)            = null
     * StringUtils.splitPreserveAllTokens(&quot;&quot;, *, *)              = []
     * StringUtils.splitPreserveAllTokens(&quot;ab de fg&quot;, null, 0)   = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 0) = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 0)    = [&quot;ab&quot;, &quot;cd&quot;, &quot;ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab:cd:ef&quot;, &quot;:&quot;, 2)    = [&quot;ab&quot;, &quot;cd:ef&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 2) = [&quot;ab&quot;, &quot;  de fg&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 3) = [&quot;ab&quot;, &quot;&quot;, &quot; de fg&quot;]
     * StringUtils.splitPreserveAllTokens(&quot;ab   de fg&quot;, null, 4) = [&quot;ab&quot;, &quot;&quot;, &quot;&quot;, &quot;de fg&quot;]
     * &lt;/pre&gt;
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separatorChars  the characters used as the delimiters,
     *  &lt;code&gt;null&lt;/code&gt; splits on whitespace
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String[] splitPreserveAllTokens(String str, String separatorChars, int max) {
<span class="fc" id="L2528">        return splitWorker(str, separatorChars, max, true);</span>
    }

    /**
     * Performs the logic for the &lt;code&gt;split&lt;/code&gt; and 
     * &lt;code&gt;splitPreserveAllTokens&lt;/code&gt; methods that return a maximum array 
     * length.
     *
     * @param str  the String to parse, may be &lt;code&gt;null&lt;/code&gt;
     * @param separatorChars the separate character
     * @param max  the maximum number of elements to include in the
     *  array. A zero or negative value implies no limit.
     * @param preserveAllTokens if &lt;code&gt;true&lt;/code&gt;, adjacent separators are
     * treated as empty token separators; if &lt;code&gt;false&lt;/code&gt;, adjacent
     * separators are treated as one separator.
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    private static String[] splitWorker(String str, String separatorChars, int max, boolean preserveAllTokens) {
        // Performance tuned for 2.0 (JDK1.4)
        // Direct code is quicker than StringTokenizer.
        // Also, StringTokenizer uses isSpace() not isWhitespace()

<span class="fc bfc" id="L2550" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L2551">            return null;</span>
        }
<span class="fc" id="L2553">        int len = str.length();</span>
<span class="fc bfc" id="L2554" title="All 2 branches covered.">        if (len == 0) {</span>
<span class="fc" id="L2555">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L2557">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2558">        int sizePlus1 = 1;</span>
<span class="fc" id="L2559">        int i = 0, start = 0;</span>
<span class="fc" id="L2560">        boolean match = false;</span>
<span class="fc" id="L2561">        boolean lastMatch = false;</span>
<span class="fc bfc" id="L2562" title="All 2 branches covered.">        if (separatorChars == null) {</span>
            // Null separator means use whitespace
<span class="fc bfc" id="L2564" title="All 2 branches covered.">            while (i &lt; len) {</span>
<span class="fc bfc" id="L2565" title="All 2 branches covered.">                if (Character.isWhitespace(str.charAt(i))) {</span>
<span class="fc bfc" id="L2566" title="All 4 branches covered.">                    if (match || preserveAllTokens) {</span>
<span class="fc" id="L2567">                        lastMatch = true;</span>
<span class="fc bfc" id="L2568" title="All 2 branches covered.">                        if (sizePlus1++ == max) {</span>
<span class="fc" id="L2569">                            i = len;</span>
<span class="fc" id="L2570">                            lastMatch = false;</span>
                        }
<span class="fc" id="L2572">                        list.add(str.substring(start, i));</span>
<span class="fc" id="L2573">                        match = false;</span>
                    }
<span class="fc" id="L2575">                    start = ++i;</span>
<span class="fc" id="L2576">                    continue;</span>
                }
<span class="fc" id="L2578">                lastMatch = false;</span>
<span class="fc" id="L2579">                match = true;</span>
<span class="fc" id="L2580">                i++;</span>
            }
<span class="fc bfc" id="L2582" title="All 2 branches covered.">        } else if (separatorChars.length() == 1) {</span>
            // Optimise 1 character case
<span class="fc" id="L2584">            char sep = separatorChars.charAt(0);</span>
<span class="fc bfc" id="L2585" title="All 2 branches covered.">            while (i &lt; len) {</span>
<span class="fc bfc" id="L2586" title="All 2 branches covered.">                if (str.charAt(i) == sep) {</span>
<span class="fc bfc" id="L2587" title="All 4 branches covered.">                    if (match || preserveAllTokens) {</span>
<span class="fc" id="L2588">                        lastMatch = true;</span>
<span class="fc bfc" id="L2589" title="All 2 branches covered.">                        if (sizePlus1++ == max) {</span>
<span class="fc" id="L2590">                            i = len;</span>
<span class="fc" id="L2591">                            lastMatch = false;</span>
                        }
<span class="fc" id="L2593">                        list.add(str.substring(start, i));</span>
<span class="fc" id="L2594">                        match = false;</span>
                    }
<span class="fc" id="L2596">                    start = ++i;</span>
<span class="fc" id="L2597">                    continue;</span>
                }
<span class="fc" id="L2599">                lastMatch = false;</span>
<span class="fc" id="L2600">                match = true;</span>
<span class="fc" id="L2601">                i++;</span>
            }
<span class="fc" id="L2603">        } else {</span>
            // standard case
<span class="fc bfc" id="L2605" title="All 2 branches covered.">            while (i &lt; len) {</span>
<span class="fc bfc" id="L2606" title="All 2 branches covered.">                if (separatorChars.indexOf(str.charAt(i)) &gt;= 0) {</span>
<span class="fc bfc" id="L2607" title="All 4 branches covered.">                    if (match || preserveAllTokens) {</span>
<span class="fc" id="L2608">                        lastMatch = true;</span>
<span class="fc bfc" id="L2609" title="All 2 branches covered.">                        if (sizePlus1++ == max) {</span>
<span class="fc" id="L2610">                            i = len;</span>
<span class="fc" id="L2611">                            lastMatch = false;</span>
                        }
<span class="fc" id="L2613">                        list.add(str.substring(start, i));</span>
<span class="fc" id="L2614">                        match = false;</span>
                    }
<span class="fc" id="L2616">                    start = ++i;</span>
<span class="fc" id="L2617">                    continue;</span>
                }
<span class="fc" id="L2619">                lastMatch = false;</span>
<span class="fc" id="L2620">                match = true;</span>
<span class="fc" id="L2621">                i++;</span>
            }
        }
<span class="fc bfc" id="L2624" title="All 6 branches covered.">        if (match || (preserveAllTokens &amp;&amp; lastMatch)) {</span>
<span class="fc" id="L2625">            list.add(str.substring(start, i));</span>
        }
<span class="fc" id="L2627">        return list.toArray(new String[list.size()]);</span>
    }

    /**
     * &lt;p&gt;Splits a String by Character type as returned by
     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
     * characters of the same type are returned as complete tokens. 
     * &lt;pre&gt;
     * StringUtils.splitByCharacterType(null)         = null
     * StringUtils.splitByCharacterType(&quot;&quot;)           = []
     * StringUtils.splitByCharacterType(&quot;ab de fg&quot;)   = [&quot;ab&quot;, &quot; &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
     * StringUtils.splitByCharacterType(&quot;ab   de fg&quot;) = [&quot;ab&quot;, &quot;   &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
     * StringUtils.splitByCharacterType(&quot;ab:cd:ef&quot;)   = [&quot;ab&quot;, &quot;:&quot;, &quot;cd&quot;, &quot;:&quot;, &quot;ef&quot;]
     * StringUtils.splitByCharacterType(&quot;number5&quot;)    = [&quot;number&quot;, &quot;5&quot;]
     * StringUtils.splitByCharacterType(&quot;fooBar&quot;)     = [&quot;foo&quot;, &quot;B&quot;, &quot;ar&quot;]
     * StringUtils.splitByCharacterType(&quot;foo200Bar&quot;)  = [&quot;foo&quot;, &quot;200&quot;, &quot;B&quot;, &quot;ar&quot;]
     * StringUtils.splitByCharacterType(&quot;ASFRules&quot;)   = [&quot;ASFR&quot;, &quot;ules&quot;]
     * &lt;/pre&gt;
     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    public static String[] splitByCharacterType(String str) {
<span class="fc" id="L2650">        return splitByCharacterType(str, false);</span>
    }

    /**
     * &lt;p&gt;Splits a String by Character type as returned by
     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
     * characters of the same type are returned as complete tokens, with the
     * following exception: the character of type
     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt;, if any, immediately
     * preceding a token of type &lt;code&gt;Character.LOWERCASE_LETTER&lt;/code&gt;
     * will belong to the following token rather than to the preceding, if any,
     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt; token. 
     * &lt;pre&gt;
     * StringUtils.splitByCharacterTypeCamelCase(null)         = null
     * StringUtils.splitByCharacterTypeCamelCase(&quot;&quot;)           = []
     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab de fg&quot;)   = [&quot;ab&quot;, &quot; &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab   de fg&quot;) = [&quot;ab&quot;, &quot;   &quot;, &quot;de&quot;, &quot; &quot;, &quot;fg&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;ab:cd:ef&quot;)   = [&quot;ab&quot;, &quot;:&quot;, &quot;cd&quot;, &quot;:&quot;, &quot;ef&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;number5&quot;)    = [&quot;number&quot;, &quot;5&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;fooBar&quot;)     = [&quot;foo&quot;, &quot;Bar&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;foo200Bar&quot;)  = [&quot;foo&quot;, &quot;200&quot;, &quot;Bar&quot;]
     * StringUtils.splitByCharacterTypeCamelCase(&quot;ASFRules&quot;)   = [&quot;ASF&quot;, &quot;Rules&quot;]
     * &lt;/pre&gt;
     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    public static String[] splitByCharacterTypeCamelCase(String str) {
<span class="fc" id="L2678">        return splitByCharacterType(str, true);</span>
    }

    /**
     * &lt;p&gt;Splits a String by Character type as returned by
     * &lt;code&gt;java.lang.Character.getType(char)&lt;/code&gt;. Groups of contiguous
     * characters of the same type are returned as complete tokens, with the
     * following exception: if &lt;code&gt;camelCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;,
     * the character of type &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt;, if any,
     * immediately preceding a token of type &lt;code&gt;Character.LOWERCASE_LETTER&lt;/code&gt;
     * will belong to the following token rather than to the preceding, if any,
     * &lt;code&gt;Character.UPPERCASE_LETTER&lt;/code&gt; token. 
     * @param str the String to split, may be &lt;code&gt;null&lt;/code&gt;
     * @param camelCase whether to use so-called &quot;camel-case&quot; for letter types
     * @return an array of parsed Strings, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    private static String[] splitByCharacterType(String str, boolean camelCase) {
<span class="fc bfc" id="L2696" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L2697">            return null;</span>
        }
<span class="fc bfc" id="L2699" title="All 2 branches covered.">        if (str.length() == 0) {</span>
<span class="fc" id="L2700">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L2702">        char[] c = str.toCharArray();</span>
<span class="fc" id="L2703">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L2704">        int tokenStart = 0;</span>
<span class="fc" id="L2705">        int currentType = Character.getType(c[tokenStart]);</span>
<span class="fc bfc" id="L2706" title="All 2 branches covered.">        for (int pos = tokenStart + 1; pos &lt; c.length; pos++) {</span>
<span class="fc" id="L2707">            int type = Character.getType(c[pos]);</span>
<span class="fc bfc" id="L2708" title="All 2 branches covered.">            if (type == currentType) {</span>
<span class="fc" id="L2709">                continue;</span>
            }
<span class="fc bfc" id="L2711" title="All 6 branches covered.">            if (camelCase &amp;&amp; type == Character.LOWERCASE_LETTER &amp;&amp; currentType == Character.UPPERCASE_LETTER) {</span>
<span class="fc" id="L2712">                int newTokenStart = pos - 1;</span>
<span class="fc bfc" id="L2713" title="All 2 branches covered.">                if (newTokenStart != tokenStart) {</span>
<span class="fc" id="L2714">                    list.add(new String(c, tokenStart, newTokenStart - tokenStart));</span>
<span class="fc" id="L2715">                    tokenStart = newTokenStart;</span>
                }
<span class="fc" id="L2717">            } else {</span>
<span class="fc" id="L2718">                list.add(new String(c, tokenStart, pos - tokenStart));</span>
<span class="fc" id="L2719">                tokenStart = pos;</span>
            }
<span class="fc" id="L2721">            currentType = type;</span>
        }
<span class="fc" id="L2723">        list.add(new String(c, tokenStart, c.length - tokenStart));</span>
<span class="fc" id="L2724">        return list.toArray(new String[list.size()]);</span>
    }

    // Joining
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No separator is added to the joined String.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null)            = null
     * StringUtils.join([])              = &quot;&quot;
     * StringUtils.join([null])          = &quot;&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]) = &quot;abc&quot;
     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;]) = &quot;a&quot;
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
     * @since 2.0
     */
    public static String join(Object[] array) {
<span class="fc" id="L2750">        return join(array, null);</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = &quot;&quot;
     * StringUtils.join([null], *)             = &quot;&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], ';')  = &quot;a;b;c&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ';')  = &quot;;;a&quot;
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
     * @since 2.0
     */
    public static String join(Object[] array, char separator) {
<span class="fc bfc" id="L2776" title="All 2 branches covered.">        if (array == null) {</span>
<span class="fc" id="L2777">            return null;</span>
        }

<span class="fc" id="L2780">        return join(array, separator, 0, array.length);</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)               = null
     * StringUtils.join([], *)                 = &quot;&quot;
     * StringUtils.join([null], *)             = &quot;&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], ';')  = &quot;a;b;c&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null) = &quot;abc&quot;
     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ';')  = &quot;;;a&quot;
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use
     * @param startIndex the first index to start joining from.  It is
     * an error to pass in an end index past the end of the array
     * @param endIndex the index to stop joining from (exclusive). It is
     * an error to pass in an end index past the end of the array
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
     * @since 2.0
     */
    public static String join(Object[] array, char separator, int startIndex, int endIndex) {
<span class="pc bpc" id="L2810" title="1 of 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L2811">            return null;</span>
        }
<span class="fc" id="L2813">        int bufSize = (endIndex - startIndex);</span>
<span class="fc bfc" id="L2814" title="All 2 branches covered.">        if (bufSize &lt;= 0) {</span>
<span class="fc" id="L2815">            return EMPTY;</span>
        }

<span class="fc bfc" id="L2818" title="All 2 branches covered.">        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length()) + 1);</span>
<span class="fc" id="L2819">        StringBuilder buf = new StringBuilder(bufSize);</span>

<span class="fc bfc" id="L2821" title="All 2 branches covered.">        for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="fc bfc" id="L2822" title="All 2 branches covered.">            if (i &gt; startIndex) {</span>
<span class="fc" id="L2823">                buf.append(separator);</span>
            }
<span class="fc bfc" id="L2825" title="All 2 branches covered.">            if (array[i] != null) {</span>
<span class="fc" id="L2826">                buf.append(array[i]);</span>
            }
        }
<span class="fc" id="L2829">        return buf.toString();</span>
    }


    /**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)                = null
     * StringUtils.join([], *)                  = &quot;&quot;
     * StringUtils.join([null], *)              = &quot;&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ',')   = &quot;,,a&quot;
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use, null treated as &quot;&quot;
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
     */
    public static String join(Object[] array, String separator) {
<span class="fc bfc" id="L2857" title="All 2 branches covered.">        if (array == null) {</span>
<span class="fc" id="L2858">            return null;</span>
        }
<span class="fc" id="L2860">        return join(array, separator, 0, array.length);</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided array into a single String
     * containing the provided list of elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).
     * Null objects or empty strings within the array are represented by
     * empty strings.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.join(null, *)                = null
     * StringUtils.join([], *)                  = &quot;&quot;
     * StringUtils.join([null], *)              = &quot;&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;--&quot;)  = &quot;a--b--c&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], null)  = &quot;abc&quot;
     * StringUtils.join([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], &quot;&quot;)    = &quot;abc&quot;
     * StringUtils.join([null, &quot;&quot;, &quot;a&quot;], ',')   = &quot;,,a&quot;
     * &lt;/pre&gt;
     *
     * @param array  the array of values to join together, may be null
     * @param separator  the separator character to use, null treated as &quot;&quot;
     * @param startIndex the first index to start joining from.  It is
     * an error to pass in an end index past the end of the array
     * @param endIndex the index to stop joining from (exclusive). It is
     * an error to pass in an end index past the end of the array
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null array input
     */
    public static String join(Object[] array, String separator, int startIndex, int endIndex) {
<span class="pc bpc" id="L2891" title="1 of 2 branches missed.">        if (array == null) {</span>
<span class="nc" id="L2892">            return null;</span>
        }
<span class="fc bfc" id="L2894" title="All 2 branches covered.">        if (separator == null) {</span>
<span class="fc" id="L2895">            separator = EMPTY;</span>
        }

        // endIndex - startIndex &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))
        //           (Assuming that all Strings are roughly equally long)
<span class="fc" id="L2900">        int bufSize = (endIndex - startIndex);</span>
<span class="fc bfc" id="L2901" title="All 2 branches covered.">        if (bufSize &lt;= 0) {</span>
<span class="fc" id="L2902">            return EMPTY;</span>
        }

<span class="fc bfc" id="L2905" title="All 2 branches covered.">        bufSize *= ((array[startIndex] == null ? 16 : array[startIndex].toString().length())</span>
<span class="fc" id="L2906">                        + separator.length());</span>

<span class="fc" id="L2908">        StringBuilder buf = new StringBuilder(bufSize);</span>

<span class="fc bfc" id="L2910" title="All 2 branches covered.">        for (int i = startIndex; i &lt; endIndex; i++) {</span>
<span class="fc bfc" id="L2911" title="All 2 branches covered.">            if (i &gt; startIndex) {</span>
<span class="fc" id="L2912">                buf.append(separator);</span>
            }
<span class="fc bfc" id="L2914" title="All 2 branches covered.">            if (array[i] != null) {</span>
<span class="fc" id="L2915">                buf.append(array[i]);</span>
            }
        }
<span class="fc" id="L2918">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
     * strings within the iteration are represented by empty strings.&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
     *
     * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
     * @since 2.0
     */
    public static String join(Iterator&lt;?&gt; iterator, char separator) {

        // handle null, zero and one elements before building a buffer
<span class="fc bfc" id="L2938" title="All 2 branches covered.">        if (iterator == null) {</span>
<span class="fc" id="L2939">            return null;</span>
        }
<span class="fc bfc" id="L2941" title="All 2 branches covered.">        if (!iterator.hasNext()) {</span>
<span class="fc" id="L2942">            return EMPTY;</span>
        }
<span class="fc" id="L2944">        Object first = iterator.next();</span>
<span class="fc bfc" id="L2945" title="All 2 branches covered.">        if (!iterator.hasNext()) {</span>
<span class="fc" id="L2946">            return ObjectUtils.toString(first);</span>
        }

        // two or more elements
<span class="fc" id="L2950">        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small</span>
<span class="pc bpc" id="L2951" title="1 of 2 branches missed.">        if (first != null) {</span>
<span class="fc" id="L2952">            buf.append(first);</span>
        }

<span class="fc bfc" id="L2955" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L2956">            buf.append(separator);</span>
<span class="fc" id="L2957">            Object obj = iterator.next();</span>
<span class="pc bpc" id="L2958" title="1 of 2 branches missed.">            if (obj != null) {</span>
<span class="fc" id="L2959">                buf.append(obj);</span>
            }
<span class="fc" id="L2961">        }</span>

<span class="fc" id="L2963">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Iterator&lt;/code&gt; into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
     *
     * @param iterator  the &lt;code&gt;Iterator&lt;/code&gt; of values to join together, may be null
     * @param separator  the separator character to use, null treated as &quot;&quot;
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
     */
    public static String join(Iterator&lt;?&gt; iterator, String separator) {

        // handle null, zero and one elements before building a buffer
<span class="fc bfc" id="L2982" title="All 2 branches covered.">        if (iterator == null) {</span>
<span class="fc" id="L2983">            return null;</span>
        }
<span class="fc bfc" id="L2985" title="All 2 branches covered.">        if (!iterator.hasNext()) {</span>
<span class="fc" id="L2986">            return EMPTY;</span>
        }
<span class="fc" id="L2988">        Object first = iterator.next();</span>
<span class="fc bfc" id="L2989" title="All 2 branches covered.">        if (!iterator.hasNext()) {</span>
<span class="fc" id="L2990">            return ObjectUtils.toString(first);</span>
        }

        // two or more elements
<span class="fc" id="L2994">        StringBuilder buf = new StringBuilder(256); // Java default is 16, probably too small</span>
<span class="pc bpc" id="L2995" title="1 of 2 branches missed.">        if (first != null) {</span>
<span class="fc" id="L2996">            buf.append(first);</span>
        }

<span class="fc bfc" id="L2999" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc bfc" id="L3000" title="All 2 branches covered.">            if (separator != null) {</span>
<span class="fc" id="L3001">                buf.append(separator);</span>
            }
<span class="fc" id="L3003">            Object obj = iterator.next();</span>
<span class="pc bpc" id="L3004" title="1 of 2 branches missed.">            if (obj != null) {</span>
<span class="fc" id="L3005">                buf.append(obj);</span>
            }
<span class="fc" id="L3007">        }</span>
<span class="fc" id="L3008">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Collection&lt;/code&gt; into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list. Null objects or empty
     * strings within the iteration are represented by empty strings.&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],char)}. &lt;/p&gt;
     *
     * @param collection  the &lt;code&gt;Collection&lt;/code&gt; of values to join together, may be null
     * @param separator  the separator character to use
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
     * @since 2.3
     */
    public static String join(Collection&lt;?&gt; collection, char separator) {
<span class="fc bfc" id="L3026" title="All 2 branches covered.">        if (collection == null) {</span>
<span class="fc" id="L3027">            return null;</span>
        }
<span class="fc" id="L3029">        return join(collection.iterator(), separator);</span>
    }

    /**
     * &lt;p&gt;Joins the elements of the provided &lt;code&gt;Collection&lt;/code&gt; into
     * a single String containing the provided elements.&lt;/p&gt;
     *
     * &lt;p&gt;No delimiter is added before or after the list.
     * A &lt;code&gt;null&lt;/code&gt; separator is the same as an empty String (&quot;&quot;).&lt;/p&gt;
     *
     * &lt;p&gt;See the examples here: {@link #join(Object[],String)}. &lt;/p&gt;
     *
     * @param collection  the &lt;code&gt;Collection&lt;/code&gt; of values to join together, may be null
     * @param separator  the separator character to use, null treated as &quot;&quot;
     * @return the joined String, &lt;code&gt;null&lt;/code&gt; if null iterator input
     * @since 2.3
     */
    public static String join(Collection&lt;?&gt; collection, String separator) {
<span class="fc bfc" id="L3047" title="All 2 branches covered.">        if (collection == null) {</span>
<span class="fc" id="L3048">            return null;</span>
        }
<span class="fc" id="L3050">        return join(collection.iterator(), separator);</span>
    }

    // Delete
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Deletes all whitespaces from a String as defined by
     * {@link Character#isWhitespace(char)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.deleteWhitespace(null)         = null
     * StringUtils.deleteWhitespace(&quot;&quot;)           = &quot;&quot;
     * StringUtils.deleteWhitespace(&quot;abc&quot;)        = &quot;abc&quot;
     * StringUtils.deleteWhitespace(&quot;   ab  c  &quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to delete whitespace from, may be null
     * @return the String without whitespaces, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String deleteWhitespace(String str) {
<span class="fc bfc" id="L3070" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L3071">            return str;</span>
        }
<span class="fc" id="L3073">        int sz = str.length();</span>
<span class="fc" id="L3074">        char[] chs = new char[sz];</span>
<span class="fc" id="L3075">        int count = 0;</span>
<span class="fc bfc" id="L3076" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L3077" title="All 2 branches covered.">            if (!Character.isWhitespace(str.charAt(i))) {</span>
<span class="fc" id="L3078">                chs[count++] = str.charAt(i);</span>
            }
        }
<span class="fc bfc" id="L3081" title="All 2 branches covered.">        if (count == sz) {</span>
<span class="fc" id="L3082">            return str;</span>
        }
<span class="fc" id="L3084">        return new String(chs, 0, count);</span>
    }

    // Remove
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Removes a substring only if it is at the begining of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStart(null, *)      = null
     * StringUtils.removeStart(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeStart(*, null)      = *
     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStart(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
     * StringUtils.removeStart(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeStart(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String removeStart(String str, String remove) {
<span class="fc bfc" id="L3114" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(remove)) {</span>
<span class="fc" id="L3115">            return str;</span>
        }
<span class="fc bfc" id="L3117" title="All 2 branches covered.">        if (str.startsWith(remove)){</span>
<span class="fc" id="L3118">            return str.substring(remove.length());</span>
        }
<span class="fc" id="L3120">        return str;</span>
    }

    /**
     * &lt;p&gt;Case insensitive removal of a substring if it is at the begining of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeStartIgnoreCase(null, *)      = null
     * StringUtils.removeStartIgnoreCase(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeStartIgnoreCase(*, null)      = *
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;www.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;WWW.&quot;)   = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;domain.com&quot;, &quot;www.&quot;)       = &quot;domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeStartIgnoreCase(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for (case insensitive) and remove, may be null
     * @return the substring with the string removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    public static String removeStartIgnoreCase(String str, String remove) {
<span class="fc bfc" id="L3149" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(remove)) {</span>
<span class="fc" id="L3150">            return str;</span>
        }
<span class="fc bfc" id="L3152" title="All 2 branches covered.">        if (startsWithIgnoreCase(str, remove)) {</span>
<span class="fc" id="L3153">            return str.substring(remove.length());</span>
        }
<span class="fc" id="L3155">        return str;</span>
    }

    /**
     * &lt;p&gt;Removes a substring only if it is at the end of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEnd(null, *)      = null
     * StringUtils.removeEnd(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeEnd(*, null)      = *
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String removeEnd(String str, String remove) {
<span class="fc bfc" id="L3183" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(remove)) {</span>
<span class="fc" id="L3184">            return str;</span>
        }
<span class="fc bfc" id="L3186" title="All 2 branches covered.">        if (str.endsWith(remove)) {</span>
<span class="fc" id="L3187">            return str.substring(0, str.length() - remove.length());</span>
        }
<span class="fc" id="L3189">        return str;</span>
    }

    /**
     * &lt;p&gt;Case insensitive removal of a substring if it is at the end of a source string,
     * otherwise returns the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; search string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.removeEnd(null, *)      = null
     * StringUtils.removeEnd(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.removeEnd(*, null)      = *
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com.&quot;)  = &quot;www.domain.com.&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;.com&quot;)   = &quot;www.domain&quot;
     * StringUtils.removeEnd(&quot;www.domain.com&quot;, &quot;domain&quot;) = &quot;www.domain.com&quot;
     * StringUtils.removeEnd(&quot;abc&quot;, &quot;&quot;)    = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for (case insensitive) and remove, may be null
     * @return the substring with the string removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.4
     */
    public static String removeEndIgnoreCase(String str, String remove) {
<span class="fc bfc" id="L3217" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(remove)) {</span>
<span class="fc" id="L3218">            return str;</span>
        }
<span class="fc bfc" id="L3220" title="All 2 branches covered.">        if (endsWithIgnoreCase(str, remove)) {</span>
<span class="fc" id="L3221">            return str.substring(0, str.length() - remove.length());</span>
        }
<span class="fc" id="L3223">        return str;</span>
    }

    /**
     * &lt;p&gt;Removes all occurrences of a substring from within the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.
     * A &lt;code&gt;null&lt;/code&gt; remove string will return the source string.
     * An empty (&quot;&quot;) remove string will return the source string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)        = null
     * StringUtils.remove(&quot;&quot;, *)          = &quot;&quot;
     * StringUtils.remove(*, null)        = *
     * StringUtils.remove(*, &quot;&quot;)          = *
     * StringUtils.remove(&quot;queued&quot;, &quot;ue&quot;) = &quot;qd&quot;
     * StringUtils.remove(&quot;queued&quot;, &quot;zz&quot;) = &quot;queued&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the String to search for and remove, may be null
     * @return the substring with the string removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String remove(String str, String remove) {
<span class="fc bfc" id="L3250" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(remove)) {</span>
<span class="fc" id="L3251">            return str;</span>
        }
<span class="fc" id="L3253">        return replace(str, remove, EMPTY, -1);</span>
    }

    /**
     * &lt;p&gt;Removes all occurrences of a character from within the source string.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; source string will return &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) source string will return the empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.remove(null, *)       = null
     * StringUtils.remove(&quot;&quot;, *)         = &quot;&quot;
     * StringUtils.remove(&quot;queued&quot;, 'u') = &quot;qeed&quot;
     * StringUtils.remove(&quot;queued&quot;, 'z') = &quot;queued&quot;
     * &lt;/pre&gt;
     *
     * @param str  the source String to search, may be null
     * @param remove  the char to search for and remove, may be null
     * @return the substring with the char removed if found,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.1
     */
    public static String remove(String str, char remove) {
<span class="fc bfc" id="L3276" title="All 4 branches covered.">        if (isEmpty(str) || str.indexOf(remove) == -1) {</span>
<span class="fc" id="L3277">            return str;</span>
        }
<span class="fc" id="L3279">        char[] chars = str.toCharArray();</span>
<span class="fc" id="L3280">        int pos = 0;</span>
<span class="fc bfc" id="L3281" title="All 2 branches covered.">        for (int i = 0; i &lt; chars.length; i++) {</span>
<span class="fc bfc" id="L3282" title="All 2 branches covered.">            if (chars[i] != remove) {</span>
<span class="fc" id="L3283">                chars[pos++] = chars[i];</span>
            }
        }
<span class="fc" id="L3286">        return new String(chars, 0, pos);</span>
    }

    // Replacing
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Replaces a String with another String inside a larger String, once.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceOnce(null, *, *)        = null
     * StringUtils.replaceOnce(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, null, *)    = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, *, null)    = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;ba&quot;
     * StringUtils.replaceOnce(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zba&quot;
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int max)
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace with, may be null
     * @return the text with any replacements processed,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String replaceOnce(String text, String searchString, String replacement) {
<span class="fc" id="L3315">        return replace(text, searchString, replacement, 1);</span>
    }

    /**
     * &lt;p&gt;Replaces all occurrences of a String within another String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *)        = null
     * StringUtils.replace(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null)    = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *)      = &quot;any&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, null)  = &quot;aba&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;&quot;)    = &quot;b&quot;
     * StringUtils.replace(&quot;aba&quot;, &quot;a&quot;, &quot;z&quot;)   = &quot;zbz&quot;
     * &lt;/pre&gt;
     *
     * @see #replace(String text, String searchString, String replacement, int max)
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @return the text with any replacements processed,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String replace(String text, String searchString, String replacement) {
<span class="fc" id="L3342">        return replace(text, searchString, replacement, -1);</span>
    }

    /**
     * &lt;p&gt;Replaces a String with another String inside a larger String,
     * for the first &lt;code&gt;max&lt;/code&gt; values of the search String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replace(null, *, *, *)         = null
     * StringUtils.replace(&quot;&quot;, *, *, *)           = &quot;&quot;
     * StringUtils.replace(&quot;any&quot;, null, *, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, null, *)     = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, &quot;&quot;, *, *)       = &quot;any&quot;
     * StringUtils.replace(&quot;any&quot;, *, *, 0)        = &quot;any&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, null, -1) = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;&quot;, -1)   = &quot;b&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 0)   = &quot;abaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 1)   = &quot;zbaa&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, 2)   = &quot;zbza&quot;
     * StringUtils.replace(&quot;abaa&quot;, &quot;a&quot;, &quot;z&quot;, -1)  = &quot;zbzz&quot;
     * &lt;/pre&gt;
     *
     * @param text  text to search and replace in, may be null
     * @param searchString  the String to search for, may be null
     * @param replacement  the String to replace it with, may be null
     * @param max  maximum number of values to replace, or &lt;code&gt;-1&lt;/code&gt; if no maximum
     * @return the text with any replacements processed,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String replace(String text, String searchString, String replacement, int max) {
<span class="fc bfc" id="L3374" title="All 8 branches covered.">        if (isEmpty(text) || isEmpty(searchString) || replacement == null || max == 0) {</span>
<span class="fc" id="L3375">            return text;</span>
        }
<span class="fc" id="L3377">        int start = 0;</span>
<span class="fc" id="L3378">        int end = text.indexOf(searchString, start);</span>
<span class="fc bfc" id="L3379" title="All 2 branches covered.">        if (end == -1) {</span>
<span class="fc" id="L3380">            return text;</span>
        }
<span class="fc" id="L3382">        int replLength = searchString.length();</span>
<span class="fc" id="L3383">        int increase = replacement.length() - replLength;</span>
<span class="fc bfc" id="L3384" title="All 2 branches covered.">        increase = (increase &lt; 0 ? 0 : increase);</span>
<span class="fc bfc" id="L3385" title="All 4 branches covered.">        increase *= (max &lt; 0 ? 16 : (max &gt; 64 ? 64 : max));</span>
<span class="fc" id="L3386">        StringBuilder buf = new StringBuilder(text.length() + increase);</span>
<span class="fc bfc" id="L3387" title="All 2 branches covered.">        while (end != -1) {</span>
<span class="fc" id="L3388">            buf.append(text.substring(start, end)).append(replacement);</span>
<span class="fc" id="L3389">            start = end + replLength;</span>
<span class="fc bfc" id="L3390" title="All 2 branches covered.">            if (--max == 0) {</span>
<span class="fc" id="L3391">                break;</span>
            }
<span class="fc" id="L3393">            end = text.indexOf(searchString, start);</span>
        }
<span class="fc" id="L3395">        buf.append(text.substring(start));</span>
<span class="fc" id="L3396">        return buf.toString();</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored. This will not repeat. For repeating replaces, call the
     * overloaded method.
     * &lt;/p&gt;
     * 
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *)        = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *)          = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0]) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null)  = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;})  = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;})  = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;})  = &quot;wcte&quot;
     *  (example of how it does not repeat)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;})  = &quot;dcte&quot;
     * &lt;/pre&gt;
     * 
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
     *         null String input
     * @throws IndexOutOfBoundsException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */
    public static String replaceEach(String text, String[] searchList, String[] replacementList) {
<span class="fc" id="L3439">        return replaceEach(text, searchList, replacementList, false, 0);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored. This will not repeat. For repeating replaces, call the
     * overloaded method.
     * &lt;/p&gt;
     * 
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
     *  (example of how it repeats)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, true) = IllegalArgumentException
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, false) = &quot;dcabe&quot;
     * &lt;/pre&gt;
     * 
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
     *         null String input
     * @throws IllegalArgumentException
     *             if the search is repeating and there is an endless loop due
     *             to outputs of one being inputs to another
     * @throws IndexOutOfBoundsException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */
    public static String replaceEachRepeatedly(String text, String[] searchList, String[] replacementList) {
        // timeToLive should be 0 if not used or nothing to replace, else it's
        // the length of the replace array
<span class="fc bfc" id="L3490" title="All 2 branches covered.">        int timeToLive = searchList == null ? 0 : searchList.length;</span>
<span class="fc" id="L3491">        return replaceEach(text, searchList, replacementList, true, timeToLive);</span>
    }

    /**
     * &lt;p&gt;
     * Replaces all occurrences of Strings within another String.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A &lt;code&gt;null&lt;/code&gt; reference passed to this method is a no-op, or if
     * any &quot;search string&quot; or &quot;string to replace&quot; is null, that replace will be
     * ignored. 
     * &lt;/p&gt;
     * 
     * &lt;pre&gt;
     *  StringUtils.replaceEach(null, *, *, *) = null
     *  StringUtils.replaceEach(&quot;&quot;, *, *, *) = &quot;&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[0], null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, null, new String[0], *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, null, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{&quot;a&quot;}, new String[]{&quot;&quot;}, *) = &quot;b&quot;
     *  StringUtils.replaceEach(&quot;aba&quot;, new String[]{null}, new String[]{&quot;a&quot;}, *) = &quot;aba&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;w&quot;, &quot;t&quot;}, *) = &quot;wcte&quot;
     *  (example of how it repeats)
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, false) = &quot;dcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;t&quot;}, true) = &quot;tcte&quot;
     *  StringUtils.replaceEach(&quot;abcde&quot;, new String[]{&quot;ab&quot;, &quot;d&quot;}, new String[]{&quot;d&quot;, &quot;ab&quot;}, *) = IllegalArgumentException
     * &lt;/pre&gt;
     * 
     * @param text
     *            text to search and replace in, no-op if null
     * @param searchList
     *            the Strings to search for, no-op if null
     * @param replacementList
     *            the Strings to replace them with, no-op if null
     * @param repeat if true, then replace repeatedly 
     *       until there are no more possible replacements or timeToLive &lt; 0
     * @param timeToLive
     *            if less than 0 then there is a circular reference and endless
     *            loop
     * @return the text with any replacements processed, &lt;code&gt;null&lt;/code&gt; if
     *         null String input
     * @throws IllegalArgumentException
     *             if the search is repeating and there is an endless loop due
     *             to outputs of one being inputs to another
     * @throws IndexOutOfBoundsException
     *             if the lengths of the arrays are not the same (null is ok,
     *             and/or size 0)
     * @since 2.4
     */
    private static String replaceEach(String text, String[] searchList, String[] replacementList, 
                                      boolean repeat, int timeToLive) 
    {

        // mchyzer Performance note: This creates very few new objects (one major goal)
        // let me know if there are performance requests, we can create a harness to measure

<span class="pc bpc" id="L3549" title="1 of 12 branches missed.">        if (text == null || text.length() == 0 || searchList == null || </span>
            searchList.length == 0 || replacementList == null || replacementList.length == 0) 
        {
<span class="fc" id="L3552">            return text;</span>
        }

        // if recursing, this shouldnt be less than 0
<span class="fc bfc" id="L3556" title="All 2 branches covered.">        if (timeToLive &lt; 0) {</span>
<span class="fc" id="L3557">            throw new IllegalStateException(&quot;TimeToLive of &quot; + timeToLive + &quot; is less than 0: &quot; + text);</span>
        }

<span class="fc" id="L3560">        int searchLength = searchList.length;</span>
<span class="fc" id="L3561">        int replacementLength = replacementList.length;</span>

        // make sure lengths are ok, these need to be equal
<span class="pc bpc" id="L3564" title="1 of 2 branches missed.">        if (searchLength != replacementLength) {</span>
<span class="nc" id="L3565">            throw new IllegalArgumentException(&quot;Search and Replace array lengths don't match: &quot;</span>
                + searchLength
                + &quot; vs &quot;
                + replacementLength);
        }

        // keep track of which still have matches
<span class="fc" id="L3572">        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];</span>

        // index on index that the match was found
<span class="fc" id="L3575">        int textIndex = -1;</span>
<span class="fc" id="L3576">        int replaceIndex = -1;</span>
<span class="fc" id="L3577">        int tempIndex = -1;</span>

        // index of replace array that will replace the search string found
        // NOTE: logic duplicated below START
<span class="fc bfc" id="L3581" title="All 2 branches covered.">        for (int i = 0; i &lt; searchLength; i++) {</span>
<span class="pc bpc" id="L3582" title="1 of 4 branches missed.">            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || </span>
<span class="pc bpc" id="L3583" title="2 of 4 branches missed.">                searchList[i].length() == 0 || replacementList[i] == null) </span>
            {
<span class="nc" id="L3585">                continue;</span>
            }
<span class="fc" id="L3587">            tempIndex = text.indexOf(searchList[i]);</span>

            // see if we need to keep searching for this
<span class="fc bfc" id="L3590" title="All 2 branches covered.">            if (tempIndex == -1) {</span>
<span class="fc" id="L3591">                noMoreMatchesForReplIndex[i] = true;</span>
            } else {
<span class="fc bfc" id="L3593" title="All 4 branches covered.">                if (textIndex == -1 || tempIndex &lt; textIndex) {</span>
<span class="fc" id="L3594">                    textIndex = tempIndex;</span>
<span class="fc" id="L3595">                    replaceIndex = i;</span>
                }
            }
        }
        // NOTE: logic mostly below END

        // no search strings found, we are done
<span class="fc bfc" id="L3602" title="All 2 branches covered.">        if (textIndex == -1) {</span>
<span class="fc" id="L3603">            return text;</span>
        }

<span class="fc" id="L3606">        int start = 0;</span>

        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit
<span class="fc" id="L3609">        int increase = 0;</span>

        // count the replacement text elements that are larger than their corresponding text being replaced
<span class="fc bfc" id="L3612" title="All 2 branches covered.">        for (int i = 0; i &lt; searchList.length; i++) {</span>
<span class="fc" id="L3613">            int greater = replacementList[i].length() - searchList[i].length();</span>
<span class="fc bfc" id="L3614" title="All 2 branches covered.">            if (greater &gt; 0) {</span>
<span class="fc" id="L3615">                increase += 3 * greater; // assume 3 matches</span>
            }
        }
        // have upper-bound at 20% increase, then let Java take over
<span class="fc" id="L3619">        increase = Math.min(increase, text.length() / 5);</span>

<span class="fc" id="L3621">        StringBuilder buf = new StringBuilder(text.length() + increase);</span>

<span class="fc bfc" id="L3623" title="All 2 branches covered.">        while (textIndex != -1) {</span>

<span class="fc bfc" id="L3625" title="All 2 branches covered.">            for (int i = start; i &lt; textIndex; i++) {</span>
<span class="fc" id="L3626">                buf.append(text.charAt(i));</span>
            }
<span class="fc" id="L3628">            buf.append(replacementList[replaceIndex]);</span>

<span class="fc" id="L3630">            start = textIndex + searchList[replaceIndex].length();</span>

<span class="fc" id="L3632">            textIndex = -1;</span>
<span class="fc" id="L3633">            replaceIndex = -1;</span>
<span class="fc" id="L3634">            tempIndex = -1;</span>
            // find the next earliest match
            // NOTE: logic mostly duplicated above START
<span class="fc bfc" id="L3637" title="All 2 branches covered.">            for (int i = 0; i &lt; searchLength; i++) {</span>
<span class="pc bpc" id="L3638" title="1 of 4 branches missed.">                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || </span>
<span class="pc bpc" id="L3639" title="2 of 4 branches missed.">                    searchList[i].length() == 0 || replacementList[i] == null) </span>
                {
<span class="nc" id="L3641">                    continue;</span>
                }
<span class="fc" id="L3643">                tempIndex = text.indexOf(searchList[i], start);</span>

                // see if we need to keep searching for this
<span class="fc bfc" id="L3646" title="All 2 branches covered.">                if (tempIndex == -1) {</span>
<span class="fc" id="L3647">                    noMoreMatchesForReplIndex[i] = true;</span>
                } else {
<span class="fc bfc" id="L3649" title="All 4 branches covered.">                    if (textIndex == -1 || tempIndex &lt; textIndex) {</span>
<span class="fc" id="L3650">                        textIndex = tempIndex;</span>
<span class="fc" id="L3651">                        replaceIndex = i;</span>
                    }
                }
            }
            // NOTE: logic duplicated above END

        }
<span class="fc" id="L3658">        int textLength = text.length();</span>
<span class="fc bfc" id="L3659" title="All 2 branches covered.">        for (int i = start; i &lt; textLength; i++) {</span>
<span class="fc" id="L3660">            buf.append(text.charAt(i));</span>
        }
<span class="fc" id="L3662">        String result = buf.toString();</span>
<span class="fc bfc" id="L3663" title="All 2 branches covered.">        if (!repeat) {</span>
<span class="fc" id="L3664">            return result;</span>
        }

<span class="fc" id="L3667">        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);</span>
    }

    // Replace, character based
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Replaces all occurrences of a character in a String with another.
     * This is a null-safe version of {@link String#replace(char, char)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input returns an empty string.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)        = null
     * StringUtils.replaceChars(&quot;&quot;, *, *)          = &quot;&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, 'b', 'y') = &quot;aycya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, 'z', 'y') = &quot;abcba&quot;
     * &lt;/pre&gt;
     *
     * @param str  String to replace characters in, may be null
     * @param searchChar  the character to search for, may be null
     * @param replaceChar  the character to replace, may be null
     * @return modified String, &lt;code&gt;null&lt;/code&gt; if null string input
     * @since 2.0
     */
    public static String replaceChars(String str, char searchChar, char replaceChar) {
<span class="fc bfc" id="L3693" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L3694">            return null;</span>
        }
<span class="fc" id="L3696">        return str.replace(searchChar, replaceChar);</span>
    }

    /**
     * &lt;p&gt;Replaces multiple characters in a String in one go.
     * This method can also be used to delete characters.&lt;/p&gt;
     *
     * &lt;p&gt;For example:&lt;br /&gt;
     * &lt;code&gt;replaceChars(&amp;quot;hello&amp;quot;, &amp;quot;ho&amp;quot;, &amp;quot;jy&amp;quot;) = jelly&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
     * An empty (&quot;&quot;) string input returns an empty string.
     * A null or empty set of search characters returns the input string.&lt;/p&gt;
     *
     * &lt;p&gt;The length of the search characters should normally equal the length
     * of the replace characters.
     * If the search characters is longer, then the extra search characters
     * are deleted.
     * If the search characters is shorter, then the extra replace characters
     * are ignored.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.replaceChars(null, *, *)           = null
     * StringUtils.replaceChars(&quot;&quot;, *, *)             = &quot;&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, null, *)       = &quot;abc&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;&quot;, *)         = &quot;abc&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, null)     = &quot;ac&quot;
     * StringUtils.replaceChars(&quot;abc&quot;, &quot;b&quot;, &quot;&quot;)       = &quot;ac&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yz&quot;)  = &quot;ayzya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;y&quot;)   = &quot;ayya&quot;
     * StringUtils.replaceChars(&quot;abcba&quot;, &quot;bc&quot;, &quot;yzx&quot;) = &quot;ayzya&quot;
     * &lt;/pre&gt;
     *
     * @param str  String to replace characters in, may be null
     * @param searchChars  a set of characters to search for, may be null
     * @param replaceChars  a set of characters to replace, may be null
     * @return modified String, &lt;code&gt;null&lt;/code&gt; if null string input
     * @since 2.0
     */
    public static String replaceChars(String str, String searchChars, String replaceChars) {
<span class="fc bfc" id="L3736" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(searchChars)) {</span>
<span class="fc" id="L3737">            return str;</span>
        }
<span class="fc bfc" id="L3739" title="All 2 branches covered.">        if (replaceChars == null) {</span>
<span class="fc" id="L3740">            replaceChars = EMPTY;</span>
        }
<span class="fc" id="L3742">        boolean modified = false;</span>
<span class="fc" id="L3743">        int replaceCharsLength = replaceChars.length();</span>
<span class="fc" id="L3744">        int strLength = str.length();</span>
<span class="fc" id="L3745">        StringBuilder buf = new StringBuilder(strLength);</span>
<span class="fc bfc" id="L3746" title="All 2 branches covered.">        for (int i = 0; i &lt; strLength; i++) {</span>
<span class="fc" id="L3747">            char ch = str.charAt(i);</span>
<span class="fc" id="L3748">            int index = searchChars.indexOf(ch);</span>
<span class="fc bfc" id="L3749" title="All 2 branches covered.">            if (index &gt;= 0) {</span>
<span class="fc" id="L3750">                modified = true;</span>
<span class="fc bfc" id="L3751" title="All 2 branches covered.">                if (index &lt; replaceCharsLength) {</span>
<span class="fc" id="L3752">                    buf.append(replaceChars.charAt(index));</span>
                }
            } else {
<span class="fc" id="L3755">                buf.append(ch);</span>
            }
        }
<span class="fc bfc" id="L3758" title="All 2 branches covered.">        if (modified) {</span>
<span class="fc" id="L3759">            return buf.toString();</span>
        }
<span class="fc" id="L3761">        return str;</span>
    }

    // Overlay
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Overlays part of a String with another String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; string input returns &lt;code&gt;null&lt;/code&gt;.
     * A negative index is treated as zero.
     * An index greater than the string length is treated as the string length.
     * The start index is always the smaller of the two indices.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.overlay(null, *, *, *)            = null
     * StringUtils.overlay(&quot;&quot;, &quot;abc&quot;, 0, 0)          = &quot;abc&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, null, 2, 4)     = &quot;abef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;&quot;, 2, 4)       = &quot;abef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;&quot;, 4, 2)       = &quot;abef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 4)   = &quot;abzzzzef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 4, 2)   = &quot;abzzzzef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, -1, 4)  = &quot;zzzzef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 2, 8)   = &quot;abzzzz&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, -2, -3) = &quot;zzzzabcdef&quot;
     * StringUtils.overlay(&quot;abcdef&quot;, &quot;zzzz&quot;, 8, 10)  = &quot;abcdefzzzz&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to do overlaying in, may be null
     * @param overlay  the String to overlay, may be null
     * @param start  the position to start overlaying at
     * @param end  the position to stop overlaying before
     * @return overlayed String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String overlay(String str, String overlay, int start, int end) {
<span class="fc bfc" id="L3796" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L3797">            return null;</span>
        }
<span class="fc bfc" id="L3799" title="All 2 branches covered.">        if (overlay == null) {</span>
<span class="fc" id="L3800">            overlay = EMPTY;</span>
        }
<span class="fc" id="L3802">        int len = str.length();</span>
<span class="fc bfc" id="L3803" title="All 2 branches covered.">        if (start &lt; 0) {</span>
<span class="fc" id="L3804">            start = 0;</span>
        }
<span class="fc bfc" id="L3806" title="All 2 branches covered.">        if (start &gt; len) {</span>
<span class="fc" id="L3807">            start = len;</span>
        }
<span class="fc bfc" id="L3809" title="All 2 branches covered.">        if (end &lt; 0) {</span>
<span class="fc" id="L3810">            end = 0;</span>
        }
<span class="fc bfc" id="L3812" title="All 2 branches covered.">        if (end &gt; len) {</span>
<span class="fc" id="L3813">            end = len;</span>
        }
<span class="fc bfc" id="L3815" title="All 2 branches covered.">        if (start &gt; end) {</span>
<span class="fc" id="L3816">            int temp = start;</span>
<span class="fc" id="L3817">            start = end;</span>
<span class="fc" id="L3818">            end = temp;</span>
        }
<span class="fc" id="L3820">        return new StringBuilder(len + start - end + overlay.length() + 1)</span>
<span class="fc" id="L3821">            .append(str.substring(0, start))</span>
<span class="fc" id="L3822">            .append(overlay)</span>
<span class="fc" id="L3823">            .append(str.substring(end))</span>
<span class="fc" id="L3824">            .toString();</span>
    }

    // Chomping
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Removes one newline from end of a String if it's there,
     * otherwise leave it alone.  A newline is &amp;quot;&lt;code&gt;\n&lt;/code&gt;&amp;quot;,
     * &amp;quot;&lt;code&gt;\r&lt;/code&gt;&amp;quot;, or &amp;quot;&lt;code&gt;\r\n&lt;/code&gt;&amp;quot;.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: This method changed in 2.0.
     * It now more closely matches Perl chomp.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chomp(null)          = null
     * StringUtils.chomp(&quot;&quot;)            = &quot;&quot;
     * StringUtils.chomp(&quot;abc \r&quot;)      = &quot;abc &quot;
     * StringUtils.chomp(&quot;abc\n&quot;)       = &quot;abc&quot;
     * StringUtils.chomp(&quot;abc\r\n&quot;)     = &quot;abc&quot;
     * StringUtils.chomp(&quot;abc\r\n\r\n&quot;) = &quot;abc\r\n&quot;
     * StringUtils.chomp(&quot;abc\n\r&quot;)     = &quot;abc\n&quot;
     * StringUtils.chomp(&quot;abc\n\rabc&quot;)  = &quot;abc\n\rabc&quot;
     * StringUtils.chomp(&quot;\r&quot;)          = &quot;&quot;
     * StringUtils.chomp(&quot;\n&quot;)          = &quot;&quot;
     * StringUtils.chomp(&quot;\r\n&quot;)        = &quot;&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to chomp a newline from, may be null
     * @return String without newline, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String chomp(String str) {
<span class="fc bfc" id="L3855" title="All 2 branches covered.">        if (isEmpty(str)) {</span>
<span class="fc" id="L3856">            return str;</span>
        }

<span class="fc bfc" id="L3859" title="All 2 branches covered.">        if (str.length() == 1) {</span>
<span class="fc" id="L3860">            char ch = str.charAt(0);</span>
<span class="fc bfc" id="L3861" title="All 4 branches covered.">            if (ch == CharUtils.CR || ch == CharUtils.LF) {</span>
<span class="fc" id="L3862">                return EMPTY;</span>
            }
<span class="fc" id="L3864">            return str;</span>
        }

<span class="fc" id="L3867">        int lastIdx = str.length() - 1;</span>
<span class="fc" id="L3868">        char last = str.charAt(lastIdx);</span>

<span class="fc bfc" id="L3870" title="All 2 branches covered.">        if (last == CharUtils.LF) {</span>
<span class="fc bfc" id="L3871" title="All 2 branches covered.">            if (str.charAt(lastIdx - 1) == CharUtils.CR) {</span>
<span class="fc" id="L3872">                lastIdx--;</span>
            }
<span class="fc bfc" id="L3874" title="All 2 branches covered.">        } else if (last != CharUtils.CR) {</span>
<span class="fc" id="L3875">            lastIdx++;</span>
        }
<span class="fc" id="L3877">        return str.substring(0, lastIdx);</span>
    }

    /**
     * &lt;p&gt;Removes &lt;code&gt;separator&lt;/code&gt; from the end of
     * &lt;code&gt;str&lt;/code&gt; if it's there, otherwise leave it alone.&lt;/p&gt;
     *
     * &lt;p&gt;NOTE: This method changed in version 2.0.
     * It now more closely matches Perl chomp.
     * For the previous behavior, use {@link #substringBeforeLast(String, String)}.
     * This method uses {@link String#endsWith(String)}.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chomp(null, *)         = null
     * StringUtils.chomp(&quot;&quot;, *)           = &quot;&quot;
     * StringUtils.chomp(&quot;foobar&quot;, &quot;bar&quot;) = &quot;foo&quot;
     * StringUtils.chomp(&quot;foobar&quot;, &quot;baz&quot;) = &quot;foobar&quot;
     * StringUtils.chomp(&quot;foo&quot;, &quot;foo&quot;)    = &quot;&quot;
     * StringUtils.chomp(&quot;foo &quot;, &quot;foo&quot;)   = &quot;foo &quot;
     * StringUtils.chomp(&quot; foo&quot;, &quot;foo&quot;)   = &quot; &quot;
     * StringUtils.chomp(&quot;foo&quot;, &quot;foooo&quot;)  = &quot;foo&quot;
     * StringUtils.chomp(&quot;foo&quot;, &quot;&quot;)       = &quot;foo&quot;
     * StringUtils.chomp(&quot;foo&quot;, null)     = &quot;foo&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to chomp from, may be null
     * @param separator  separator String, may be null
     * @return String without trailing separator, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String chomp(String str, String separator) {
<span class="fc bfc" id="L3907" title="All 4 branches covered.">        if (isEmpty(str) || separator == null) {</span>
<span class="fc" id="L3908">            return str;</span>
        }
<span class="fc bfc" id="L3910" title="All 2 branches covered.">        if (str.endsWith(separator)) {</span>
<span class="fc" id="L3911">            return str.substring(0, str.length() - separator.length());</span>
        }
<span class="fc" id="L3913">        return str;</span>
    }

    // Chopping
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Remove the last character from a String.&lt;/p&gt;
     *
     * &lt;p&gt;If the String ends in &lt;code&gt;\r\n&lt;/code&gt;, then remove both
     * of them.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.chop(null)          = null
     * StringUtils.chop(&quot;&quot;)            = &quot;&quot;
     * StringUtils.chop(&quot;abc \r&quot;)      = &quot;abc &quot;
     * StringUtils.chop(&quot;abc\n&quot;)       = &quot;abc&quot;
     * StringUtils.chop(&quot;abc\r\n&quot;)     = &quot;abc&quot;
     * StringUtils.chop(&quot;abc&quot;)         = &quot;ab&quot;
     * StringUtils.chop(&quot;abc\nabc&quot;)    = &quot;abc\nab&quot;
     * StringUtils.chop(&quot;a&quot;)           = &quot;&quot;
     * StringUtils.chop(&quot;\r&quot;)          = &quot;&quot;
     * StringUtils.chop(&quot;\n&quot;)          = &quot;&quot;
     * StringUtils.chop(&quot;\r\n&quot;)        = &quot;&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to chop last character from, may be null
     * @return String without last character, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String chop(String str) {
<span class="fc bfc" id="L3942" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L3943">            return null;</span>
        }
<span class="fc" id="L3945">        int strLen = str.length();</span>
<span class="fc bfc" id="L3946" title="All 2 branches covered.">        if (strLen &lt; 2) {</span>
<span class="fc" id="L3947">            return EMPTY;</span>
        }
<span class="fc" id="L3949">        int lastIdx = strLen - 1;</span>
<span class="fc" id="L3950">        String ret = str.substring(0, lastIdx);</span>
<span class="fc" id="L3951">        char last = str.charAt(lastIdx);</span>
<span class="fc bfc" id="L3952" title="All 2 branches covered.">        if (last == CharUtils.LF) {</span>
<span class="fc bfc" id="L3953" title="All 2 branches covered.">            if (ret.charAt(lastIdx - 1) == CharUtils.CR) {</span>
<span class="fc" id="L3954">                return ret.substring(0, lastIdx - 1);</span>
            }
        }
<span class="fc" id="L3957">        return ret;</span>
    }

    // Conversion
    //-----------------------------------------------------------------------

    // Padding
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
     * new String.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, 2) = null
     * StringUtils.repeat(&quot;&quot;, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, 2)   = &quot;&quot;
     * StringUtils.repeat(&quot;a&quot;, 3)  = &quot;aaa&quot;
     * StringUtils.repeat(&quot;ab&quot;, 2) = &quot;abab&quot;
     * StringUtils.repeat(&quot;a&quot;, -2) = &quot;&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to repeat, may be null
     * @param repeat  number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String repeat(String str, int repeat) {
        // Performance tuned for 2.0 (JDK1.4)

<span class="fc bfc" id="L3986" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L3987">            return null;</span>
        }
<span class="fc bfc" id="L3989" title="All 2 branches covered.">        if (repeat &lt;= 0) {</span>
<span class="fc" id="L3990">            return EMPTY;</span>
        }
<span class="fc" id="L3992">        int inputLength = str.length();</span>
<span class="fc bfc" id="L3993" title="All 4 branches covered.">        if (repeat == 1 || inputLength == 0) {</span>
<span class="fc" id="L3994">            return str;</span>
        }
<span class="fc bfc" id="L3996" title="All 4 branches covered.">        if (inputLength == 1 &amp;&amp; repeat &lt;= PAD_LIMIT) {</span>
<span class="fc" id="L3997">            return padding(repeat, str.charAt(0));</span>
        }

<span class="fc" id="L4000">        int outputLength = inputLength * repeat;</span>
<span class="fc bfc" id="L4001" title="All 3 branches covered.">        switch (inputLength) {</span>
            case 1 :
<span class="fc" id="L4003">                char ch = str.charAt(0);</span>
<span class="fc" id="L4004">                char[] output1 = new char[outputLength];</span>
<span class="fc bfc" id="L4005" title="All 2 branches covered.">                for (int i = repeat - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L4006">                    output1[i] = ch;</span>
                }
<span class="fc" id="L4008">                return new String(output1);</span>
            case 2 :
<span class="fc" id="L4010">                char ch0 = str.charAt(0);</span>
<span class="fc" id="L4011">                char ch1 = str.charAt(1);</span>
<span class="fc" id="L4012">                char[] output2 = new char[outputLength];</span>
<span class="fc bfc" id="L4013" title="All 2 branches covered.">                for (int i = repeat * 2 - 2; i &gt;= 0; i--, i--) {</span>
<span class="fc" id="L4014">                    output2[i] = ch0;</span>
<span class="fc" id="L4015">                    output2[i + 1] = ch1;</span>
                }
<span class="fc" id="L4017">                return new String(output2);</span>
            default :
<span class="fc" id="L4019">                StringBuilder buf = new StringBuilder(outputLength);</span>
<span class="fc bfc" id="L4020" title="All 2 branches covered.">                for (int i = 0; i &lt; repeat; i++) {</span>
<span class="fc" id="L4021">                    buf.append(str);</span>
                }
<span class="fc" id="L4023">                return buf.toString();</span>
        }
    }

    /**
     * &lt;p&gt;Repeat a String &lt;code&gt;repeat&lt;/code&gt; times to form a
     * new String, with a String separator injected each time. &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.repeat(null, null, 2) = null
     * StringUtils.repeat(null, &quot;x&quot;, 2)  = null
     * StringUtils.repeat(&quot;&quot;, null, 0)   = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;&quot;, 2)     = &quot;&quot;
     * StringUtils.repeat(&quot;&quot;, &quot;x&quot;, 3)    = &quot;xxx&quot;
     * StringUtils.repeat(&quot;?&quot;, &quot;, &quot;, 3)  = &quot;?, ?, ?&quot;
     * &lt;/pre&gt;
     *
     * @param str        the String to repeat, may be null
     * @param separator  the String to inject, may be null
     * @param repeat     number of times to repeat str, negative treated as zero
     * @return a new String consisting of the original String repeated,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String repeat(String str, String separator, int repeat) {
<span class="fc bfc" id="L4047" title="All 4 branches covered.">        if(str == null || separator == null) {</span>
<span class="fc" id="L4048">            return repeat(str, repeat);</span>
        } else {
            // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
<span class="fc" id="L4051">            String result = repeat(str + separator, repeat);</span>
<span class="fc" id="L4052">            return removeEnd(result, separator);</span>
        }
    }

    /**
     * &lt;p&gt;Returns padding using the specified delimiter repeated
     * to a given length.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.padding(0, 'e')  = &quot;&quot;
     * StringUtils.padding(3, 'e')  = &quot;eee&quot;
     * StringUtils.padding(-2, 'e') = IndexOutOfBoundsException
     * &lt;/pre&gt;
     *
     * &lt;p&gt;Note: this method doesn't not support padding with
     * &lt;a href=&quot;http://www.unicode.org/glossary/#supplementary_character&quot;&gt;Unicode Supplementary Characters&lt;/a&gt;
     * as they require a pair of &lt;code&gt;char&lt;/code&gt;s to be represented.
     * If you are needing to support full I18N of your applications
     * consider using {@link #repeat(String, int)} instead. 
     * &lt;/p&gt;
     *
     * @param repeat  number of times to repeat delim
     * @param padChar  character to repeat
     * @return String with repeated character
     * @throws IndexOutOfBoundsException if &lt;code&gt;repeat &amp;lt; 0&lt;/code&gt;
     * @see #repeat(String, int)
     */
    private static String padding(int repeat, char padChar) throws IndexOutOfBoundsException {
<span class="pc bpc" id="L4080" title="1 of 2 branches missed.">        if (repeat &lt; 0) {</span>
<span class="nc" id="L4081">            throw new IndexOutOfBoundsException(&quot;Cannot pad a negative amount: &quot; + repeat);</span>
        }
<span class="fc" id="L4083">        final char[] buf = new char[repeat];</span>
<span class="fc bfc" id="L4084" title="All 2 branches covered.">        for (int i = 0; i &lt; buf.length; i++) {</span>
<span class="fc" id="L4085">            buf[i] = padChar;</span>
        }
<span class="fc" id="L4087">        return new String(buf);</span>
    }

    /**
     * &lt;p&gt;Right pad a String with spaces (' ').&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *)   = null
     * StringUtils.rightPad(&quot;&quot;, 3)     = &quot;   &quot;
     * StringUtils.rightPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 5)  = &quot;bat  &quot;
     * StringUtils.rightPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, -1) = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @return right padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String rightPad(String str, int size) {
<span class="fc" id="L4110">        return rightPad(str, size, ' ');</span>
    }

    /**
     * &lt;p&gt;Right pad a String with a specified character.&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *, *)     = null
     * StringUtils.rightPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 5, 'z')  = &quot;batzz&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padChar  the character to pad with
     * @return right padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String rightPad(String str, int size, char padChar) {
<span class="fc bfc" id="L4135" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4136">            return null;</span>
        }
<span class="fc" id="L4138">        int pads = size - str.length();</span>
<span class="fc bfc" id="L4139" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4140">            return str; // returns original String when possible</span>
        }
<span class="fc bfc" id="L4142" title="All 2 branches covered.">        if (pads &gt; PAD_LIMIT) {</span>
<span class="fc" id="L4143">            return rightPad(str, size, String.valueOf(padChar));</span>
        }
<span class="fc" id="L4145">        return str.concat(padding(pads, padChar));</span>
    }

    /**
     * &lt;p&gt;Right pad a String with a specified String.&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.rightPad(null, *, *)      = null
     * StringUtils.rightPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;batyz&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;batyzyzy&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
     * StringUtils.rightPad(&quot;bat&quot;, 5, null)  = &quot;bat  &quot;
     * StringUtils.rightPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;bat  &quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padStr  the String to pad with, null or empty treated as single space
     * @return right padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String rightPad(String str, int size, String padStr) {
<span class="fc bfc" id="L4172" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4173">            return null;</span>
        }
<span class="fc bfc" id="L4175" title="All 2 branches covered.">        if (isEmpty(padStr)) {</span>
<span class="fc" id="L4176">            padStr = &quot; &quot;;</span>
        }
<span class="fc" id="L4178">        int padLen = padStr.length();</span>
<span class="fc" id="L4179">        int strLen = str.length();</span>
<span class="fc" id="L4180">        int pads = size - strLen;</span>
<span class="fc bfc" id="L4181" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4182">            return str; // returns original String when possible</span>
        }
<span class="fc bfc" id="L4184" title="All 4 branches covered.">        if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {</span>
<span class="fc" id="L4185">            return rightPad(str, size, padStr.charAt(0));</span>
        }

<span class="fc bfc" id="L4188" title="All 2 branches covered.">        if (pads == padLen) {</span>
<span class="fc" id="L4189">            return str.concat(padStr);</span>
<span class="fc bfc" id="L4190" title="All 2 branches covered.">        } else if (pads &lt; padLen) {</span>
<span class="fc" id="L4191">            return str.concat(padStr.substring(0, pads));</span>
        } else {
<span class="fc" id="L4193">            char[] padding = new char[pads];</span>
<span class="fc" id="L4194">            char[] padChars = padStr.toCharArray();</span>
<span class="fc bfc" id="L4195" title="All 2 branches covered.">            for (int i = 0; i &lt; pads; i++) {</span>
<span class="fc" id="L4196">                padding[i] = padChars[i % padLen];</span>
            }
<span class="fc" id="L4198">            return str.concat(new String(padding));</span>
        }
    }

    /**
     * &lt;p&gt;Left pad a String with spaces (' ').&lt;/p&gt;
     *
     * &lt;p&gt;The String is padded to the size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *)   = null
     * StringUtils.leftPad(&quot;&quot;, 3)     = &quot;   &quot;
     * StringUtils.leftPad(&quot;bat&quot;, 3)  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 5)  = &quot;  bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 1)  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, -1) = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @return left padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String leftPad(String str, int size) {
<span class="fc" id="L4222">        return leftPad(str, size, ' ');</span>
    }

    /**
     * &lt;p&gt;Left pad a String with a specified character.&lt;/p&gt;
     *
     * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *, *)     = null
     * StringUtils.leftPad(&quot;&quot;, 3, 'z')     = &quot;zzz&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 3, 'z')  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 5, 'z')  = &quot;zzbat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 1, 'z')  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, -1, 'z') = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padChar  the character to pad with
     * @return left padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String leftPad(String str, int size, char padChar) {
<span class="fc bfc" id="L4247" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4248">            return null;</span>
        }
<span class="fc" id="L4250">        int pads = size - str.length();</span>
<span class="fc bfc" id="L4251" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4252">            return str; // returns original String when possible</span>
        }
<span class="fc bfc" id="L4254" title="All 2 branches covered.">        if (pads &gt; PAD_LIMIT) {</span>
<span class="fc" id="L4255">            return leftPad(str, size, String.valueOf(padChar));</span>
        }
<span class="fc" id="L4257">        return padding(pads, padChar).concat(str);</span>
    }

    /**
     * &lt;p&gt;Left pad a String with a specified String.&lt;/p&gt;
     *
     * &lt;p&gt;Pad to a size of &lt;code&gt;size&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.leftPad(null, *, *)      = null
     * StringUtils.leftPad(&quot;&quot;, 3, &quot;z&quot;)      = &quot;zzz&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 3, &quot;yz&quot;)  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;yz&quot;)  = &quot;yzbat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 8, &quot;yz&quot;)  = &quot;yzyzybat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 1, &quot;yz&quot;)  = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, -1, &quot;yz&quot;) = &quot;bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 5, null)  = &quot;  bat&quot;
     * StringUtils.leftPad(&quot;bat&quot;, 5, &quot;&quot;)    = &quot;  bat&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to pad out, may be null
     * @param size  the size to pad to
     * @param padStr  the String to pad with, null or empty treated as single space
     * @return left padded String or original String if no padding is necessary,
     *  &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String leftPad(String str, int size, String padStr) {
<span class="fc bfc" id="L4284" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4285">            return null;</span>
        }
<span class="fc bfc" id="L4287" title="All 2 branches covered.">        if (isEmpty(padStr)) {</span>
<span class="fc" id="L4288">            padStr = &quot; &quot;;</span>
        }
<span class="fc" id="L4290">        int padLen = padStr.length();</span>
<span class="fc" id="L4291">        int strLen = str.length();</span>
<span class="fc" id="L4292">        int pads = size - strLen;</span>
<span class="fc bfc" id="L4293" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4294">            return str; // returns original String when possible</span>
        }
<span class="fc bfc" id="L4296" title="All 4 branches covered.">        if (padLen == 1 &amp;&amp; pads &lt;= PAD_LIMIT) {</span>
<span class="fc" id="L4297">            return leftPad(str, size, padStr.charAt(0));</span>
        }

<span class="fc bfc" id="L4300" title="All 2 branches covered.">        if (pads == padLen) {</span>
<span class="fc" id="L4301">            return padStr.concat(str);</span>
<span class="fc bfc" id="L4302" title="All 2 branches covered.">        } else if (pads &lt; padLen) {</span>
<span class="fc" id="L4303">            return padStr.substring(0, pads).concat(str);</span>
        } else {
<span class="fc" id="L4305">            char[] padding = new char[pads];</span>
<span class="fc" id="L4306">            char[] padChars = padStr.toCharArray();</span>
<span class="fc bfc" id="L4307" title="All 2 branches covered.">            for (int i = 0; i &lt; pads; i++) {</span>
<span class="fc" id="L4308">                padding[i] = padChars[i % padLen];</span>
            }
<span class="fc" id="L4310">            return new String(padding).concat(str);</span>
        }
    }

    /**
     * Gets a String's length or &lt;code&gt;0&lt;/code&gt; if the String is &lt;code&gt;null&lt;/code&gt;.
     * 
     * @param str
     *            a String or &lt;code&gt;null&lt;/code&gt;
     * @return String length or &lt;code&gt;0&lt;/code&gt; if the String is &lt;code&gt;null&lt;/code&gt;.
     * @since 2.4
     */
    public static int length(String str) {
<span class="fc bfc" id="L4323" title="All 2 branches covered.">        return str == null ? 0 : str.length();</span>
    }
    
    // Centering
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;
     * using the space character (' ').&lt;p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;p&gt;Equivalent to &lt;code&gt;center(str, size, &quot; &quot;)&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *)   = null
     * StringUtils.center(&quot;&quot;, 4)     = &quot;    &quot;
     * StringUtils.center(&quot;ab&quot;, -1)  = &quot;ab&quot;
     * StringUtils.center(&quot;ab&quot;, 4)   = &quot; ab &quot;
     * StringUtils.center(&quot;abcd&quot;, 2) = &quot;abcd&quot;
     * StringUtils.center(&quot;a&quot;, 4)    = &quot; a  &quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String center(String str, int size) {
<span class="fc" id="L4352">        return center(str, size, ' ');</span>
    }

    /**
     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;.
     * Uses a supplied character as the value to pad the String with.&lt;/p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *, *)     = null
     * StringUtils.center(&quot;&quot;, 4, ' ')     = &quot;    &quot;
     * StringUtils.center(&quot;ab&quot;, -1, ' ')  = &quot;ab&quot;
     * StringUtils.center(&quot;ab&quot;, 4, ' ')   = &quot; ab&quot;
     * StringUtils.center(&quot;abcd&quot;, 2, ' ') = &quot;abcd&quot;
     * StringUtils.center(&quot;a&quot;, 4, ' ')    = &quot; a  &quot;
     * StringUtils.center(&quot;a&quot;, 4, 'y')    = &quot;yayy&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @param padChar  the character to pad the new String with
     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String center(String str, int size, char padChar) {
<span class="fc bfc" id="L4380" title="All 4 branches covered.">        if (str == null || size &lt;= 0) {</span>
<span class="fc" id="L4381">            return str;</span>
        }
<span class="fc" id="L4383">        int strLen = str.length();</span>
<span class="fc" id="L4384">        int pads = size - strLen;</span>
<span class="fc bfc" id="L4385" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4386">            return str;</span>
        }
<span class="fc" id="L4388">        str = leftPad(str, strLen + pads / 2, padChar);</span>
<span class="fc" id="L4389">        str = rightPad(str, size, padChar);</span>
<span class="fc" id="L4390">        return str;</span>
    }

    /**
     * &lt;p&gt;Centers a String in a larger String of size &lt;code&gt;size&lt;/code&gt;.
     * Uses a supplied String as the value to pad the String with.&lt;/p&gt;
     *
     * &lt;p&gt;If the size is less than the String length, the String is returned.
     * A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.
     * A negative size is treated as zero.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.center(null, *, *)     = null
     * StringUtils.center(&quot;&quot;, 4, &quot; &quot;)     = &quot;    &quot;
     * StringUtils.center(&quot;ab&quot;, -1, &quot; &quot;)  = &quot;ab&quot;
     * StringUtils.center(&quot;ab&quot;, 4, &quot; &quot;)   = &quot; ab&quot;
     * StringUtils.center(&quot;abcd&quot;, 2, &quot; &quot;) = &quot;abcd&quot;
     * StringUtils.center(&quot;a&quot;, 4, &quot; &quot;)    = &quot; a  &quot;
     * StringUtils.center(&quot;a&quot;, 4, &quot;yz&quot;)   = &quot;yayz&quot;
     * StringUtils.center(&quot;abc&quot;, 7, null) = &quot;  abc  &quot;
     * StringUtils.center(&quot;abc&quot;, 7, &quot;&quot;)   = &quot;  abc  &quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to center, may be null
     * @param size  the int size of new String, negative treated as zero
     * @param padStr  the String to pad the new String with, must not be null or empty
     * @return centered String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @throws IllegalArgumentException if padStr is &lt;code&gt;null&lt;/code&gt; or empty
     */
    public static String center(String str, int size, String padStr) {
<span class="fc bfc" id="L4420" title="All 4 branches covered.">        if (str == null || size &lt;= 0) {</span>
<span class="fc" id="L4421">            return str;</span>
        }
<span class="fc bfc" id="L4423" title="All 2 branches covered.">        if (isEmpty(padStr)) {</span>
<span class="fc" id="L4424">            padStr = &quot; &quot;;</span>
        }
<span class="fc" id="L4426">        int strLen = str.length();</span>
<span class="fc" id="L4427">        int pads = size - strLen;</span>
<span class="fc bfc" id="L4428" title="All 2 branches covered.">        if (pads &lt;= 0) {</span>
<span class="fc" id="L4429">            return str;</span>
        }
<span class="fc" id="L4431">        str = leftPad(str, strLen + pads / 2, padStr);</span>
<span class="fc" id="L4432">        str = rightPad(str, size, padStr);</span>
<span class="fc" id="L4433">        return str;</span>
    }

    // Case conversion
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase()}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.upperCase(null)  = null
     * StringUtils.upperCase(&quot;&quot;)    = &quot;&quot;
     * StringUtils.upperCase(&quot;aBc&quot;) = &quot;ABC&quot;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toUpperCase()},
     * the result of this method is affected by the current locale.
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
     *
     * @param str  the String to upper case, may be null
     * @return the upper cased String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String upperCase(String str) {
<span class="fc bfc" id="L4458" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4459">            return null;</span>
        }
<span class="fc" id="L4461">        return str.toUpperCase();</span>
    }

    /**
     * &lt;p&gt;Converts a String to upper case as per {@link String#toUpperCase(Locale)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.upperCase(null, Locale.ENGLISH)  = null
     * StringUtils.upperCase(&quot;&quot;, Locale.ENGLISH)    = &quot;&quot;
     * StringUtils.upperCase(&quot;aBc&quot;, Locale.ENGLISH) = &quot;ABC&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to upper case, may be null
     * @param locale  the locale that defines the case transformation rules, must not be null
     * @return the upper cased String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 3.0
     */
    public static String upperCase(String str, Locale locale) {
<span class="fc bfc" id="L4481" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4482">            return null;</span>
        }
<span class="fc" id="L4484">        return str.toUpperCase(locale);</span>
    }

    /**
     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase()}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lowerCase(null)  = null
     * StringUtils.lowerCase(&quot;&quot;)    = &quot;&quot;
     * StringUtils.lowerCase(&quot;aBc&quot;) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; As described in the documentation for {@link String#toLowerCase()},
     * the result of this method is affected by the current locale.
     * For platform-independent case transformations, the method {@link #lowerCase(String, Locale)}
     * should be used with a specific locale (e.g. {@link Locale#ENGLISH}).&lt;/p&gt;
     *
     * @param str  the String to lower case, may be null
     * @return the lower cased String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String lowerCase(String str) {
<span class="fc bfc" id="L4507" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4508">            return null;</span>
        }
<span class="fc" id="L4510">        return str.toLowerCase();</span>
    }

    /**
     * &lt;p&gt;Converts a String to lower case as per {@link String#toLowerCase(Locale)}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.lowerCase(null, Locale.ENGLISH)  = null
     * StringUtils.lowerCase(&quot;&quot;, Locale.ENGLISH)    = &quot;&quot;
     * StringUtils.lowerCase(&quot;aBc&quot;, Locale.ENGLISH) = &quot;abc&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to lower case, may be null
     * @param locale  the locale that defines the case transformation rules, must not be null
     * @return the lower cased String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 3.0
     */
    public static String lowerCase(String str, Locale locale) {
<span class="fc bfc" id="L4530" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4531">            return null;</span>
        }
<span class="fc" id="L4533">        return str.toLowerCase(locale);</span>
    }

    /**
     * &lt;p&gt;Capitalizes a String changing the first letter to title case as
     * per {@link Character#toTitleCase(char)}. No other letters are changed.&lt;/p&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#capitalize(String)}.
     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.capitalize(null)  = null
     * StringUtils.capitalize(&quot;&quot;)    = &quot;&quot;
     * StringUtils.capitalize(&quot;cat&quot;) = &quot;Cat&quot;
     * StringUtils.capitalize(&quot;cAt&quot;) = &quot;CAt&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to capitalize, may be null
     * @return the capitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @see WordUtils#capitalize(String)
     * @see #uncapitalize(String)
     * @since 2.0
     */
    public static String capitalize(String str) {
        int strLen;
<span class="fc bfc" id="L4558" title="All 4 branches covered.">        if (str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L4559">            return str;</span>
        }
<span class="fc" id="L4561">        return new StringBuilder(strLen)</span>
<span class="fc" id="L4562">            .append(Character.toTitleCase(str.charAt(0)))</span>
<span class="fc" id="L4563">            .append(str.substring(1))</span>
<span class="fc" id="L4564">            .toString();</span>
    }

    /**
     * &lt;p&gt;Uncapitalizes a String changing the first letter to title case as
     * per {@link Character#toLowerCase(char)}. No other letters are changed.&lt;/p&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#uncapitalize(String)}.
     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.uncapitalize(null)  = null
     * StringUtils.uncapitalize(&quot;&quot;)    = &quot;&quot;
     * StringUtils.uncapitalize(&quot;Cat&quot;) = &quot;cat&quot;
     * StringUtils.uncapitalize(&quot;CAT&quot;) = &quot;cAT&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to uncapitalize, may be null
     * @return the uncapitalized String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @see WordUtils#uncapitalize(String)
     * @see #capitalize(String)
     * @since 2.0
     */
    public static String uncapitalize(String str) {
        int strLen;
<span class="fc bfc" id="L4589" title="All 4 branches covered.">        if (str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L4590">            return str;</span>
        }
<span class="fc" id="L4592">        return new StringBuilder(strLen)</span>
<span class="fc" id="L4593">            .append(Character.toLowerCase(str.charAt(0)))</span>
<span class="fc" id="L4594">            .append(str.substring(1))</span>
<span class="fc" id="L4595">            .toString();</span>
    }

    /**
     * &lt;p&gt;Swaps the case of a String changing upper and title case to
     * lower case, and lower case to upper case.&lt;/p&gt;
     *
     * &lt;ul&gt;
     *  &lt;li&gt;Upper case character converts to Lower case&lt;/li&gt;
     *  &lt;li&gt;Title case character converts to Lower case&lt;/li&gt;
     *  &lt;li&gt;Lower case character converts to Upper case&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * &lt;p&gt;For a word based algorithm, see {@link WordUtils#swapCase(String)}.
     * A &lt;code&gt;null&lt;/code&gt; input String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.swapCase(null)                 = null
     * StringUtils.swapCase(&quot;&quot;)                   = &quot;&quot;
     * StringUtils.swapCase(&quot;The dog has a BONE&quot;) = &quot;tHE DOG HAS A bone&quot;
     * &lt;/pre&gt;
     *
     * &lt;p&gt;NOTE: This method changed in Lang version 2.0.
     * It no longer performs a word based algorithm.
     * If you only use ASCII, you will notice no change.
     * That functionality is available in WordUtils.&lt;/p&gt;
     *
     * @param str  the String to swap case, may be null
     * @return the changed String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String swapCase(String str) {
        int strLen;
<span class="fc bfc" id="L4627" title="All 4 branches covered.">        if (str == null || (strLen = str.length()) == 0) {</span>
<span class="fc" id="L4628">            return str;</span>
        }
<span class="fc" id="L4630">        StringBuilder buffer = new StringBuilder(strLen);</span>

<span class="fc" id="L4632">        char ch = 0;</span>
<span class="fc bfc" id="L4633" title="All 2 branches covered.">        for (int i = 0; i &lt; strLen; i++) {</span>
<span class="fc" id="L4634">            ch = str.charAt(i);</span>
<span class="fc bfc" id="L4635" title="All 2 branches covered.">            if (Character.isUpperCase(ch)) {</span>
<span class="fc" id="L4636">                ch = Character.toLowerCase(ch);</span>
<span class="pc bpc" id="L4637" title="1 of 2 branches missed.">            } else if (Character.isTitleCase(ch)) {</span>
<span class="nc" id="L4638">                ch = Character.toLowerCase(ch);</span>
<span class="fc bfc" id="L4639" title="All 2 branches covered.">            } else if (Character.isLowerCase(ch)) {</span>
<span class="fc" id="L4640">                ch = Character.toUpperCase(ch);</span>
            }
<span class="fc" id="L4642">            buffer.append(ch);</span>
        }
<span class="fc" id="L4644">        return buffer.toString();</span>
    }

    // Count matches
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Counts how many times the substring appears in the larger String.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; or empty (&quot;&quot;) String input returns &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.countMatches(null, *)       = 0
     * StringUtils.countMatches(&quot;&quot;, *)         = 0
     * StringUtils.countMatches(&quot;abba&quot;, null)  = 0
     * StringUtils.countMatches(&quot;abba&quot;, &quot;&quot;)    = 0
     * StringUtils.countMatches(&quot;abba&quot;, &quot;a&quot;)   = 2
     * StringUtils.countMatches(&quot;abba&quot;, &quot;ab&quot;)  = 1
     * StringUtils.countMatches(&quot;abba&quot;, &quot;xxx&quot;) = 0
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param sub  the substring to count, may be null
     * @return the number of occurrences, 0 if either String is &lt;code&gt;null&lt;/code&gt;
     */
    public static int countMatches(String str, String sub) {
<span class="fc bfc" id="L4669" title="All 4 branches covered.">        if (isEmpty(str) || isEmpty(sub)) {</span>
<span class="fc" id="L4670">            return 0;</span>
        }
<span class="fc" id="L4672">        int count = 0;</span>
<span class="fc" id="L4673">        int idx = 0;</span>
<span class="fc bfc" id="L4674" title="All 2 branches covered.">        while ((idx = str.indexOf(sub, idx)) != -1) {</span>
<span class="fc" id="L4675">            count++;</span>
<span class="fc" id="L4676">            idx += sub.length();</span>
        }
<span class="fc" id="L4678">        return count;</span>
    }

    // Character Tests
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if the String contains only unicode letters.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlpha(null)   = false
     * StringUtils.isAlpha(&quot;&quot;)     = true
     * StringUtils.isAlpha(&quot;  &quot;)   = false
     * StringUtils.isAlpha(&quot;abc&quot;)  = true
     * StringUtils.isAlpha(&quot;ab2c&quot;) = false
     * StringUtils.isAlpha(&quot;ab-c&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters, and is non-null
     */
    public static boolean isAlpha(String str) {
<span class="fc bfc" id="L4702" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4703">            return false;</span>
        }
<span class="fc" id="L4705">        int sz = str.length();</span>
<span class="fc bfc" id="L4706" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4707" title="All 2 branches covered.">            if (Character.isLetter(str.charAt(i)) == false) {</span>
<span class="fc" id="L4708">                return false;</span>
            }
        }
<span class="fc" id="L4711">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only unicode letters and
     * space (' ').&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphaSpace(null)   = false
     * StringUtils.isAlphaSpace(&quot;&quot;)     = true
     * StringUtils.isAlphaSpace(&quot;  &quot;)   = true
     * StringUtils.isAlphaSpace(&quot;abc&quot;)  = true
     * StringUtils.isAlphaSpace(&quot;ab c&quot;) = true
     * StringUtils.isAlphaSpace(&quot;ab2c&quot;) = false
     * StringUtils.isAlphaSpace(&quot;ab-c&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters and space,
     *  and is non-null
     */
    public static boolean isAlphaSpace(String str) {
<span class="fc bfc" id="L4736" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4737">            return false;</span>
        }
<span class="fc" id="L4739">        int sz = str.length();</span>
<span class="fc bfc" id="L4740" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4741" title="All 4 branches covered.">            if ((Character.isLetter(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != ' ')) {</span>
<span class="fc" id="L4742">                return false;</span>
            }
        }
<span class="fc" id="L4745">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only unicode letters or digits.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphanumeric(null)   = false
     * StringUtils.isAlphanumeric(&quot;&quot;)     = true
     * StringUtils.isAlphanumeric(&quot;  &quot;)   = false
     * StringUtils.isAlphanumeric(&quot;abc&quot;)  = true
     * StringUtils.isAlphanumeric(&quot;ab c&quot;) = false
     * StringUtils.isAlphanumeric(&quot;ab2c&quot;) = true
     * StringUtils.isAlphanumeric(&quot;ab-c&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters or digits,
     *  and is non-null
     */
    public static boolean isAlphanumeric(String str) {
<span class="fc bfc" id="L4769" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4770">            return false;</span>
        }
<span class="fc" id="L4772">        int sz = str.length();</span>
<span class="fc bfc" id="L4773" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4774" title="All 2 branches covered.">            if (Character.isLetterOrDigit(str.charAt(i)) == false) {</span>
<span class="fc" id="L4775">                return false;</span>
            }
        }
<span class="fc" id="L4778">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only unicode letters, digits
     * or space (&lt;code&gt;' '&lt;/code&gt;).&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAlphanumeric(null)   = false
     * StringUtils.isAlphanumeric(&quot;&quot;)     = true
     * StringUtils.isAlphanumeric(&quot;  &quot;)   = true
     * StringUtils.isAlphanumeric(&quot;abc&quot;)  = true
     * StringUtils.isAlphanumeric(&quot;ab c&quot;) = true
     * StringUtils.isAlphanumeric(&quot;ab2c&quot;) = true
     * StringUtils.isAlphanumeric(&quot;ab-c&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains letters, digits or space,
     *  and is non-null
     */
    public static boolean isAlphanumericSpace(String str) {
<span class="fc bfc" id="L4803" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4804">            return false;</span>
        }
<span class="fc" id="L4806">        int sz = str.length();</span>
<span class="fc bfc" id="L4807" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4808" title="All 4 branches covered.">            if ((Character.isLetterOrDigit(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != ' ')) {</span>
<span class="fc" id="L4809">                return false;</span>
            }
        }
<span class="fc" id="L4812">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the string contains only ASCII printable characters.&lt;/p&gt;
     * 
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     * 
     * &lt;pre&gt;
     * StringUtils.isAsciiPrintable(null)     = false
     * StringUtils.isAsciiPrintable(&quot;&quot;)       = true
     * StringUtils.isAsciiPrintable(&quot; &quot;)      = true
     * StringUtils.isAsciiPrintable(&quot;Ceki&quot;)   = true
     * StringUtils.isAsciiPrintable(&quot;ab2c&quot;)   = true
     * StringUtils.isAsciiPrintable(&quot;!ab-c~&quot;) = true
     * StringUtils.isAsciiPrintable(&quot;\u0020&quot;) = true
     * StringUtils.isAsciiPrintable(&quot;\u0021&quot;) = true
     * StringUtils.isAsciiPrintable(&quot;\u007e&quot;) = true
     * StringUtils.isAsciiPrintable(&quot;\u007f&quot;) = false
     * StringUtils.isAsciiPrintable(&quot;Ceki G\u00fclc\u00fc&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str the string to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if every character is in the range
     *  32 thru 126
     * @since 2.1
     */
    public static boolean isAsciiPrintable(String str) {
<span class="fc bfc" id="L4841" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4842">            return false;</span>
        }
<span class="fc" id="L4844">        int sz = str.length();</span>
<span class="fc bfc" id="L4845" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4846" title="All 2 branches covered.">            if (CharUtils.isAsciiPrintable(str.charAt(i)) == false) {</span>
<span class="fc" id="L4847">                return false;</span>
            }
        }
<span class="fc" id="L4850">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only unicode digits.
     * A decimal point is not a unicode digit and returns false.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNumeric(null)   = false
     * StringUtils.isNumeric(&quot;&quot;)     = true
     * StringUtils.isNumeric(&quot;  &quot;)   = false
     * StringUtils.isNumeric(&quot;123&quot;)  = true
     * StringUtils.isNumeric(&quot;12 3&quot;) = false
     * StringUtils.isNumeric(&quot;ab2c&quot;) = false
     * StringUtils.isNumeric(&quot;12-3&quot;) = false
     * StringUtils.isNumeric(&quot;12.3&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains digits, and is non-null
     */
    public static boolean isNumeric(String str) {
<span class="fc bfc" id="L4875" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4876">            return false;</span>
        }
<span class="fc" id="L4878">        int sz = str.length();</span>
<span class="fc bfc" id="L4879" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4880" title="All 2 branches covered.">            if (Character.isDigit(str.charAt(i)) == false) {</span>
<span class="fc" id="L4881">                return false;</span>
            }
        }
<span class="fc" id="L4884">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only unicode digits or space
     * (&lt;code&gt;' '&lt;/code&gt;).
     * A decimal point is not a unicode digit and returns false.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isNumeric(null)   = false
     * StringUtils.isNumeric(&quot;&quot;)     = true
     * StringUtils.isNumeric(&quot;  &quot;)   = true
     * StringUtils.isNumeric(&quot;123&quot;)  = true
     * StringUtils.isNumeric(&quot;12 3&quot;) = true
     * StringUtils.isNumeric(&quot;ab2c&quot;) = false
     * StringUtils.isNumeric(&quot;12-3&quot;) = false
     * StringUtils.isNumeric(&quot;12.3&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains digits or space,
     *  and is non-null
     */
    public static boolean isNumericSpace(String str) {
<span class="fc bfc" id="L4911" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4912">            return false;</span>
        }
<span class="fc" id="L4914">        int sz = str.length();</span>
<span class="fc bfc" id="L4915" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4916" title="All 4 branches covered.">            if ((Character.isDigit(str.charAt(i)) == false) &amp;&amp; (str.charAt(i) != ' ')) {</span>
<span class="fc" id="L4917">                return false;</span>
            }
        }
<span class="fc" id="L4920">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only whitespace.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isWhitespace(null)   = false
     * StringUtils.isWhitespace(&quot;&quot;)     = true
     * StringUtils.isWhitespace(&quot;  &quot;)   = true
     * StringUtils.isWhitespace(&quot;abc&quot;)  = false
     * StringUtils.isWhitespace(&quot;ab2c&quot;) = false
     * StringUtils.isWhitespace(&quot;ab-c&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains whitespace, and is non-null
     * @since 2.0
     */
    public static boolean isWhitespace(String str) {
<span class="fc bfc" id="L4943" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L4944">            return false;</span>
        }
<span class="fc" id="L4946">        int sz = str.length();</span>
<span class="fc bfc" id="L4947" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4948" title="All 2 branches covered.">            if ((Character.isWhitespace(str.charAt(i)) == false)) {</span>
<span class="fc" id="L4949">                return false;</span>
            }
        }
<span class="fc" id="L4952">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only lowercase characters.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAllLowerCase(null)   = false
     * StringUtils.isAllLowerCase(&quot;&quot;)     = false
     * StringUtils.isAllLowerCase(&quot;  &quot;)   = false
     * StringUtils.isAllLowerCase(&quot;abc&quot;)  = true
     * StringUtils.isAllLowerCase(&quot;abC&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains lowercase characters, and is non-null
     */
    public static boolean isAllLowerCase(String str) {
<span class="fc bfc" id="L4973" title="All 4 branches covered.">        if (str == null || isEmpty(str)) {</span>
<span class="fc" id="L4974">            return false;</span>
        }
<span class="fc" id="L4976">        int sz = str.length();</span>
<span class="fc bfc" id="L4977" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L4978" title="All 2 branches covered.">            if (Character.isLowerCase(str.charAt(i)) == false) {</span>
<span class="fc" id="L4979">                return false;</span>
            }
        }
<span class="fc" id="L4982">        return true;</span>
    }

    /**
     * &lt;p&gt;Checks if the String contains only uppercase characters.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.
     * An empty String (&quot;&quot;) will return &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.isAllUpperCase(null)   = false
     * StringUtils.isAllUpperCase(&quot;&quot;)     = false
     * StringUtils.isAllUpperCase(&quot;  &quot;)   = false
     * StringUtils.isAllUpperCase(&quot;ABC&quot;)  = true
     * StringUtils.isAllUpperCase(&quot;aBC&quot;) = false
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if only contains uppercase characters, and is non-null
     */
    public static boolean isAllUpperCase(String str) {
<span class="fc bfc" id="L5003" title="All 4 branches covered.">        if (str == null || isEmpty(str)) {</span>
<span class="fc" id="L5004">            return false;</span>
        }
<span class="fc" id="L5006">        int sz = str.length();</span>
<span class="fc bfc" id="L5007" title="All 2 branches covered.">        for (int i = 0; i &lt; sz; i++) {</span>
<span class="fc bfc" id="L5008" title="All 2 branches covered.">            if (Character.isUpperCase(str.charAt(i)) == false) {</span>
<span class="fc" id="L5009">                return false;</span>
            }
        }
<span class="fc" id="L5012">        return true;</span>
    }

    // Defaults
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Returns either the passed in String,
     * or if the String is &lt;code&gt;null&lt;/code&gt;, an empty String (&quot;&quot;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultString(null)  = &quot;&quot;
     * StringUtils.defaultString(&quot;&quot;)    = &quot;&quot;
     * StringUtils.defaultString(&quot;bat&quot;) = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @see ObjectUtils#toString(Object)
     * @see String#valueOf(Object)
     * @param str  the String to check, may be null
     * @return the passed in String, or the empty String if it
     *  was &lt;code&gt;null&lt;/code&gt;
     */
    public static String defaultString(String str) {
<span class="fc bfc" id="L5034" title="All 2 branches covered.">        return str == null ? EMPTY : str;</span>
    }

    /**
     * &lt;p&gt;Returns either the passed in String, or if the String is
     * &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultString(null, &quot;NULL&quot;)  = &quot;NULL&quot;
     * StringUtils.defaultString(&quot;&quot;, &quot;NULL&quot;)    = &quot;&quot;
     * StringUtils.defaultString(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
     * &lt;/pre&gt;
     *
     * @see ObjectUtils#toString(Object,String)
     * @see String#valueOf(Object)
     * @param str  the String to check, may be null
     * @param defaultStr  the default String to return
     *  if the input is &lt;code&gt;null&lt;/code&gt;, may be null
     * @return the passed in String, or the default if it was &lt;code&gt;null&lt;/code&gt;
     */
    public static String defaultString(String str, String defaultStr) {
<span class="fc bfc" id="L5055" title="All 2 branches covered.">        return str == null ? defaultStr : str;</span>
    }

    /**
     * &lt;p&gt;Returns either the passed in String, or if the String is
     * empty or &lt;code&gt;null&lt;/code&gt;, the value of &lt;code&gt;defaultStr&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.defaultIfEmpty(null, &quot;NULL&quot;)  = &quot;NULL&quot;
     * StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;
     * StringUtils.defaultIfEmpty(&quot;bat&quot;, &quot;NULL&quot;) = &quot;bat&quot;
     * StringUtils.defaultIfEmpty(&quot;&quot;, null)      = null
     * &lt;/pre&gt;
     *
     * @see StringUtils#defaultString(String, String)
     * @param str  the String to check, may be null
     * @param defaultStr  the default String to return
     *  if the input is empty (&quot;&quot;) or &lt;code&gt;null&lt;/code&gt;, may be null
     * @return the passed in String, or the default
     */
    public static String defaultIfEmpty(String str, String defaultStr) {
<span class="fc bfc" id="L5076" title="All 2 branches covered.">        return StringUtils.isEmpty(str) ? defaultStr : str;</span>
    }

    // Reversing
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Reverses a String as per {@link StringBuilder#reverse()}.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; String returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.reverse(null)  = null
     * StringUtils.reverse(&quot;&quot;)    = &quot;&quot;
     * StringUtils.reverse(&quot;bat&quot;) = &quot;tab&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to reverse, may be null
     * @return the reversed String, &lt;code&gt;null&lt;/code&gt; if null String input
     */
    public static String reverse(String str) {
<span class="fc bfc" id="L5096" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L5097">            return null;</span>
        }
<span class="fc" id="L5099">        return new StringBuilder(str).reverse().toString();</span>
    }

    /**
     * &lt;p&gt;Reverses a String that is delimited by a specific character.&lt;/p&gt;
     *
     * &lt;p&gt;The Strings between the delimiters are not reversed.
     * Thus java.lang.String becomes String.lang.java (if the delimiter
     * is &lt;code&gt;'.'&lt;/code&gt;).&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.reverseDelimited(null, *)      = null
     * StringUtils.reverseDelimited(&quot;&quot;, *)        = &quot;&quot;
     * StringUtils.reverseDelimited(&quot;a.b.c&quot;, 'x') = &quot;a.b.c&quot;
     * StringUtils.reverseDelimited(&quot;a.b.c&quot;, &quot;.&quot;) = &quot;c.b.a&quot;
     * &lt;/pre&gt;
     *
     * @param str  the String to reverse, may be null
     * @param separatorChar  the separator character to use
     * @return the reversed String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @since 2.0
     */
    public static String reverseDelimited(String str, char separatorChar) {
<span class="fc bfc" id="L5122" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L5123">            return null;</span>
        }
        // could implement manually, but simple way is to reuse other,
        // probably slower, methods.
<span class="fc" id="L5127">        String[] strs = split(str, separatorChar);</span>
<span class="fc" id="L5128">        ArrayUtils.reverse(strs);</span>
<span class="fc" id="L5129">        return join(strs, separatorChar);</span>
    }

    // Abbreviating
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
     * &quot;Now is the time for all good men&quot; into &quot;Now is the time for...&quot;&lt;/p&gt;
     *
     * &lt;p&gt;Specifically:
     * &lt;ul&gt;
     *   &lt;li&gt;If &lt;code&gt;str&lt;/code&gt; is less than &lt;code&gt;maxWidth&lt;/code&gt; characters
     *       long, return it.&lt;/li&gt;
     *   &lt;li&gt;Else abbreviate it to &lt;code&gt;(substring(str, 0, max-3) + &quot;...&quot;)&lt;/code&gt;.&lt;/li&gt;
     *   &lt;li&gt;If &lt;code&gt;maxWidth&lt;/code&gt; is less than &lt;code&gt;4&lt;/code&gt;, throw an
     *       &lt;code&gt;IllegalArgumentException&lt;/code&gt;.&lt;/li&gt;
     *   &lt;li&gt;In no case will it return a String of length greater than
     *       &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/li&gt;
     * &lt;/ul&gt;
     * &lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.abbreviate(null, *)      = null
     * StringUtils.abbreviate(&quot;&quot;, 4)        = &quot;&quot;
     * StringUtils.abbreviate(&quot;abcdefg&quot;, 6) = &quot;abc...&quot;
     * StringUtils.abbreviate(&quot;abcdefg&quot;, 7) = &quot;abcdefg&quot;
     * StringUtils.abbreviate(&quot;abcdefg&quot;, 8) = &quot;abcdefg&quot;
     * StringUtils.abbreviate(&quot;abcdefg&quot;, 4) = &quot;a...&quot;
     * StringUtils.abbreviate(&quot;abcdefg&quot;, 3) = IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param maxWidth  maximum length of result String, must be at least 4
     * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @throws IllegalArgumentException if the width is too small
     * @since 2.0
     */
    public static String abbreviate(String str, int maxWidth) {
<span class="fc" id="L5167">        return abbreviate(str, 0, maxWidth);</span>
    }

    /**
     * &lt;p&gt;Abbreviates a String using ellipses. This will turn
     * &quot;Now is the time for all good men&quot; into &quot;...is the time for...&quot;&lt;/p&gt;
     *
     * &lt;p&gt;Works like &lt;code&gt;abbreviate(String, int)&lt;/code&gt;, but allows you to specify
     * a &quot;left edge&quot; offset.  Note that this left edge is not necessarily going to
     * be the leftmost character in the result, or the first character following the
     * ellipses, but it will appear somewhere in the result.
     *
     * &lt;p&gt;In no case will it return a String of length greater than
     * &lt;code&gt;maxWidth&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.abbreviate(null, *, *)                = null
     * StringUtils.abbreviate(&quot;&quot;, 0, 4)                  = &quot;&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, -1, 10) = &quot;abcdefg...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 0, 10)  = &quot;abcdefg...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 1, 10)  = &quot;abcdefg...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 4, 10)  = &quot;abcdefg...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 5, 10)  = &quot;...fghi...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 6, 10)  = &quot;...ghij...&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 8, 10)  = &quot;...ijklmno&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 10, 10) = &quot;...ijklmno&quot;
     * StringUtils.abbreviate(&quot;abcdefghijklmno&quot;, 12, 10) = &quot;...ijklmno&quot;
     * StringUtils.abbreviate(&quot;abcdefghij&quot;, 0, 3)        = IllegalArgumentException
     * StringUtils.abbreviate(&quot;abcdefghij&quot;, 5, 6)        = IllegalArgumentException
     * &lt;/pre&gt;
     *
     * @param str  the String to check, may be null
     * @param offset  left edge of source String
     * @param maxWidth  maximum length of result String, must be at least 4
     * @return abbreviated String, &lt;code&gt;null&lt;/code&gt; if null String input
     * @throws IllegalArgumentException if the width is too small
     * @since 2.0
     */
    public static String abbreviate(String str, int offset, int maxWidth) {
<span class="fc bfc" id="L5206" title="All 2 branches covered.">        if (str == null) {</span>
<span class="fc" id="L5207">            return null;</span>
        }
<span class="fc bfc" id="L5209" title="All 2 branches covered.">        if (maxWidth &lt; 4) {</span>
<span class="fc" id="L5210">            throw new IllegalArgumentException(&quot;Minimum abbreviation width is 4&quot;);</span>
        }
<span class="fc bfc" id="L5212" title="All 2 branches covered.">        if (str.length() &lt;= maxWidth) {</span>
<span class="fc" id="L5213">            return str;</span>
        }
<span class="fc bfc" id="L5215" title="All 2 branches covered.">        if (offset &gt; str.length()) {</span>
<span class="fc" id="L5216">            offset = str.length();</span>
        }
<span class="fc bfc" id="L5218" title="All 2 branches covered.">        if ((str.length() - offset) &lt; (maxWidth - 3)) {</span>
<span class="fc" id="L5219">            offset = str.length() - (maxWidth - 3);</span>
        }
<span class="fc bfc" id="L5221" title="All 2 branches covered.">        if (offset &lt;= 4) {</span>
<span class="fc" id="L5222">            return str.substring(0, maxWidth - 3) + &quot;...&quot;;</span>
        }
<span class="fc bfc" id="L5224" title="All 2 branches covered.">        if (maxWidth &lt; 7) {</span>
<span class="fc" id="L5225">            throw new IllegalArgumentException(&quot;Minimum abbreviation width with offset is 7&quot;);</span>
        }
<span class="fc bfc" id="L5227" title="All 2 branches covered.">        if ((offset + (maxWidth - 3)) &lt; str.length()) {</span>
<span class="fc" id="L5228">            return &quot;...&quot; + abbreviate(str.substring(offset), maxWidth - 3);</span>
        }
<span class="fc" id="L5230">        return &quot;...&quot; + str.substring(str.length() - (maxWidth - 3));</span>
    }

    // Difference
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Compares two Strings, and returns the portion where they differ.
     * (More precisely, return the remainder of the second String,
     * starting from where it's different from the first.)&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;difference(&quot;i am a machine&quot;, &quot;i am a robot&quot;) -&gt; &quot;robot&quot;&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.difference(null, null) = null
     * StringUtils.difference(&quot;&quot;, &quot;&quot;) = &quot;&quot;
     * StringUtils.difference(&quot;&quot;, &quot;abc&quot;) = &quot;abc&quot;
     * StringUtils.difference(&quot;abc&quot;, &quot;&quot;) = &quot;&quot;
     * StringUtils.difference(&quot;abc&quot;, &quot;abc&quot;) = &quot;&quot;
     * StringUtils.difference(&quot;ab&quot;, &quot;abxyz&quot;) = &quot;xyz&quot;
     * StringUtils.difference(&quot;abcde&quot;, &quot;abxyz&quot;) = &quot;xyz&quot;
     * StringUtils.difference(&quot;abcde&quot;, &quot;xyz&quot;) = &quot;xyz&quot;
     * &lt;/pre&gt;
     *
     * @param str1  the first String, may be null
     * @param str2  the second String, may be null
     * @return the portion of str2 where it differs from str1; returns the
     * empty String if they are equal
     * @since 2.0
     */
    public static String difference(String str1, String str2) {
<span class="fc bfc" id="L5261" title="All 2 branches covered.">        if (str1 == null) {</span>
<span class="fc" id="L5262">            return str2;</span>
        }
<span class="fc bfc" id="L5264" title="All 2 branches covered.">        if (str2 == null) {</span>
<span class="fc" id="L5265">            return str1;</span>
        }
<span class="fc" id="L5267">        int at = indexOfDifference(str1, str2);</span>
<span class="fc bfc" id="L5268" title="All 2 branches covered.">        if (at == -1) {</span>
<span class="fc" id="L5269">            return EMPTY;</span>
        }
<span class="fc" id="L5271">        return str2.substring(at);</span>
    }

    /**
     * &lt;p&gt;Compares two Strings, and returns the index at which the
     * Strings begin to differ.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;indexOfDifference(&quot;i am a machine&quot;, &quot;i am a robot&quot;) -&gt; 7&lt;/code&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfDifference(null, null) = -1
     * StringUtils.indexOfDifference(&quot;&quot;, &quot;&quot;) = -1
     * StringUtils.indexOfDifference(&quot;&quot;, &quot;abc&quot;) = 0
     * StringUtils.indexOfDifference(&quot;abc&quot;, &quot;&quot;) = 0
     * StringUtils.indexOfDifference(&quot;abc&quot;, &quot;abc&quot;) = -1
     * StringUtils.indexOfDifference(&quot;ab&quot;, &quot;abxyz&quot;) = 2
     * StringUtils.indexOfDifference(&quot;abcde&quot;, &quot;abxyz&quot;) = 2
     * StringUtils.indexOfDifference(&quot;abcde&quot;, &quot;xyz&quot;) = 0
     * &lt;/pre&gt;
     *
     * @param str1  the first String, may be null
     * @param str2  the second String, may be null
     * @return the index where str2 and str1 begin to differ; -1 if they are equal
     * @since 2.0
     */
    public static int indexOfDifference(String str1, String str2) {
<span class="fc bfc" id="L5298" title="All 2 branches covered.">        if (str1 == str2) {</span>
<span class="fc" id="L5299">            return -1;</span>
        }
<span class="fc bfc" id="L5301" title="All 4 branches covered.">        if (str1 == null || str2 == null) {</span>
<span class="fc" id="L5302">            return 0;</span>
        }
        int i;
<span class="fc bfc" id="L5305" title="All 4 branches covered.">        for (i = 0; i &lt; str1.length() &amp;&amp; i &lt; str2.length(); ++i) {</span>
<span class="fc bfc" id="L5306" title="All 2 branches covered.">            if (str1.charAt(i) != str2.charAt(i)) {</span>
<span class="fc" id="L5307">                break;</span>
            }
        }
<span class="pc bpc" id="L5310" title="1 of 4 branches missed.">        if (i &lt; str2.length() || i &lt; str1.length()) {</span>
<span class="fc" id="L5311">            return i;</span>
        }
<span class="nc" id="L5313">        return -1;</span>
    }

    /**
     * &lt;p&gt;Compares all Strings in an array and returns the index at which the
     * Strings begin to differ.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;indexOfDifference(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) -&gt; 7&lt;/code&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.indexOfDifference(null) = -1
     * StringUtils.indexOfDifference(new String[] {}) = -1
     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;}) = -1
     * StringUtils.indexOfDifference(new String[] {null, null}) = -1
     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, &quot;&quot;}) = -1
     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, null}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, null, null}) = 0
     * StringUtils.indexOfDifference(new String[] {null, null, &quot;abc&quot;}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;&quot;, &quot;abc&quot;}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;&quot;}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;abc&quot;}) = -1
     * StringUtils.indexOfDifference(new String[] {&quot;abc&quot;, &quot;a&quot;}) = 1
     * StringUtils.indexOfDifference(new String[] {&quot;ab&quot;, &quot;abxyz&quot;}) = 2
     * StringUtils.indexOfDifference(new String[] {&quot;abcde&quot;, &quot;abxyz&quot;}) = 2
     * StringUtils.indexOfDifference(new String[] {&quot;abcde&quot;, &quot;xyz&quot;}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;xyz&quot;, &quot;abcde&quot;}) = 0
     * StringUtils.indexOfDifference(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) = 7
     * &lt;/pre&gt;
     *
     * @param strs  array of strings, entries may be null
     * @return the index where the strings begin to differ; -1 if they are all equal
     * @since 2.4
     */
    public static int indexOfDifference(String[] strs) {
<span class="fc bfc" id="L5348" title="All 4 branches covered.">        if (strs == null || strs.length &lt;= 1) {</span>
<span class="fc" id="L5349">            return -1;</span>
        }
<span class="fc" id="L5351">        boolean anyStringNull = false;</span>
<span class="fc" id="L5352">        boolean allStringsNull = true;</span>
<span class="fc" id="L5353">        int arrayLen = strs.length;</span>
<span class="fc" id="L5354">        int shortestStrLen = Integer.MAX_VALUE;</span>
<span class="fc" id="L5355">        int longestStrLen = 0;</span>

        // find the min and max string lengths; this avoids checking to make
        // sure we are not exceeding the length of the string each time through
        // the bottom loop.
<span class="fc bfc" id="L5360" title="All 2 branches covered.">        for (int i = 0; i &lt; arrayLen; i++) {</span>
<span class="fc bfc" id="L5361" title="All 2 branches covered.">            if (strs[i] == null) {</span>
<span class="fc" id="L5362">                anyStringNull = true;</span>
<span class="fc" id="L5363">                shortestStrLen = 0;</span>
            } else {
<span class="fc" id="L5365">                allStringsNull = false;</span>
<span class="fc" id="L5366">                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);</span>
<span class="fc" id="L5367">                longestStrLen = Math.max(strs[i].length(), longestStrLen);</span>
            }
        }

        // handle lists containing all nulls or all empty strings
<span class="fc bfc" id="L5372" title="All 6 branches covered.">        if (allStringsNull || (longestStrLen == 0 &amp;&amp; !anyStringNull)) {</span>
<span class="fc" id="L5373">            return -1;</span>
        }

        // handle lists containing some nulls or some empty strings
<span class="fc bfc" id="L5377" title="All 2 branches covered.">        if (shortestStrLen == 0) {</span>
<span class="fc" id="L5378">            return 0;</span>
        }

        // find the position with the first difference across all strings
<span class="fc" id="L5382">        int firstDiff = -1;</span>
<span class="fc bfc" id="L5383" title="All 2 branches covered.">        for (int stringPos = 0; stringPos &lt; shortestStrLen; stringPos++) {</span>
<span class="fc" id="L5384">            char comparisonChar = strs[0].charAt(stringPos);</span>
<span class="fc bfc" id="L5385" title="All 2 branches covered.">            for (int arrayPos = 1; arrayPos &lt; arrayLen; arrayPos++) {</span>
<span class="fc bfc" id="L5386" title="All 2 branches covered.">                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {</span>
<span class="fc" id="L5387">                    firstDiff = stringPos;</span>
<span class="fc" id="L5388">                    break;</span>
                }
            }
<span class="fc bfc" id="L5391" title="All 2 branches covered.">            if (firstDiff != -1) {</span>
<span class="fc" id="L5392">                break;</span>
            }
        }

<span class="fc bfc" id="L5396" title="All 4 branches covered.">        if (firstDiff == -1 &amp;&amp; shortestStrLen != longestStrLen) {</span>
            // we compared all of the characters up to the length of the
            // shortest string and didn't find a match, but the string lengths
            // vary, so return the length of the shortest string.
<span class="fc" id="L5400">            return shortestStrLen;</span>
        }
<span class="fc" id="L5402">        return firstDiff;</span>
    }
    
    /**
     * &lt;p&gt;Compares all Strings in an array and returns the initial sequence of 
     * characters that is common to all of them.&lt;/p&gt;
     *
     * &lt;p&gt;For example,
     * &lt;code&gt;getCommonPrefix(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) -&gt; &quot;i am a &quot;&lt;/code&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.getCommonPrefix(null) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;}) = &quot;abc&quot;
     * StringUtils.getCommonPrefix(new String[] {null, null}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, &quot;&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, null}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, null, null}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {null, null, &quot;abc&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;&quot;, &quot;abc&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;abc&quot;}) = &quot;abc&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abc&quot;, &quot;a&quot;}) = &quot;a&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;ab&quot;, &quot;abxyz&quot;}) = &quot;ab&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abcde&quot;, &quot;abxyz&quot;}) = &quot;ab&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;abcde&quot;, &quot;xyz&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;xyz&quot;, &quot;abcde&quot;}) = &quot;&quot;
     * StringUtils.getCommonPrefix(new String[] {&quot;i am a machine&quot;, &quot;i am a robot&quot;}) = &quot;i am a &quot;
     * &lt;/pre&gt;
     *
     * @param strs  array of String objects, entries may be null
     * @return the initial sequence of characters that are common to all Strings
     * in the array; empty String if the array is null, the elements are all null 
     * or if there is no common prefix. 
     * @since 2.4
     */
    public static String getCommonPrefix(String[] strs) {
<span class="fc bfc" id="L5439" title="All 4 branches covered.">        if (strs == null || strs.length == 0) {</span>
<span class="fc" id="L5440">            return EMPTY;</span>
        }
<span class="fc" id="L5442">        int smallestIndexOfDiff = indexOfDifference(strs);</span>
<span class="fc bfc" id="L5443" title="All 2 branches covered.">        if (smallestIndexOfDiff == -1) {</span>
            // all strings were identical
<span class="fc bfc" id="L5445" title="All 2 branches covered.">            if (strs[0] == null) {</span>
<span class="fc" id="L5446">                return EMPTY;</span>
            }
<span class="fc" id="L5448">            return strs[0];</span>
<span class="fc bfc" id="L5449" title="All 2 branches covered.">        } else if (smallestIndexOfDiff == 0) {</span>
            // there were no common initial characters
<span class="fc" id="L5451">            return EMPTY;</span>
        } else {
            // we found a common initial character sequence
<span class="fc" id="L5454">            return strs[0].substring(0, smallestIndexOfDiff);</span>
        }
    }  
    
    // Misc
    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Find the Levenshtein distance between two Strings.&lt;/p&gt;
     *
     * &lt;p&gt;This is the number of changes needed to change one String into
     * another, where each change is a single character modification (deletion,
     * insertion or substitution).&lt;/p&gt;
     *
     * &lt;p&gt;The previous implementation of the Levenshtein distance algorithm
     * was from &lt;a href=&quot;http://www.merriampark.com/ld.htm&quot;&gt;http://www.merriampark.com/ld.htm&lt;/a&gt;&lt;/p&gt;
     *
     * &lt;p&gt;Chas Emerick has written an implementation in Java, which avoids an OutOfMemoryError
     * which can occur when my Java implementation is used with very large strings.&lt;br&gt;
     * This implementation of the Levenshtein distance algorithm
     * is from &lt;a href=&quot;http://www.merriampark.com/ldjava.htm&quot;&gt;http://www.merriampark.com/ldjava.htm&lt;/a&gt;&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
     * StringUtils.getLevenshteinDistance(&quot;&quot;,&quot;&quot;)               = 0
     * StringUtils.getLevenshteinDistance(&quot;&quot;,&quot;a&quot;)              = 1
     * StringUtils.getLevenshteinDistance(&quot;aaapppp&quot;, &quot;&quot;)       = 7
     * StringUtils.getLevenshteinDistance(&quot;frog&quot;, &quot;fog&quot;)       = 1
     * StringUtils.getLevenshteinDistance(&quot;fly&quot;, &quot;ant&quot;)        = 3
     * StringUtils.getLevenshteinDistance(&quot;elephant&quot;, &quot;hippo&quot;) = 7
     * StringUtils.getLevenshteinDistance(&quot;hippo&quot;, &quot;elephant&quot;) = 7
     * StringUtils.getLevenshteinDistance(&quot;hippo&quot;, &quot;zzzzzzzz&quot;) = 8
     * StringUtils.getLevenshteinDistance(&quot;hello&quot;, &quot;hallo&quot;)    = 1
     * &lt;/pre&gt;
     *
     * @param s  the first String, must not be null
     * @param t  the second String, must not be null
     * @return result distance
     * @throws IllegalArgumentException if either String input &lt;code&gt;null&lt;/code&gt;
     */
    public static int getLevenshteinDistance(String s, String t) {
<span class="fc bfc" id="L5495" title="All 4 branches covered.">        if (s == null || t == null) {</span>
<span class="fc" id="L5496">            throw new IllegalArgumentException(&quot;Strings must not be null&quot;);</span>
        }

        /*
           The difference between this impl. and the previous is that, rather 
           than creating and retaining a matrix of size s.length()+1 by t.length()+1, 
           we maintain two single-dimensional arrays of length s.length()+1.  The first, d,
           is the 'current working' distance array that maintains the newest distance cost
           counts as we iterate through the characters of String s.  Each time we increment
           the index of String t we are comparing, d is copied to p, the second int[].  Doing so
           allows us to retain the previous cost counts as required by the algorithm (taking 
           the minimum of the cost count to the left, up one, and diagonally up and to the left
           of the current cost count being calculated).  (Note that the arrays aren't really 
           copied anymore, just switched...this is clearly much better than cloning an array 
           or doing a System.arraycopy() each time  through the outer loop.)

           Effectively, the difference between the two implementations is this one does not 
           cause an out of memory condition when calculating the LD over two very large strings.
         */

<span class="fc" id="L5516">        int n = s.length(); // length of s</span>
<span class="fc" id="L5517">        int m = t.length(); // length of t</span>

<span class="fc bfc" id="L5519" title="All 2 branches covered.">        if (n == 0) {</span>
<span class="fc" id="L5520">            return m;</span>
<span class="fc bfc" id="L5521" title="All 2 branches covered.">        } else if (m == 0) {</span>
<span class="fc" id="L5522">            return n;</span>
        }

<span class="fc bfc" id="L5525" title="All 2 branches covered.">        if (n &gt; m) {</span>
            // swap the input strings to consume less memory
<span class="fc" id="L5527">            String tmp = s;</span>
<span class="fc" id="L5528">            s = t;</span>
<span class="fc" id="L5529">            t = tmp;</span>
<span class="fc" id="L5530">            n = m;</span>
<span class="fc" id="L5531">            m = t.length();</span>
        }

<span class="fc" id="L5534">        int p[] = new int[n+1]; //'previous' cost array, horizontally</span>
<span class="fc" id="L5535">        int d[] = new int[n+1]; // cost array, horizontally</span>
        int _d[]; //placeholder to assist in swapping p and d

        // indexes into strings s and t
        int i; // iterates through s
        int j; // iterates through t

        char t_j; // jth character of t

        int cost; // cost

<span class="fc bfc" id="L5546" title="All 2 branches covered.">        for (i = 0; i&lt;=n; i++) {</span>
<span class="fc" id="L5547">            p[i] = i;</span>
        }

<span class="fc bfc" id="L5550" title="All 2 branches covered.">        for (j = 1; j&lt;=m; j++) {</span>
<span class="fc" id="L5551">            t_j = t.charAt(j-1);</span>
<span class="fc" id="L5552">            d[0] = j;</span>

<span class="fc bfc" id="L5554" title="All 2 branches covered.">            for (i=1; i&lt;=n; i++) {</span>
<span class="fc bfc" id="L5555" title="All 2 branches covered.">                cost = s.charAt(i-1)==t_j ? 0 : 1;</span>
                // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
<span class="fc" id="L5557">                d[i] = Math.min(Math.min(d[i-1]+1, p[i]+1),  p[i-1]+cost);</span>
            }

            // copy current distance counts to 'previous row' distance counts
<span class="fc" id="L5561">            _d = p;</span>
<span class="fc" id="L5562">            p = d;</span>
<span class="fc" id="L5563">            d = _d;</span>
        }

        // our last action in the above loop was to switch d and p, so p now 
        // actually has the most recent cost counts
<span class="fc" id="L5568">        return p[n];</span>
    }

    /**
     * &lt;p&gt;Gets the minimum of three &lt;code&gt;int&lt;/code&gt; values.&lt;/p&gt;
     *
     * @param a  value 1
     * @param b  value 2
     * @param c  value 3
     * @return  the smallest of the values
     */
/*
    private static int min(int a, int b, int c) {
        // Method copied from NumberUtils to avoid dependency on subpackage
        if (b &lt; a) {
            a = b;
        }
        if (c &lt; a) {
            a = c;
        }
        return a;
    }
*/

    // startsWith
    //-----------------------------------------------------------------------

    /**
     * &lt;p&gt;Check if a String starts with a specified prefix.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWith(null, null)      = true
     * StringUtils.startsWith(null, &quot;abc&quot;)     = false
     * StringUtils.startsWith(&quot;abcdef&quot;, null)  = false
     * StringUtils.startsWith(&quot;abcdef&quot;, &quot;abc&quot;) = true
     * StringUtils.startsWith(&quot;ABCDEF&quot;, &quot;abc&quot;) = false
     * &lt;/pre&gt;
     *
     * @see java.lang.String#startsWith(String)
     * @param str  the String to check, may be null
     * @param prefix the prefix to find, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix, case sensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     * @since 2.4
     */
    public static boolean startsWith(String str, String prefix) {
<span class="fc" id="L5617">        return startsWith(str, prefix, false);</span>
    }

    /**
     * &lt;p&gt;Case insensitive check if a String starts with a specified prefix.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.startsWithIgnoreCase(null, null)      = true
     * StringUtils.startsWithIgnoreCase(null, &quot;abc&quot;)     = false
     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
     * StringUtils.startsWithIgnoreCase(&quot;abcdef&quot;, &quot;abc&quot;) = true
     * StringUtils.startsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;abc&quot;) = true
     * &lt;/pre&gt;
     *
     * @see java.lang.String#startsWith(String)
     * @param str  the String to check, may be null
     * @param prefix the prefix to find, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix, case insensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     * @since 2.4
     */
    public static boolean startsWithIgnoreCase(String str, String prefix) {
<span class="fc" id="L5642">        return startsWith(str, prefix, true);</span>
    }

    /**
     * &lt;p&gt;Check if a String starts with a specified prefix (optionally case insensitive).&lt;/p&gt;
     *
     * @see java.lang.String#startsWith(String)
     * @param str  the String to check, may be null
     * @param prefix the prefix to find, may be null
     * @param ignoreCase inidicates whether the compare should ignore case
     *  (case insensitive) or not.
     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix or
     *  both &lt;code&gt;null&lt;/code&gt;
     */
    private static boolean startsWith(String str, String prefix, boolean ignoreCase) {
<span class="fc bfc" id="L5657" title="All 4 branches covered.">        if (str == null || prefix == null) {</span>
<span class="fc bfc" id="L5658" title="All 4 branches covered.">            return (str == null &amp;&amp; prefix == null);</span>
        }
<span class="fc bfc" id="L5660" title="All 2 branches covered.">        if (prefix.length() &gt; str.length()) {</span>
<span class="fc" id="L5661">            return false;</span>
        }
<span class="fc" id="L5663">        return str.regionMatches(ignoreCase, 0, prefix, 0, prefix.length());</span>
    }
    
    /**
     * &lt;p&gt;Check if a String starts with any of an array of specified strings.&lt;/p&gt;
     * 
     * &lt;pre&gt;
     * StringUtils.startsWithAny(null, null)      = false
     * StringUtils.startsWithAny(null, new String[] {&quot;abc&quot;})  = false
     * StringUtils.startsWithAny(&quot;abcxyz&quot;, null)     = false
     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;&quot;}) = false
     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {&quot;abc&quot;}) = true
     * StringUtils.startsWithAny(&quot;abcxyz&quot;, new String[] {null, &quot;xyz&quot;, &quot;abc&quot;}) = true
     * &lt;/pre&gt;
     *
     * @param string  the String to check, may be null
     * @param searchStrings the Strings to find, may be null or empty
     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with any of the the prefixes, case insensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     * @since 3.0
     */
    public static boolean startsWithAny(String string, String[] searchStrings) {
<span class="fc bfc" id="L5685" title="All 4 branches covered.">        if (isEmpty(string) || ArrayUtils.isEmpty(searchStrings)) {</span>
<span class="fc" id="L5686">            return false;</span>
        }
<span class="fc bfc" id="L5688" title="All 2 branches covered.">        for (int i = 0; i &lt; searchStrings.length; i++) {</span>
<span class="fc" id="L5689">            String searchString = searchStrings[i];</span>
<span class="fc bfc" id="L5690" title="All 2 branches covered.">            if (StringUtils.startsWith(string, searchString)) {</span>
<span class="fc" id="L5691">                return true;</span>
            }
        }
<span class="fc" id="L5694">        return false;</span>
    }

    // endsWith
    //-----------------------------------------------------------------------

    /**
     * &lt;p&gt;Check if a String ends with a specified suffix.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered to be equal. The comparison is case sensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWith(null, null)      = true
     * StringUtils.endsWith(null, &quot;def&quot;)     = false
     * StringUtils.endsWith(&quot;abcdef&quot;, null)  = false
     * StringUtils.endsWith(&quot;abcdef&quot;, &quot;def&quot;) = true
     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;def&quot;) = false
     * StringUtils.endsWith(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
     * &lt;/pre&gt;
     *
     * @see java.lang.String#endsWith(String)
     * @param str  the String to check, may be null
     * @param suffix the suffix to find, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String ends with the suffix, case sensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     * @since 2.4
     */
    public static boolean endsWith(String str, String suffix) {
<span class="fc" id="L5723">        return endsWith(str, suffix, false);</span>
    }

    /**
     * &lt;p&gt;Case insensitive check if a String ends with a specified suffix.&lt;/p&gt;
     *
     * &lt;p&gt;&lt;code&gt;null&lt;/code&gt;s are handled without exceptions. Two &lt;code&gt;null&lt;/code&gt;
     * references are considered to be equal. The comparison is case insensitive.&lt;/p&gt;
     *
     * &lt;pre&gt;
     * StringUtils.endsWithIgnoreCase(null, null)      = true
     * StringUtils.endsWithIgnoreCase(null, &quot;def&quot;)     = false
     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, null)  = false
     * StringUtils.endsWithIgnoreCase(&quot;abcdef&quot;, &quot;def&quot;) = true
     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;def&quot;) = true
     * StringUtils.endsWithIgnoreCase(&quot;ABCDEF&quot;, &quot;cde&quot;) = false
     * &lt;/pre&gt;
     *
     * @see java.lang.String#endsWith(String)
     * @param str  the String to check, may be null
     * @param suffix the suffix to find, may be null
     * @return &lt;code&gt;true&lt;/code&gt; if the String ends with the suffix, case insensitive, or
     *  both &lt;code&gt;null&lt;/code&gt;
     * @since 2.4
     */
    public static boolean endsWithIgnoreCase(String str, String suffix) {
<span class="fc" id="L5749">        return endsWith(str, suffix, true);</span>
    }

    /**
     * &lt;p&gt;Check if a String ends with a specified suffix (optionally case insensitive).&lt;/p&gt;
     *
     * @see java.lang.String#endsWith(String)
     * @param str  the String to check, may be null
     * @param suffix the suffix to find, may be null
     * @param ignoreCase inidicates whether the compare should ignore case
     *  (case insensitive) or not.
     * @return &lt;code&gt;true&lt;/code&gt; if the String starts with the prefix or
     *  both &lt;code&gt;null&lt;/code&gt;
     */
    private static boolean endsWith(String str, String suffix, boolean ignoreCase) {
<span class="fc bfc" id="L5764" title="All 4 branches covered.">        if (str == null || suffix == null) {</span>
<span class="fc bfc" id="L5765" title="All 4 branches covered.">            return (str == null &amp;&amp; suffix == null);</span>
        }
<span class="fc bfc" id="L5767" title="All 2 branches covered.">        if (suffix.length() &gt; str.length()) {</span>
<span class="fc" id="L5768">            return false;</span>
        }
<span class="fc" id="L5770">        int strOffset = str.length() - suffix.length();</span>
<span class="fc" id="L5771">        return str.regionMatches(ignoreCase, strOffset, suffix, 0, suffix.length());</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>