<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExceptionUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons Lang</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.lang.exception</a> &gt; <span class="el_source">ExceptionUtils.java</span></div><h1>ExceptionUtils.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.lang.exception;

import java.io.PrintStream;
import java.io.PrintWriter;
import java.io.Serializable;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Set;
import java.util.StringTokenizer;

//import net.jcip.annotations.GuardedBy;
//import net.jcip.annotations.ThreadSafe;

import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.ClassUtils;
import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang.SystemUtils;

/**
 * &lt;p&gt;Provides utilities for manipulating and examining 
 * &lt;code&gt;Throwable&lt;/code&gt; objects.&lt;/p&gt;
 *
 * @author Daniel L. Rall
 * @author Dmitri Plotnikov
 * @author Stephen Colebourne
 * @author &lt;a href=&quot;mailto:ggregory@seagullsw.com&quot;&gt;Gary Gregory&lt;/a&gt;
 * @author Pete Gieser
 * @since 1.0
 * @version $Id$
 */
//@ThreadSafe
public class ExceptionUtils {
    
    /**
     * &lt;p&gt;Used when printing stack frames to denote the start of a
     * wrapped exception.&lt;/p&gt;
     *
     * &lt;p&gt;Package private for accessibility by test suite.&lt;/p&gt;
     */
    static final String WRAPPED_MARKER = &quot; [wrapped] &quot;;

    // Lock object for CAUSE_METHOD_NAMES
<span class="fc" id="L66">    private static final Object CAUSE_METHOD_NAMES_LOCK = new Object();</span>
    
    /**
     * &lt;p&gt;The names of methods commonly used to access a wrapped exception.&lt;/p&gt;
     */
//    @GuardedBy(&quot;CAUSE_METHOD_NAMES_LOCK&quot;)
<span class="fc" id="L72">    private static String[] CAUSE_METHOD_NAMES = {</span>
        &quot;getCause&quot;,
        &quot;getNextException&quot;,
        &quot;getTargetException&quot;,
        &quot;getException&quot;,
        &quot;getSourceException&quot;,
        &quot;getRootCause&quot;,
        &quot;getCausedByException&quot;,
        &quot;getNested&quot;,
        &quot;getLinkedException&quot;,
        &quot;getNestedException&quot;,
        &quot;getLinkedCause&quot;,
        &quot;getThrowable&quot;,
    };

    /**
     * &lt;p&gt;The Method object for Java 1.4 getCause.&lt;/p&gt;
     */
    private static final Method THROWABLE_CAUSE_METHOD;

    /**
     * &lt;p&gt;The Method object for Java 1.4 initCause.&lt;/p&gt;
     */
    private static final Method THROWABLE_INITCAUSE_METHOD;
    
    /**
     * An empty {@link ExceptionContext}.
     * @since 3.0
     */
<span class="fc" id="L101">    public static final ExceptionContext EMPTY_CONTEXT = new ExceptionContext() {</span>

        private static final long serialVersionUID = 1L;

        public ExceptionContext addLabeledValue(String label, Serializable value) {
<span class="nc" id="L106">          throw new UnsupportedOperationException();</span>
        }

        public Serializable getLabeledValue(String label) {
<span class="nc" id="L110">          return null;</span>
        }

        public Set&lt;String&gt; getLabelSet() {
<span class="nc" id="L114">          return Collections.&lt;String&gt;emptySet();</span>
        }

        public String getFormattedExceptionMessage(String baseMessage) {
<span class="nc" id="L118">          return baseMessage;</span>
        }

      };    
    static {
        Method causeMethod;
        try {
<span class="fc" id="L125">            causeMethod = Throwable.class.getMethod(&quot;getCause&quot;, (Class[]) null);</span>
<span class="nc" id="L126">        } catch (Exception e) {</span>
<span class="nc" id="L127">            causeMethod = null;</span>
<span class="fc" id="L128">        }</span>
<span class="fc" id="L129">        THROWABLE_CAUSE_METHOD = causeMethod;</span>
        try {
<span class="fc" id="L131">            causeMethod = Throwable.class.getMethod(&quot;initCause&quot;, new Class[]{Throwable.class});</span>
<span class="nc" id="L132">        } catch (Exception e) {</span>
<span class="nc" id="L133">            causeMethod = null;</span>
<span class="fc" id="L134">        }</span>
<span class="fc" id="L135">        THROWABLE_INITCAUSE_METHOD = causeMethod;</span>
<span class="fc" id="L136">    }</span>
    
    /**
     * &lt;p&gt;
     * Public constructor allows an instance of &lt;code&gt;ExceptionUtils&lt;/code&gt; to be created, although that is not
     * normally necessary.
     * &lt;/p&gt;
     */
    public ExceptionUtils() {
<span class="fc" id="L145">        super();</span>
<span class="fc" id="L146">    }</span>

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Adds to the list of method names used in the search for &lt;code&gt;Throwable&lt;/code&gt;
     * objects.&lt;/p&gt;
     * 
     * @param methodName  the methodName to add to the list, &lt;code&gt;null&lt;/code&gt;
     *  and empty strings are ignored
     * @since 2.0
     */
    public static void addCauseMethodName(String methodName) {
<span class="pc bpc" id="L158" title="1 of 4 branches missed.">        if (StringUtils.isNotEmpty(methodName) &amp;&amp; !isCauseMethodName(methodName)) {            </span>
<span class="fc" id="L159">            List&lt;String&gt; list = getCauseMethodNameList();</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">            if (list.add(methodName)) {</span>
<span class="fc" id="L161">                synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc" id="L162">                    CAUSE_METHOD_NAMES = toArray(list);</span>
<span class="fc" id="L163">                }</span>
            }
        }
<span class="fc" id="L166">    }</span>

    /**
     * &lt;p&gt;Removes from the list of method names used in the search for &lt;code&gt;Throwable&lt;/code&gt;
     * objects.&lt;/p&gt;
     * 
     * @param methodName  the methodName to remove from the list, &lt;code&gt;null&lt;/code&gt;
     *  and empty strings are ignored
     * @since 2.1
     */
    public static void removeCauseMethodName(String methodName) {
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">        if (StringUtils.isNotEmpty(methodName)) {</span>
<span class="fc" id="L178">            List&lt;String&gt; list = getCauseMethodNameList();</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">            if (list.remove(methodName)) {</span>
<span class="fc" id="L180">                synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc" id="L181">                    CAUSE_METHOD_NAMES = toArray(list);</span>
<span class="fc" id="L182">                }</span>
            }
        }
<span class="fc" id="L185">    }</span>

    /**
     * &lt;p&gt;Sets the cause of a &lt;code&gt;Throwable&lt;/code&gt; using introspection, allowing
     * source code compatibility between pre-1.4 and post-1.4 Java releases.&lt;/p&gt;
     *
     * &lt;p&gt;The typical use of this method is inside a constructor as in
     * the following example:&lt;/p&gt;
     *
     * &lt;pre&gt;
     * import org.apache.commons.lang.exception.ExceptionUtils;
     *  
     * public class MyException extends Exception {
     *  
     *    public MyException(String msg) {
     *       super(msg);
     *    }
     *
     *    public MyException(String msg, Throwable cause) {
     *       super(msg);
     *       ExceptionUtils.setCause(this, cause);
     *    }
     * }
     * &lt;/pre&gt;
     *
     * @param target  the target &lt;code&gt;Throwable&lt;/code&gt;
     * @param cause  the &lt;code&gt;Throwable&lt;/code&gt; to set in the target
     * @return a &lt;code&gt;true&lt;/code&gt; if the target has been modified
     * @since 2.2
     */
    public static boolean setCause(Throwable target, Throwable cause) {
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L217">            throw new NullPointerException(&quot;target must not be null.&quot;);</span>
        }
<span class="fc" id="L219">        Object[] causeArgs = new Object[]{cause};</span>
<span class="fc" id="L220">        boolean modifiedTarget = false;</span>
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">        if (THROWABLE_INITCAUSE_METHOD != null) {</span>
            try {
<span class="fc" id="L223">                THROWABLE_INITCAUSE_METHOD.invoke(target, causeArgs);</span>
<span class="fc" id="L224">                modifiedTarget = true;</span>
<span class="nc" id="L225">            } catch (IllegalAccessException ignored) {</span>
                // Exception ignored.
<span class="fc" id="L227">            } catch (InvocationTargetException ignored) {</span>
                // Exception ignored.
<span class="pc" id="L229">            }</span>
        }
        try {
<span class="fc" id="L232">            Method setCauseMethod = target.getClass().getMethod(&quot;setCause&quot;, new Class[]{Throwable.class});</span>
<span class="fc" id="L233">            setCauseMethod.invoke(target, causeArgs);</span>
<span class="fc" id="L234">            modifiedTarget = true;</span>
<span class="nc" id="L235">        } catch (NoSuchMethodException ignored) {</span>
            // Exception ignored.
<span class="nc" id="L237">        } catch (IllegalAccessException ignored) {</span>
            // Exception ignored.
<span class="nc" id="L239">        } catch (InvocationTargetException ignored) {</span>
            // Exception ignored.
<span class="pc" id="L241">        }</span>
<span class="fc" id="L242">        return modifiedTarget;</span>
    }

    /**
     * Returns the given list as a &lt;code&gt;String[]&lt;/code&gt;.
     * @param list a list to transform.
     * @return the given list as a &lt;code&gt;String[]&lt;/code&gt;.
     */
    private static String[] toArray(List&lt;String&gt; list) {
<span class="fc" id="L251">        return list.toArray(new String[list.size()]);</span>
    }

    /**
     * Returns {@link #CAUSE_METHOD_NAMES} as a List.
     *
     * @return {@link #CAUSE_METHOD_NAMES} as a List.
     */
    private static ArrayList&lt;String&gt; getCauseMethodNameList() {
<span class="fc" id="L260">        synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc" id="L261">            return new ArrayList&lt;String&gt;(Arrays.asList(CAUSE_METHOD_NAMES));</span>
        }
    }

    /**
     * &lt;p&gt;Tests if the list of method names used in the search for &lt;code&gt;Throwable&lt;/code&gt;
     * objects include the given name.&lt;/p&gt;
     * 
     * @param methodName  the methodName to search in the list.
     * @return if the list of method names used in the search for &lt;code&gt;Throwable&lt;/code&gt;
     *  objects include the given name.
     * @since 2.1
     */
    public static boolean isCauseMethodName(String methodName) {
<span class="fc" id="L275">        synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">            return ArrayUtils.indexOf(CAUSE_METHOD_NAMES, methodName) &gt;= 0;</span>
        }
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the cause.&lt;/p&gt;
     *
     * &lt;p&gt;The method searches for methods with specific names that return a 
     * &lt;code&gt;Throwable&lt;/code&gt; object. This will pick up most wrapping exceptions,
     * including those from JDK 1.4.
     * The method names can be added to using {@link #addCauseMethodName(String)}.&lt;/p&gt;
     *
     * &lt;p&gt;The default list searched for are:&lt;/p&gt;
     * &lt;ul&gt;
     *  &lt;li&gt;&lt;code&gt;getCause()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getNextException()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getTargetException()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getException()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getSourceException()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getRootCause()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getCausedByException()&lt;/code&gt;&lt;/li&gt;
     *  &lt;li&gt;&lt;code&gt;getNested()&lt;/code&gt;&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * &lt;p&gt;In the absence of any such method, the object is inspected for a
     * &lt;code&gt;detail&lt;/code&gt; field assignable to a &lt;code&gt;Throwable&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;If none of the above is found, returns &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
     *
     * @param throwable  the throwable to introspect for a cause, may be null
     * @return the cause of the &lt;code&gt;Throwable&lt;/code&gt;,
     *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
     * @since 1.0
     */
    public static Throwable getCause(Throwable throwable) {
<span class="fc" id="L312">        synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc" id="L313">            return getCause(throwable, CAUSE_METHOD_NAMES);</span>
        }
    }

    /**
     * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the cause.&lt;/p&gt;
     *
     * &lt;ol&gt;
     * &lt;li&gt;Try known exception types.&lt;/li&gt;
     * &lt;li&gt;Try the supplied array of method names.&lt;/li&gt;
     * &lt;li&gt;Try the field 'detail'.&lt;/li&gt;
     * &lt;/ol&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; set of method names means use the default set.
     * A &lt;code&gt;null&lt;/code&gt; in the set of method names will be ignored.&lt;/p&gt;
     *
     * @param throwable  the throwable to introspect for a cause, may be null
     * @param methodNames  the method names, null treated as default set
     * @return the cause of the &lt;code&gt;Throwable&lt;/code&gt;,
     *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
     * @since 1.0
     */
    public static Throwable getCause(Throwable throwable, String[] methodNames) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L337">            return null;</span>
        }
<span class="fc" id="L339">        Throwable cause = getCauseUsingWellKnownTypes(throwable);</span>
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">        if (cause == null) {</span>
<span class="fc bfc" id="L341" title="All 2 branches covered.">            if (methodNames == null) {</span>
<span class="fc" id="L342">                synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="fc" id="L343">                    methodNames = CAUSE_METHOD_NAMES;</span>
<span class="fc" id="L344">                }</span>
            }
<span class="fc bfc" id="L346" title="All 2 branches covered.">            for (int i = 0; i &lt; methodNames.length; i++) {</span>
<span class="fc" id="L347">                String methodName = methodNames[i];</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">                if (methodName != null) {</span>
<span class="fc" id="L349">                    cause = getCauseUsingMethodName(throwable, methodName);</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">                    if (cause != null) {</span>
<span class="fc" id="L351">                        break;</span>
                    }
                }
            }

<span class="fc bfc" id="L356" title="All 2 branches covered.">            if (cause == null) {</span>
<span class="fc" id="L357">                cause = getCauseUsingFieldName(throwable, &quot;detail&quot;);</span>
            }
        }
<span class="fc" id="L360">        return cause;</span>
    }

    /**
     * &lt;p&gt;Introspects the &lt;code&gt;Throwable&lt;/code&gt; to obtain the root cause.&lt;/p&gt;
     *
     * &lt;p&gt;This method walks through the exception chain to the last element,
     * &quot;root&quot; of the tree, using {@link #getCause(Throwable)}, and
     * returns that exception.&lt;/p&gt;
     *
     * &lt;p&gt;From version 2.2, this method handles recursive cause structures
     * that might otherwise cause infinite loops. If the throwable parameter
     * has a cause of itself, then null will be returned. If the throwable
     * parameter cause chain loops, the last element in the chain before the
     * loop is returned.&lt;/p&gt;
     *
     * @param throwable  the throwable to get the root cause for, may be null
     * @return the root cause of the &lt;code&gt;Throwable&lt;/code&gt;,
     *  &lt;code&gt;null&lt;/code&gt; if none found or null throwable input
     */
    public static Throwable getRootCause(Throwable throwable) {
<span class="fc" id="L381">        List&lt;Throwable&gt; list = getThrowableList(throwable);</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        return (list.size() &lt; 2 ? null : (Throwable)list.get(list.size() - 1));</span>
    }

    /**
     * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; for known types.&lt;/p&gt;
     * 
     * &lt;p&gt;Uses &lt;code&gt;instanceof&lt;/code&gt; checks to examine the exception,
     * looking for well known types which could contain chained or
     * wrapped exceptions.&lt;/p&gt;
     *
     * @param throwable  the exception to examine
     * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
     */
    private static Throwable getCauseUsingWellKnownTypes(Throwable throwable) {
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (throwable instanceof SQLException) {</span>
<span class="nc" id="L397">            return ((SQLException) throwable).getNextException();</span>
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">        } else if (throwable instanceof InvocationTargetException) {</span>
<span class="nc" id="L399">            return ((InvocationTargetException) throwable).getTargetException();</span>
        } else {
<span class="fc" id="L401">            return null;</span>
        }
    }

    /**
     * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by method name.&lt;/p&gt;
     *
     * @param throwable  the exception to examine
     * @param methodName  the name of the method to find and invoke
     * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
     */
    private static Throwable getCauseUsingMethodName(Throwable throwable, String methodName) {
<span class="fc" id="L413">        Method method = null;</span>
        try {
<span class="fc" id="L415">            method = throwable.getClass().getMethod(methodName, (Class[]) null);</span>
<span class="fc" id="L416">        } catch (NoSuchMethodException ignored) {</span>
            // exception ignored
<span class="nc" id="L418">        } catch (SecurityException ignored) {</span>
            // exception ignored
<span class="fc" id="L420">        }</span>

<span class="fc bfc" id="L422" title="All 4 branches covered.">        if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {</span>
            try {
<span class="fc" id="L424">                return (Throwable) method.invoke(throwable, ArrayUtils.EMPTY_OBJECT_ARRAY);</span>
<span class="nc" id="L425">            } catch (IllegalAccessException ignored) {</span>
                // exception ignored
<span class="nc" id="L427">            } catch (IllegalArgumentException ignored) {</span>
                // exception ignored
<span class="nc" id="L429">            } catch (InvocationTargetException ignored) {</span>
                // exception ignored
<span class="nc" id="L431">            }</span>
        }
<span class="fc" id="L433">        return null;</span>
    }

    /**
     * &lt;p&gt;Finds a &lt;code&gt;Throwable&lt;/code&gt; by field name.&lt;/p&gt;
     *
     * @param throwable  the exception to examine
     * @param fieldName  the name of the attribute to examine
     * @return the wrapped exception, or &lt;code&gt;null&lt;/code&gt; if not found
     */
    private static Throwable getCauseUsingFieldName(Throwable throwable, String fieldName) {
<span class="fc" id="L444">        Field field = null;</span>
        try {
<span class="nc" id="L446">            field = throwable.getClass().getField(fieldName);</span>
<span class="fc" id="L447">        } catch (NoSuchFieldException ignored) {</span>
            // exception ignored
<span class="nc" id="L449">        } catch (SecurityException ignored) {</span>
            // exception ignored
<span class="pc" id="L451">        }</span>

<span class="pc bpc" id="L453" title="3 of 4 branches missed.">        if (field != null &amp;&amp; Throwable.class.isAssignableFrom(field.getType())) {</span>
            try {
<span class="nc" id="L455">                return (Throwable) field.get(throwable);</span>
<span class="nc" id="L456">            } catch (IllegalAccessException ignored) {</span>
                // exception ignored
<span class="nc" id="L458">            } catch (IllegalArgumentException ignored) {</span>
                // exception ignored
<span class="nc" id="L460">            }</span>
        }
<span class="fc" id="L462">        return null;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Checks if the Throwable class has a &lt;code&gt;getCause&lt;/code&gt; method.&lt;/p&gt;
     *
     * &lt;p&gt;This is true for JDK 1.4 and above.&lt;/p&gt;
     *
     * @return true if Throwable is nestable
     * @since 2.0
     */
    public static boolean isThrowableNested() {
<span class="nc bnc" id="L475" title="All 2 branches missed.">        return THROWABLE_CAUSE_METHOD != null;</span>
    }
    
    /**
     * &lt;p&gt;Checks whether this &lt;code&gt;Throwable&lt;/code&gt; class can store a cause.&lt;/p&gt;
     *
     * &lt;p&gt;This method does &lt;b&gt;not&lt;/b&gt; check whether it actually does store a cause.&lt;p&gt;
     *
     * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to examine, may be null
     * @return boolean &lt;code&gt;true&lt;/code&gt; if nested otherwise &lt;code&gt;false&lt;/code&gt;
     * @since 2.0
     */
    public static boolean isNestedThrowable(Throwable throwable) {
<span class="nc bnc" id="L488" title="All 2 branches missed.">        if (throwable == null) {</span>
<span class="nc" id="L489">            return false;</span>
        }

<span class="nc bnc" id="L492" title="All 2 branches missed.">        if (throwable instanceof SQLException) {</span>
<span class="nc" id="L493">            return true;</span>
<span class="nc bnc" id="L494" title="All 2 branches missed.">        } else if (throwable instanceof InvocationTargetException) {</span>
<span class="nc" id="L495">            return true;</span>
<span class="nc bnc" id="L496" title="All 2 branches missed.">        } else if (isThrowableNested()) {</span>
<span class="nc" id="L497">            return true;</span>
        }

<span class="nc" id="L500">        Class&lt;? extends Throwable&gt; cls = throwable.getClass();</span>
<span class="nc" id="L501">        synchronized(CAUSE_METHOD_NAMES_LOCK) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">            for (int i = 0, isize = CAUSE_METHOD_NAMES.length; i &lt; isize; i++) {</span>
                try {
<span class="nc" id="L504">                    Method method = cls.getMethod(CAUSE_METHOD_NAMES[i], (Class[]) null);</span>
<span class="nc bnc" id="L505" title="All 4 branches missed.">                    if (method != null &amp;&amp; Throwable.class.isAssignableFrom(method.getReturnType())) {</span>
<span class="nc" id="L506">                        return true;</span>
                    }
<span class="nc" id="L508">                } catch (NoSuchMethodException ignored) {</span>
                    // exception ignored
<span class="nc" id="L510">                } catch (SecurityException ignored) {</span>
                    // exception ignored
<span class="nc" id="L512">                }</span>
            }
<span class="nc" id="L514">        }</span>

        try {
<span class="nc" id="L517">            Field field = cls.getField(&quot;detail&quot;);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            if (field != null) {</span>
<span class="nc" id="L519">                return true;</span>
            }
<span class="nc" id="L521">        } catch (NoSuchFieldException ignored) {</span>
            // exception ignored
<span class="nc" id="L523">        } catch (SecurityException ignored) {</span>
            // exception ignored
<span class="nc" id="L525">        }</span>

<span class="nc" id="L527">        return false;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Counts the number of &lt;code&gt;Throwable&lt;/code&gt; objects in the
     * exception chain.&lt;/p&gt;
     *
     * &lt;p&gt;A throwable without cause will return &lt;code&gt;1&lt;/code&gt;.
     * A throwable with one cause will return &lt;code&gt;2&lt;/code&gt; and so on.
     * A &lt;code&gt;null&lt;/code&gt; throwable will return &lt;code&gt;0&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;From version 2.2, this method handles recursive cause structures
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end is reached, or until the next item in the
     * chain is already in the result set.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the count of throwables, zero if null input
     */
    public static int getThrowableCount(Throwable throwable) {
<span class="fc" id="L548">        return getThrowableList(throwable).size();</span>
    }

    /**
     * &lt;p&gt;Returns the list of &lt;code&gt;Throwable&lt;/code&gt; objects in the
     * exception chain.&lt;/p&gt;
     *
     * &lt;p&gt;A throwable without cause will return an array containing
     * one element - the input throwable.
     * A throwable with one cause will return an array containing
     * two elements. - the input throwable and the cause throwable.
     * A &lt;code&gt;null&lt;/code&gt; throwable will return an array of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;From version 2.2, this method handles recursive cause structures
     * that might otherwise cause infinite loops. The cause chain is
     * processed until the end is reached, or until the next item in the
     * chain is already in the result set.&lt;/p&gt;
     *
     * @see #getThrowableList(Throwable)
     * @param throwable  the throwable to inspect, may be null
     * @return the array of throwables, never null
     */
    public static Throwable[] getThrowables(Throwable throwable) {
<span class="fc" id="L571">        List&lt;Throwable&gt; list = getThrowableList(throwable);</span>
<span class="fc" id="L572">        return list.toArray(new Throwable[list.size()]);</span>
    }

    /**
     * &lt;p&gt;Returns the list of &lt;code&gt;Throwable&lt;/code&gt; objects in the
     * exception chain.&lt;/p&gt;
     *
     * &lt;p&gt;A throwable without cause will return a list containing
     * one element - the input throwable.
     * A throwable with one cause will return a list containing
     * two elements. - the input throwable and the cause throwable.
     * A &lt;code&gt;null&lt;/code&gt; throwable will return a list of size zero.&lt;/p&gt;
     *
     * &lt;p&gt;This method handles recursive cause structures that might
     * otherwise cause infinite loops. The cause chain is processed until
     * the end is reached, or until the next item in the chain is already
     * in the result set.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @return the list of throwables, never null
     * @since Commons Lang 2.2
     */
    public static List&lt;Throwable&gt; getThrowableList(Throwable throwable) {
<span class="fc" id="L595">        List&lt;Throwable&gt; list = new ArrayList&lt;Throwable&gt;();</span>
<span class="fc bfc" id="L596" title="All 4 branches covered.">        while (throwable != null &amp;&amp; list.contains(throwable) == false) {</span>
<span class="fc" id="L597">            list.add(throwable);</span>
<span class="fc" id="L598">            throwable = ExceptionUtils.getCause(throwable);</span>
        }
<span class="fc" id="L600">        return list;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Returns the (zero based) index of the first &lt;code&gt;Throwable&lt;/code&gt;
     * that matches the specified class (exactly) in the exception chain.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class)} for the opposite.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; throwable returns &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; type returns &lt;code&gt;-1&lt;/code&gt;.
     * No match in the chain returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(Throwable throwable, Class&lt;?&gt; clazz) {
<span class="fc" id="L619">        return indexOf(throwable, clazz, 0, false);</span>
    }

    /**
     * &lt;p&gt;Returns the (zero based) index of the first &lt;code&gt;Throwable&lt;/code&gt;
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do not match - see
     * {@link #indexOfType(Throwable, Class, int)} for the opposite.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; throwable returns &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; type returns &lt;code&gt;-1&lt;/code&gt;.
     * No match in the chain returns &lt;code&gt;-1&lt;/code&gt;.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param clazz  the class to search for, subclasses do not match, null returns -1
     * @param fromIndex  the (zero based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     */
    public static int indexOfThrowable(Throwable throwable, Class&lt;?&gt; clazz, int fromIndex) {
<span class="fc" id="L642">        return indexOf(throwable, clazz, fromIndex, false);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Returns the (zero based) index of the first &lt;code&gt;Throwable&lt;/code&gt;
     * that matches the specified class or subclass in the exception chain.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; throwable returns &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; type returns &lt;code&gt;-1&lt;/code&gt;.
     * No match in the chain returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(Throwable throwable, Class&lt;?&gt; type) {
<span class="fc" id="L662">        return indexOf(throwable, type, 0, true);</span>
    }

    /**
     * &lt;p&gt;Returns the (zero based) index of the first &lt;code&gt;Throwable&lt;/code&gt;
     * that matches the specified type in the exception chain from
     * a specified index.
     * Subclasses of the specified class do match - see
     * {@link #indexOfThrowable(Throwable, Class)} for the opposite.&lt;/p&gt;
     *
     * &lt;p&gt;A &lt;code&gt;null&lt;/code&gt; throwable returns &lt;code&gt;-1&lt;/code&gt;.
     * A &lt;code&gt;null&lt;/code&gt; type returns &lt;code&gt;-1&lt;/code&gt;.
     * No match in the chain returns &lt;code&gt;-1&lt;/code&gt;.
     * A negative start index is treated as zero.
     * A start index greater than the number of throwables returns &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @return the index into the throwable chain, -1 if no match or null input
     * @since 2.1
     */
    public static int indexOfType(Throwable throwable, Class&lt;?&gt; type, int fromIndex) {
<span class="fc" id="L686">        return indexOf(throwable, type, fromIndex, true);</span>
    }

    /**
     * &lt;p&gt;Worker method for the &lt;code&gt;indexOfType&lt;/code&gt; methods.&lt;/p&gt;
     *
     * @param throwable  the throwable to inspect, may be null
     * @param type  the type to search for, subclasses match, null returns -1
     * @param fromIndex  the (zero based) index of the starting position,
     *  negative treated as zero, larger than chain size returns -1
     * @param subclass if &lt;code&gt;true&lt;/code&gt;, compares with {@link Class#isAssignableFrom(Class)}, otherwise compares
     * using references
     * @return index of the &lt;code&gt;type&lt;/code&gt; within throwables nested withing the specified &lt;code&gt;throwable&lt;/code&gt;
     */
    private static int indexOf(Throwable throwable, Class&lt;?&gt; type, int fromIndex, boolean subclass) {
<span class="fc bfc" id="L701" title="All 4 branches covered.">        if (throwable == null || type == null) {</span>
<span class="fc" id="L702">            return -1;</span>
        }
<span class="fc bfc" id="L704" title="All 2 branches covered.">        if (fromIndex &lt; 0) {</span>
<span class="fc" id="L705">            fromIndex = 0;</span>
        }
<span class="fc" id="L707">        Throwable[] throwables = ExceptionUtils.getThrowables(throwable);</span>
<span class="fc bfc" id="L708" title="All 2 branches covered.">        if (fromIndex &gt;= throwables.length) {</span>
<span class="fc" id="L709">            return -1;</span>
        }
<span class="fc bfc" id="L711" title="All 2 branches covered.">        if (subclass) {</span>
<span class="fc bfc" id="L712" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L713" title="All 2 branches covered.">                if (type.isAssignableFrom(throwables[i].getClass())) {</span>
<span class="fc" id="L714">                    return i;</span>
                }
            }
        } else {
<span class="fc bfc" id="L718" title="All 2 branches covered.">            for (int i = fromIndex; i &lt; throwables.length; i++) {</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">                if (type.equals(throwables[i].getClass())) {</span>
<span class="fc" id="L720">                    return i;</span>
                }
            }
        }
<span class="fc" id="L724">        return -1;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Prints a compact stack trace for the root cause of a throwable
     * to &lt;code&gt;System.err&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to &lt;code&gt;printStackTrace&lt;/code&gt; for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output
     * @since 2.0
     */
    public static void printRootCauseStackTrace(Throwable throwable) {
<span class="fc" id="L747">        printRootCauseStackTrace(throwable, System.err);</span>
<span class="fc" id="L748">    }</span>

    /**
     * &lt;p&gt;Prints a compact stack trace for the root cause of a throwable.&lt;/p&gt;
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to &lt;code&gt;printStackTrace&lt;/code&gt; for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param stream  the stream to output to, may not be null
     * @throws IllegalArgumentException if the stream is &lt;code&gt;null&lt;/code&gt;
     * @since 2.0
     */
    public static void printRootCauseStackTrace(Throwable throwable, PrintStream stream) {
<span class="fc bfc" id="L770" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L771">            return;</span>
        }
<span class="fc bfc" id="L773" title="All 2 branches covered.">        if (stream == null) {</span>
<span class="fc" id="L774">            throw new IllegalArgumentException(&quot;The PrintStream must not be null&quot;);</span>
        }
<span class="fc" id="L776">        String trace[] = getRootCauseStackTrace(throwable);</span>
<span class="fc bfc" id="L777" title="All 2 branches covered.">        for (int i = 0; i &lt; trace.length; i++) {</span>
<span class="fc" id="L778">            stream.println(trace[i]);</span>
        }
<span class="fc" id="L780">        stream.flush();</span>
<span class="fc" id="L781">    }</span>

    /**
     * &lt;p&gt;Prints a compact stack trace for the root cause of a throwable.&lt;/p&gt;
     *
     * &lt;p&gt;The compact stack trace starts with the root cause and prints
     * stack frames up to the place where it was caught and wrapped.
     * Then it prints the wrapped exception and continues with stack frames
     * until the wrapper exception is caught and wrapped again, etc.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * Note that this is the opposite order to the JDK1.4 display.&lt;/p&gt;
     *
     * &lt;p&gt;The method is equivalent to &lt;code&gt;printStackTrace&lt;/code&gt; for throwables
     * that don't have nested causes.&lt;/p&gt;
     *
     * @param throwable  the throwable to output, may be null
     * @param writer  the writer to output to, may not be null
     * @throws IllegalArgumentException if the writer is &lt;code&gt;null&lt;/code&gt;
     * @since 2.0
     */
    public static void printRootCauseStackTrace(Throwable throwable, PrintWriter writer) {
<span class="fc bfc" id="L803" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L804">            return;</span>
        }
<span class="fc bfc" id="L806" title="All 2 branches covered.">        if (writer == null) {</span>
<span class="fc" id="L807">            throw new IllegalArgumentException(&quot;The PrintWriter must not be null&quot;);</span>
        }
<span class="fc" id="L809">        String trace[] = getRootCauseStackTrace(throwable);</span>
<span class="fc bfc" id="L810" title="All 2 branches covered.">        for (int i = 0; i &lt; trace.length; i++) {</span>
<span class="fc" id="L811">            writer.println(trace[i]);</span>
        }
<span class="fc" id="L813">        writer.flush();</span>
<span class="fc" id="L814">    }</span>

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Creates a compact stack trace for the root cause of the supplied
     * &lt;code&gt;Throwable&lt;/code&gt;.&lt;/p&gt;
     *
     * &lt;p&gt;The output of this method is consistent across JDK versions.
     * It consists of the root exception followed by each of its wrapping
     * exceptions separated by '[wrapped]'. Note that this is the opposite
     * order to the JDK1.4 display.&lt;/p&gt;
     *
     * @param throwable  the throwable to examine, may be null
     * @return an array of stack trace frames, never null
     * @since 2.0
     */
    public static String[] getRootCauseStackTrace(Throwable throwable) {
<span class="fc bfc" id="L831" title="All 2 branches covered.">        if (throwable == null) {</span>
<span class="fc" id="L832">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="fc" id="L834">        Throwable throwables[] = getThrowables(throwable);</span>
<span class="fc" id="L835">        int count = throwables.length;</span>
<span class="fc" id="L836">        List&lt;String&gt; frames = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L837">        List&lt;String&gt; nextTrace = getStackFrameList(throwables[count - 1]);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">        for (int i = count; --i &gt;= 0;) {</span>
<span class="fc" id="L839">            List&lt;String&gt; trace = nextTrace;</span>
<span class="fc bfc" id="L840" title="All 2 branches covered.">            if (i != 0) {</span>
<span class="fc" id="L841">                nextTrace = getStackFrameList(throwables[i - 1]);</span>
<span class="fc" id="L842">                removeCommonFrames(trace, nextTrace);</span>
            }
<span class="fc bfc" id="L844" title="All 2 branches covered.">            if (i == count - 1) {</span>
<span class="fc" id="L845">                frames.add(throwables[i].toString());</span>
            } else {
<span class="fc" id="L847">                frames.add(WRAPPED_MARKER + throwables[i].toString());</span>
            }
<span class="fc bfc" id="L849" title="All 2 branches covered.">            for (int j = 0; j &lt; trace.size(); j++) {</span>
<span class="fc" id="L850">                frames.add(trace.get(j));</span>
            }
<span class="fc" id="L852">        }</span>
<span class="fc" id="L853">        return frames.toArray(new String[0]);</span>
    }

    /**
     * &lt;p&gt;Removes common frames from the cause trace given the two stack traces.&lt;/p&gt;
     *
     * @param causeFrames  stack trace of a cause throwable
     * @param wrapperFrames  stack trace of a wrapper throwable
     * @throws IllegalArgumentException if either argument is null
     * @since 2.0
     */
    public static void removeCommonFrames(List&lt;String&gt; causeFrames, List&lt;String&gt; wrapperFrames) {
<span class="pc bpc" id="L865" title="1 of 4 branches missed.">        if (causeFrames == null || wrapperFrames == null) {</span>
<span class="fc" id="L866">            throw new IllegalArgumentException(&quot;The List must not be null&quot;);</span>
        }
<span class="fc" id="L868">        int causeFrameIndex = causeFrames.size() - 1;</span>
<span class="fc" id="L869">        int wrapperFrameIndex = wrapperFrames.size() - 1;</span>
<span class="fc bfc" id="L870" title="All 4 branches covered.">        while (causeFrameIndex &gt;= 0 &amp;&amp; wrapperFrameIndex &gt;= 0) {</span>
            // Remove the frame from the cause trace if it is the same
            // as in the wrapper trace
<span class="fc" id="L873">            String causeFrame = causeFrames.get(causeFrameIndex);</span>
<span class="fc" id="L874">            String wrapperFrame = wrapperFrames.get(wrapperFrameIndex);</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">            if (causeFrame.equals(wrapperFrame)) {</span>
<span class="fc" id="L876">                causeFrames.remove(causeFrameIndex);</span>
            }
<span class="fc" id="L878">            causeFrameIndex--;</span>
<span class="fc" id="L879">            wrapperFrameIndex--;</span>
<span class="fc" id="L880">        }</span>
<span class="fc" id="L881">    }</span>

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;A way to get the entire nested stack-trace of an throwable.&lt;/p&gt;
     *
     * &lt;p&gt;The result of this method is highly dependent on the JDK version
     * and whether the exceptions override printStackTrace or not.&lt;/p&gt;
     *
     * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to be examined
     * @return the nested stack trace, with the root cause first
     * @since 2.0
     */
    public static String getFullStackTrace(Throwable throwable) {
<span class="nc" id="L895">        StringWriter sw = new StringWriter();</span>
<span class="nc" id="L896">        PrintWriter pw = new PrintWriter(sw, true);</span>
<span class="nc" id="L897">        Throwable[] ts = getThrowables(throwable);</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">        for (int i = 0; i &lt; ts.length; i++) {</span>
<span class="nc" id="L899">            ts[i].printStackTrace(pw);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">            if (isNestedThrowable(ts[i])) {</span>
<span class="nc" id="L901">                break;</span>
            }
        }
<span class="nc" id="L904">        return sw.getBuffer().toString();</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Gets the stack trace from a Throwable as a String.&lt;/p&gt;
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to be examined
     * @return the stack trace as generated by the exception's
     *  &lt;code&gt;printStackTrace(PrintWriter)&lt;/code&gt; method
     */
    public static String getStackTrace(Throwable throwable) {
<span class="fc" id="L921">        StringWriter sw = new StringWriter();</span>
<span class="fc" id="L922">        PrintWriter pw = new PrintWriter(sw, true);</span>
<span class="fc" id="L923">        throwable.printStackTrace(pw);</span>
<span class="fc" id="L924">        return sw.getBuffer().toString();</span>
    }

    /**
     * &lt;p&gt;Captures the stack trace associated with the specified
     * &lt;code&gt;Throwable&lt;/code&gt; object, decomposing it into a list of
     * stack frames.&lt;/p&gt;
     *
     * &lt;p&gt;The result of this method vary by JDK version as this method
     * uses {@link Throwable#printStackTrace(java.io.PrintWriter)}.
     * On JDK1.3 and earlier, the cause exception will not be shown
     * unless the specified throwable alters printStackTrace.&lt;/p&gt;
     *
     * @param throwable  the &lt;code&gt;Throwable&lt;/code&gt; to examine, may be null
     * @return an array of strings describing each stack frame, never null
     */
    public static String[] getStackFrames(Throwable throwable) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">        if (throwable == null) {</span>
<span class="nc" id="L942">            return ArrayUtils.EMPTY_STRING_ARRAY;</span>
        }
<span class="nc" id="L944">        return getStackFrames(getStackTrace(throwable));</span>
    }

    //-----------------------------------------------------------------------
    /**
     * &lt;p&gt;Returns an array where each element is a line from the argument.&lt;/p&gt;
     *
     * &lt;p&gt;The end of line is determined by the value of {@link SystemUtils#LINE_SEPARATOR}.&lt;/p&gt;
     *
     * @param stackTrace  a stack trace String
     * @return an array where each element is a line from the argument
     */
    static String[] getStackFrames(String stackTrace) {
<span class="nc" id="L957">        String linebreak = SystemUtils.LINE_SEPARATOR;</span>
<span class="nc" id="L958">        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="nc" id="L959">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">        while (frames.hasMoreTokens()) {</span>
<span class="nc" id="L961">            list.add(frames.nextToken());</span>
        }
<span class="nc" id="L963">        return toArray(list);</span>
    }

    /**
     * &lt;p&gt;Produces a &lt;code&gt;List&lt;/code&gt; of stack frames - the message
     * is not included. Only the trace of the specified exception is
     * returned, any caused by trace is stripped.&lt;/p&gt;
     *
     * &lt;p&gt;This works in most cases - it will only fail if the exception
     * message contains a line that starts with:
     * &lt;code&gt;&amp;quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;at&amp;quot;.&lt;/code&gt;&lt;/p&gt;
     * 
     * @param t is any throwable
     * @return List of stack frames
     */
    static List&lt;String&gt; getStackFrameList(Throwable t) {
<span class="fc" id="L979">        String stackTrace = getStackTrace(t);</span>
<span class="fc" id="L980">        String linebreak = SystemUtils.LINE_SEPARATOR;</span>
<span class="fc" id="L981">        StringTokenizer frames = new StringTokenizer(stackTrace, linebreak);</span>
<span class="fc" id="L982">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L983">        boolean traceStarted = false;</span>
<span class="fc bfc" id="L984" title="All 2 branches covered.">        while (frames.hasMoreTokens()) {</span>
<span class="fc" id="L985">            String token = frames.nextToken();</span>
            // Determine if the line starts with &lt;whitespace&gt;at
<span class="fc" id="L987">            int at = token.indexOf(&quot;at&quot;);</span>
<span class="pc bpc" id="L988" title="1 of 4 branches missed.">            if (at != -1 &amp;&amp; token.substring(0, at).trim().length() == 0) {</span>
<span class="fc" id="L989">                traceStarted = true;</span>
<span class="fc" id="L990">                list.add(token);</span>
<span class="fc bfc" id="L991" title="All 2 branches covered.">            } else if (traceStarted) {</span>
<span class="fc" id="L992">                break;</span>
            }
<span class="fc" id="L994">        }</span>
<span class="fc" id="L995">        return list;</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets a short message summarising the exception.
     * &lt;p&gt;
     * The message returned is of the form
     * {ClassNameWithoutPackage}: {ThrowableMessage}
     *
     * @param th  the throwable to get a message for, null returns empty string
     * @return the message, non-null
     * @since Commons Lang 2.2
     */
    public static String getMessage(Throwable th) {
<span class="fc bfc" id="L1010" title="All 2 branches covered.">        if (th == null) {</span>
<span class="fc" id="L1011">            return &quot;&quot;;</span>
        }
<span class="fc" id="L1013">        String clsName = ClassUtils.getShortClassName(th, null);</span>
<span class="fc" id="L1014">        String msg = th.getMessage();</span>
<span class="fc" id="L1015">        return clsName + &quot;: &quot; + StringUtils.defaultString(msg);</span>
    }

    //-----------------------------------------------------------------------
    /**
     * Gets a short message summarising the root cause exception.
     * &lt;p&gt;
     * The message returned is of the form
     * {ClassNameWithoutPackage}: {ThrowableMessage}
     *
     * @param th  the throwable to get a message for, null returns empty string
     * @return the message, non-null
     * @since Commons Lang 2.2
     */
    public static String getRootCauseMessage(Throwable th) {
<span class="fc" id="L1030">        Throwable root = ExceptionUtils.getRootCause(th);</span>
<span class="fc bfc" id="L1031" title="All 2 branches covered.">        root = (root == null ? th : root);</span>
<span class="fc" id="L1032">        return getMessage(root);</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span></div></body></html>